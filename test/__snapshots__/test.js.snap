// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`with processors BufferSourceTypes.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"BufferSourceTypes\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'BufferSourceTypes'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"BufferSourceTypes\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor BufferSourceTypes is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class BufferSourceTypes {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    bs(source) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'bs' on 'BufferSourceTypes': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (utils.isArrayBuffer(curArg)) {
        } else if (ArrayBuffer.isView(curArg)) {
        } else {
          throw new TypeError(
            \\"Failed to execute 'bs' on 'BufferSourceTypes': parameter 1\\" + \\" is not of any supported type.\\"
          );
        }
        args.push(curArg);
      }
      return this[impl].bs(...args);
    }

    ab(ab) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'ab' on 'BufferSourceTypes': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"ArrayBuffer\\"](curArg, {
          context: \\"Failed to execute 'ab' on 'BufferSourceTypes': parameter 1\\"
        });
        args.push(curArg);
      }
      return this[impl].ab(...args);
    }

    abv(abv) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'abv' on 'BufferSourceTypes': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (ArrayBuffer.isView(curArg)) {
        } else {
          throw new TypeError(
            \\"Failed to execute 'abv' on 'BufferSourceTypes': parameter 1\\" + \\" is not of any supported type.\\"
          );
        }
        args.push(curArg);
      }
      return this[impl].abv(...args);
    }

    u8a(u8) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'u8a' on 'BufferSourceTypes': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"Uint8Array\\"](curArg, {
          context: \\"Failed to execute 'u8a' on 'BufferSourceTypes': parameter 1\\"
        });
        args.push(curArg);
      }
      return this[impl].u8a(...args);
    }

    abUnion(ab) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'abUnion' on 'BufferSourceTypes': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (utils.isArrayBuffer(curArg)) {
        } else {
          curArg = conversions[\\"DOMString\\"](curArg, {
            context: \\"Failed to execute 'abUnion' on 'BufferSourceTypes': parameter 1\\"
          });
        }
        args.push(curArg);
      }
      return this[impl].abUnion(...args);
    }

    u8aUnion(ab) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'u8aUnion' on 'BufferSourceTypes': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (ArrayBuffer.isView(curArg) && curArg.constructor.name === \\"Uint8Array\\") {
        } else {
          curArg = conversions[\\"DOMString\\"](curArg, {
            context: \\"Failed to execute 'u8aUnion' on 'BufferSourceTypes': parameter 1\\"
          });
        }
        args.push(curArg);
      }
      return this[impl].u8aUnion(...args);
    }
  }
  Object.defineProperties(BufferSourceTypes.prototype, {
    bs: { enumerable: true },
    ab: { enumerable: true },
    abv: { enumerable: true },
    u8a: { enumerable: true },
    abUnion: { enumerable: true },
    u8aUnion: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"BufferSourceTypes\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = BufferSourceTypes;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: BufferSourceTypes
  });
};

const Impl = require(\\"../implementations/BufferSourceTypes.js\\");
"
`;

exports[`with processors CEReactions.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const CEReactions = require(\\"../CEReactions.js\\");
const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"CEReactions\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'CEReactions'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"CEReactions\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor CEReactions is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  {
    let proxyHandler = proxyHandlerCache.get(globalObject);
    if (proxyHandler === undefined) {
      proxyHandler = new ProxyHandler(globalObject);
      proxyHandlerCache.set(globalObject, proxyHandler);
    }
    obj = new Proxy(obj, proxyHandler);
  }

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class CEReactions {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    method() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      CEReactions.preSteps(globalObject);
      try {
        return this[impl].method();
      } finally {
        CEReactions.postSteps(globalObject);
      }
    }

    get attr() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      CEReactions.preSteps(globalObject);
      try {
        return this[impl][\\"attr\\"];
      } finally {
        CEReactions.postSteps(globalObject);
      }
    }

    set attr(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"DOMString\\"](V, {
        context: \\"Failed to set the 'attr' property on 'CEReactions': The provided value\\"
      });

      CEReactions.preSteps(globalObject);
      try {
        this[impl][\\"attr\\"] = V;
      } finally {
        CEReactions.postSteps(globalObject);
      }
    }
  }
  Object.defineProperties(CEReactions.prototype, {
    method: { enumerable: true },
    attr: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"CEReactions\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = CEReactions;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: CEReactions
  });
};

const proxyHandlerCache = new WeakMap();
class ProxyHandler {
  constructor(globalObject) {
    this._globalObject = globalObject;
  }

  get(target, P, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.get(target, P, receiver);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc === undefined) {
      const parent = Object.getPrototypeOf(target);
      if (parent === null) {
        return undefined;
      }
      return Reflect.get(target, P, receiver);
    }
    if (!desc.get && !desc.set) {
      return desc.value;
    }
    const getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return Reflect.apply(getter, receiver, []);
  }

  has(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.has(target, P);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc !== undefined) {
      return true;
    }
    const parent = Object.getPrototypeOf(target);
    if (parent !== null) {
      return Reflect.has(parent, P);
    }
    return false;
  }

  ownKeys(target) {
    const keys = new Set();

    for (const key of target[impl][utils.supportedPropertyNames]) {
      if (!(key in target)) {
        keys.add(\`\${key}\`);
      }
    }

    for (const key of Reflect.ownKeys(target)) {
      keys.add(key);
    }
    return [...keys];
  }

  getOwnPropertyDescriptor(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.getOwnPropertyDescriptor(target, P);
    }
    let ignoreNamedProps = false;

    if (target[impl][utils.supportsPropertyName](P) && !(P in target) && !ignoreNamedProps) {
      const namedValue = target[impl][utils.namedGet](P);

      return {
        writable: true,
        enumerable: true,
        configurable: true,
        value: utils.tryWrapperForImpl(namedValue)
      };
    }

    return Reflect.getOwnPropertyDescriptor(target, P);
  }

  set(target, P, V, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.set(target, P, V, receiver);
    }
    if (target === receiver) {
      const globalObject = this._globalObject;

      if (typeof P === \\"string\\" && !utils.isArrayIndexPropName(P)) {
        let namedValue = V;

        namedValue = conversions[\\"DOMString\\"](namedValue, {
          context: \\"Failed to set the '\\" + P + \\"' property on 'CEReactions': The provided value\\"
        });

        CEReactions.preSteps(globalObject);
        try {
          const creating = !target[impl][utils.supportsPropertyName](P);
          if (creating) {
            target[impl][utils.namedSetNew](P, namedValue);
          } else {
            target[impl][utils.namedSetExisting](P, namedValue);
          }
        } finally {
          CEReactions.postSteps(globalObject);
        }

        return true;
      }
    }
    let ownDesc;

    if (ownDesc === undefined) {
      ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
    }
    if (ownDesc === undefined) {
      const parent = Reflect.getPrototypeOf(target);
      if (parent !== null) {
        return Reflect.set(parent, P, V, receiver);
      }
      ownDesc = { writable: true, enumerable: true, configurable: true, value: undefined };
    }
    if (!ownDesc.writable) {
      return false;
    }
    if (!utils.isObject(receiver)) {
      return false;
    }
    const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
    let valueDesc;
    if (existingDesc !== undefined) {
      if (existingDesc.get || existingDesc.set) {
        return false;
      }
      if (!existingDesc.writable) {
        return false;
      }
      valueDesc = { value: V };
    } else {
      valueDesc = { writable: true, enumerable: true, configurable: true, value: V };
    }
    return Reflect.defineProperty(receiver, P, valueDesc);
  }

  defineProperty(target, P, desc) {
    if (typeof P === \\"symbol\\") {
      return Reflect.defineProperty(target, P, desc);
    }

    const globalObject = this._globalObject;
    if (!utils.hasOwn(target, P)) {
      if (desc.get || desc.set) {
        return false;
      }

      let namedValue = desc.value;

      namedValue = conversions[\\"DOMString\\"](namedValue, {
        context: \\"Failed to set the '\\" + P + \\"' property on 'CEReactions': The provided value\\"
      });

      CEReactions.preSteps(globalObject);
      try {
        const creating = !target[impl][utils.supportsPropertyName](P);
        if (creating) {
          target[impl][utils.namedSetNew](P, namedValue);
        } else {
          target[impl][utils.namedSetExisting](P, namedValue);
        }
      } finally {
        CEReactions.postSteps(globalObject);
      }

      return true;
    }
    return Reflect.defineProperty(target, P, desc);
  }

  deleteProperty(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.deleteProperty(target, P);
    }

    const globalObject = this._globalObject;

    if (target[impl][utils.supportsPropertyName](P) && !(P in target)) {
      CEReactions.preSteps(globalObject);
      try {
        target[impl][utils.namedDelete](P);
        return true;
      } finally {
        CEReactions.postSteps(globalObject);
      }
    }

    return Reflect.deleteProperty(target, P);
  }

  preventExtensions() {
    return false;
  }
}

const Impl = require(\\"../implementations/CEReactions.js\\");
"
`;

exports[`with processors DOMImplementation.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"DOMImplementation\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'DOMImplementation'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"DOMImplementation\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor DOMImplementation is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class DOMImplementation {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    createDocumentType(qualifiedName, publicId, systemId) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 3) {
        throw new TypeError(
          \\"Failed to execute 'createDocumentType' on 'DOMImplementation': 3 arguments required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'createDocumentType' on 'DOMImplementation': parameter 1\\"
        });
        args.push(curArg);
      }
      {
        let curArg = arguments[1];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'createDocumentType' on 'DOMImplementation': parameter 2\\"
        });
        args.push(curArg);
      }
      {
        let curArg = arguments[2];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'createDocumentType' on 'DOMImplementation': parameter 3\\"
        });
        args.push(curArg);
      }
      return utils.tryWrapperForImpl(this[impl].createDocumentType(...args));
    }

    createDocument(namespace, qualifiedName) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 2) {
        throw new TypeError(
          \\"Failed to execute 'createDocument' on 'DOMImplementation': 2 arguments required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg === null || curArg === undefined) {
          curArg = null;
        } else {
          curArg = conversions[\\"DOMString\\"](curArg, {
            context: \\"Failed to execute 'createDocument' on 'DOMImplementation': parameter 1\\"
          });
        }
        args.push(curArg);
      }
      {
        let curArg = arguments[1];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'createDocument' on 'DOMImplementation': parameter 2\\",
          treatNullAsEmptyString: true
        });
        args.push(curArg);
      }
      {
        let curArg = arguments[2];
        if (curArg !== undefined) {
          if (curArg === null || curArg === undefined) {
            curArg = null;
          } else {
            curArg = utils.tryImplForWrapper(curArg);
          }
        } else {
          curArg = null;
        }
        args.push(curArg);
      }
      return utils.tryWrapperForImpl(this[impl].createDocument(...args));
    }

    createHTMLDocument() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg !== undefined) {
          curArg = conversions[\\"DOMString\\"](curArg, {
            context: \\"Failed to execute 'createHTMLDocument' on 'DOMImplementation': parameter 1\\"
          });
        }
        args.push(curArg);
      }
      return utils.tryWrapperForImpl(this[impl].createHTMLDocument(...args));
    }

    hasFeature() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl].hasFeature();
    }
  }
  Object.defineProperties(DOMImplementation.prototype, {
    createDocumentType: { enumerable: true },
    createDocument: { enumerable: true },
    createHTMLDocument: { enumerable: true },
    hasFeature: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"DOMImplementation\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = DOMImplementation;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: DOMImplementation
  });
};

const Impl = require(\\"../implementations/DOMImplementation.js\\");
"
`;

exports[`with processors Dictionary.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const convertURL = require(\\"./URL.js\\").convert;
const convertURLSearchParams = require(\\"./URLSearchParams.js\\").convert;

exports.convertInherit = function convertInherit(obj, ret, { context = \\"The provided value\\" } = {}) {
  {
    const key = \\"boolWithDefault\\";
    let value = obj === undefined || obj === null ? undefined : obj[key];
    if (value !== undefined) {
      value = conversions[\\"boolean\\"](value, { context: context + \\" has member boolWithDefault that\\" });

      ret[key] = value;
    } else {
      ret[key] = false;
    }
  }

  {
    const key = \\"requiredInterface\\";
    let value = obj === undefined || obj === null ? undefined : obj[key];
    if (value !== undefined) {
      value = convertURL(value, { context: context + \\" has member requiredInterface that\\" });

      ret[key] = value;
    } else {
      throw new TypeError(\\"requiredInterface is required in 'Dictionary'\\");
    }
  }

  {
    const key = \\"seq\\";
    let value = obj === undefined || obj === null ? undefined : obj[key];
    if (value !== undefined) {
      if (!utils.isObject(value)) {
        throw new TypeError(context + \\" has member seq that\\" + \\" is not an iterable object.\\");
      } else {
        const V = [];
        const tmp = value;
        for (let nextItem of tmp) {
          nextItem = convertURLSearchParams(nextItem, { context: context + \\" has member seq that\\" + \\"'s element\\" });

          V.push(nextItem);
        }
        value = V;
      }

      ret[key] = value;
    }
  }

  {
    const key = \\"vanillaString\\";
    let value = obj === undefined || obj === null ? undefined : obj[key];
    if (value !== undefined) {
      value = conversions[\\"DOMString\\"](value, { context: context + \\" has member vanillaString that\\" });

      ret[key] = value;
    }
  }
};

exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (obj !== undefined && typeof obj !== \\"object\\" && typeof obj !== \\"function\\") {
    throw new TypeError(\`\${context} is not an object.\`);
  }

  const ret = Object.create(null);
  module.exports.convertInherit(obj, ret, { context });
  return ret;
};
"
`;

exports[`with processors DictionaryConvert.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const convertDictionary = require(\\"./Dictionary.js\\").convert;
const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"DictionaryConvert\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'DictionaryConvert'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"DictionaryConvert\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor DictionaryConvert is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class DictionaryConvert {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    op() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg !== undefined) {
          curArg = conversions[\\"DOMString\\"](curArg, {
            context: \\"Failed to execute 'op' on 'DictionaryConvert': parameter 1\\"
          });
        }
        args.push(curArg);
      }
      {
        let curArg = arguments[1];
        curArg = convertDictionary(curArg, { context: \\"Failed to execute 'op' on 'DictionaryConvert': parameter 2\\" });
        args.push(curArg);
      }
      return this[impl].op(...args);
    }
  }
  Object.defineProperties(DictionaryConvert.prototype, {
    op: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"DictionaryConvert\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = DictionaryConvert;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: DictionaryConvert
  });
};

const Impl = require(\\"../implementations/DictionaryConvert.js\\");
"
`;

exports[`with processors Enum.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const convertRequestDestination = require(\\"./RequestDestination.js\\").convert;
const RequestDestination = require(\\"./RequestDestination.js\\");
const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"Enum\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'Enum'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"Enum\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor Enum is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class Enum {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    op(destination) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'op' on 'Enum': 1 argument required, but only \\" + arguments.length + \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = convertRequestDestination(curArg, { context: \\"Failed to execute 'op' on 'Enum': parameter 1\\" });
        args.push(curArg);
      }
      return this[impl].op(...args);
    }

    get attr() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return utils.tryWrapperForImpl(this[impl][\\"attr\\"]);
    }

    set attr(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = \`\${V}\`;
      if (!RequestDestination.enumerationValues.has(V)) {
        return;
      }

      this[impl][\\"attr\\"] = V;
    }
  }
  Object.defineProperties(Enum.prototype, {
    op: { enumerable: true },
    attr: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"Enum\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = Enum;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: Enum
  });
};

const Impl = require(\\"../implementations/Enum.js\\");
"
`;

exports[`with processors Global.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"Global\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'Global'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"Global\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor Global is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {
  Object.defineProperties(
    obj,
    Object.getOwnPropertyDescriptors({
      op() {
        if (!this || !exports.is(this)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return this[impl].op();
      },
      unforgeableOp() {
        if (!this || !exports.is(this)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return this[impl].unforgeableOp();
      },
      get attr() {
        if (!this || !exports.is(this)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return obj[impl][\\"attr\\"];
      },
      set attr(V) {
        if (!this || !exports.is(this)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        V = conversions[\\"DOMString\\"](V, {
          context: \\"Failed to set the 'attr' property on 'Global': The provided value\\"
        });

        obj[impl][\\"attr\\"] = V;
      },
      get unforgeableAttr() {
        if (!this || !exports.is(this)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return obj[impl][\\"unforgeableAttr\\"];
      },
      set unforgeableAttr(V) {
        if (!this || !exports.is(this)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        V = conversions[\\"DOMString\\"](V, {
          context: \\"Failed to set the 'unforgeableAttr' property on 'Global': The provided value\\"
        });

        obj[impl][\\"unforgeableAttr\\"] = V;
      },
      get length() {
        if (!this || !exports.is(this)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return obj[impl][\\"length\\"];
      },
      set length(V) {
        if (!this || !exports.is(this)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        V = conversions[\\"unsigned long\\"](V, {
          context: \\"Failed to set the 'length' property on 'Global': The provided value\\"
        });

        obj[impl][\\"length\\"] = V;
      },
      [Symbol.iterator]: Array.prototype[Symbol.iterator],
      keys: Array.prototype.keys,
      values: Array.prototype[Symbol.iterator],
      entries: Array.prototype.entries,
      forEach: Array.prototype.forEach
    })
  );

  Object.defineProperties(obj, {
    unforgeableOp: { configurable: false, writable: false },
    unforgeableAttr: { configurable: false },
    [Symbol.iterator]: { enumerable: false }
  });
};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class Global {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }
  }
  Object.defineProperties(Global.prototype, { [Symbol.toStringTag]: { value: \\"Global\\", configurable: true } });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = Global;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: Global
  });
};

const Impl = require(\\"../implementations/Global.js\\");
"
`;

exports[`with processors HTMLConstructor.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const HTMLConstructor_HTMLConstructor = require(\\"../HTMLConstructor.js\\").HTMLConstructor;
const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"HTMLConstructor\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'HTMLConstructor'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"HTMLConstructor\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor HTMLConstructor is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class HTMLConstructor {
    constructor() {
      return HTMLConstructor_HTMLConstructor(globalObject, interfaceName);
    }
  }
  Object.defineProperties(HTMLConstructor.prototype, {
    [Symbol.toStringTag]: { value: \\"HTMLConstructor\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = HTMLConstructor;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: HTMLConstructor
  });
};

const Impl = require(\\"../implementations/HTMLConstructor.js\\");
"
`;

exports[`with processors LegacyArrayClass.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"LegacyArrayClass\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'LegacyArrayClass'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"LegacyArrayClass\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor LegacyArrayClass is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class LegacyArrayClass {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    get length() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"length\\"];
    }
  }
  Object.setPrototypeOf(LegacyArrayClass.prototype, Array.prototype);
  Object.defineProperties(LegacyArrayClass.prototype, {
    length: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"LegacyArrayClass\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = LegacyArrayClass;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: LegacyArrayClass
  });
};

const Impl = require(\\"../implementations/LegacyArrayClass.js\\");
"
`;

exports[`with processors MixedIn.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"MixedIn\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'MixedIn'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"MixedIn\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor MixedIn is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class MixedIn {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    mixedInOp() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl].mixedInOp();
    }

    ifaceMixinOp() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl].ifaceMixinOp();
    }

    get mixedInAttr() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"mixedInAttr\\"];
    }

    set mixedInAttr(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"DOMString\\"](V, {
        context: \\"Failed to set the 'mixedInAttr' property on 'MixedIn': The provided value\\"
      });

      this[impl][\\"mixedInAttr\\"] = V;
    }

    get ifaceMixinAttr() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"ifaceMixinAttr\\"];
    }

    set ifaceMixinAttr(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"DOMString\\"](V, {
        context: \\"Failed to set the 'ifaceMixinAttr' property on 'MixedIn': The provided value\\"
      });

      this[impl][\\"ifaceMixinAttr\\"] = V;
    }
  }
  Object.defineProperties(MixedIn.prototype, {
    mixedInOp: { enumerable: true },
    ifaceMixinOp: { enumerable: true },
    mixedInAttr: { enumerable: true },
    ifaceMixinAttr: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"MixedIn\\", configurable: true },
    mixedInConst: { value: 43, enumerable: true },
    ifaceMixinConst: { value: 42, enumerable: true }
  });
  Object.defineProperties(MixedIn, {
    mixedInConst: { value: 43, enumerable: true },
    ifaceMixinConst: { value: 42, enumerable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = MixedIn;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: MixedIn
  });
};

const Impl = require(\\"../implementations/MixedIn.js\\");
"
`;

exports[`with processors Overloads.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const isURL = require(\\"./URL.js\\").is;
const convertURL = require(\\"./URL.js\\").convert;
const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"Overloads\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'Overloads'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"Overloads\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor Overloads is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class Overloads {
    constructor() {
      const args = [];
      switch (arguments.length) {
        case 0:
          break;
        default: {
          let curArg = arguments[0];
          if (isURL(curArg)) {
            {
              let curArg = arguments[0];
              curArg = convertURL(curArg, { context: \\"Failed to construct 'Overloads': parameter 1\\" });
              args.push(curArg);
            }
          } else {
            {
              let curArg = arguments[0];
              curArg = conversions[\\"DOMString\\"](curArg, { context: \\"Failed to construct 'Overloads': parameter 1\\" });
              args.push(curArg);
            }
          }
        }
      }
      return exports.setup(Object.create(new.target.prototype), globalObject, args);
    }

    compatible(arg1) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'compatible' on 'Overloads': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      switch (arguments.length) {
        case 1:
          {
            let curArg = arguments[0];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'compatible' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
          break;
        case 2:
          {
            let curArg = arguments[0];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'compatible' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'compatible' on 'Overloads': parameter 2\\"
            });
            args.push(curArg);
          }
          break;
        default:
          {
            let curArg = arguments[0];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'compatible' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'compatible' on 'Overloads': parameter 2\\"
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[2];
            if (curArg !== undefined) {
              curArg = conversions[\\"long\\"](curArg, {
                context: \\"Failed to execute 'compatible' on 'Overloads': parameter 3\\"
              });
            } else {
              curArg = 0;
            }
            args.push(curArg);
          }
      }
      return utils.tryWrapperForImpl(this[impl].compatible(...args));
    }

    incompatible1(arg1) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'incompatible1' on 'Overloads': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (typeof curArg === \\"number\\") {
          {
            let curArg = arguments[0];
            curArg = conversions[\\"long\\"](curArg, {
              context: \\"Failed to execute 'incompatible1' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
        } else {
          {
            let curArg = arguments[0];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'incompatible1' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
        }
      }
      return this[impl].incompatible1(...args);
    }

    incompatible2(arg1) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'incompatible2' on 'Overloads': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      switch (arguments.length) {
        case 1:
          {
            let curArg = arguments[0];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'incompatible2' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
          break;
        default:
          {
            let curArg = arguments[0];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'incompatible2' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'incompatible2' on 'Overloads': parameter 2\\"
            });
            args.push(curArg);
          }
      }
      return this[impl].incompatible2(...args);
    }

    incompatible3(arg1) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'incompatible3' on 'Overloads': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      switch (arguments.length) {
        case 1:
          {
            let curArg = arguments[0];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'incompatible3' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
          break;
        case 2:
          {
            let curArg = arguments[0];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'incompatible3' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            if (curArg === undefined) {
              {
                let curArg = arguments[1];
                if (curArg !== undefined) {
                  curArg = convertURL(curArg, {
                    context: \\"Failed to execute 'incompatible3' on 'Overloads': parameter 2\\"
                  });
                }
                args.push(curArg);
              }
            } else if (isURL(curArg)) {
              {
                let curArg = arguments[1];
                if (curArg !== undefined) {
                  curArg = convertURL(curArg, {
                    context: \\"Failed to execute 'incompatible3' on 'Overloads': parameter 2\\"
                  });
                }
                args.push(curArg);
              }
            } else if (utils.isArrayBuffer(curArg)) {
              {
                let curArg = arguments[1];
                if (utils.isArrayBuffer(curArg)) {
                } else if (ArrayBuffer.isView(curArg)) {
                } else {
                  throw new TypeError(
                    \\"Failed to execute 'incompatible3' on 'Overloads': parameter 2\\" + \\" is not of any supported type.\\"
                  );
                }
                args.push(curArg);
              }
            } else if (ArrayBuffer.isView(curArg)) {
              {
                let curArg = arguments[1];
                if (utils.isArrayBuffer(curArg)) {
                } else if (ArrayBuffer.isView(curArg)) {
                } else {
                  throw new TypeError(
                    \\"Failed to execute 'incompatible3' on 'Overloads': parameter 2\\" + \\" is not of any supported type.\\"
                  );
                }
                args.push(curArg);
              }
            } else {
              {
                let curArg = arguments[1];
                curArg = conversions[\\"DOMString\\"](curArg, {
                  context: \\"Failed to execute 'incompatible3' on 'Overloads': parameter 2\\"
                });
                args.push(curArg);
              }
            }
          }
          break;
        case 3:
          throw new TypeError(
            \\"Failed to execute 'incompatible3' on 'Overloads': only \\" + arguments.length + \\" arguments present.\\"
          );
          break;
        default:
          {
            let curArg = arguments[0];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'incompatible3' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            curArg = conversions[\\"long\\"](curArg, {
              context: \\"Failed to execute 'incompatible3' on 'Overloads': parameter 2\\"
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[2];
            if (utils.isArrayBuffer(curArg)) {
            } else if (ArrayBuffer.isView(curArg)) {
            } else {
              throw new TypeError(
                \\"Failed to execute 'incompatible3' on 'Overloads': parameter 3\\" + \\" is not of any supported type.\\"
              );
            }
            args.push(curArg);
          }
          {
            let curArg = arguments[3];
            if (utils.isArrayBuffer(curArg)) {
            } else if (ArrayBuffer.isView(curArg)) {
            } else {
              throw new TypeError(
                \\"Failed to execute 'incompatible3' on 'Overloads': parameter 4\\" + \\" is not of any supported type.\\"
              );
            }
            args.push(curArg);
          }
      }
      return this[impl].incompatible3(...args);
    }
  }
  Object.defineProperties(Overloads.prototype, {
    compatible: { enumerable: true },
    incompatible1: { enumerable: true },
    incompatible2: { enumerable: true },
    incompatible3: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"Overloads\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = Overloads;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: Overloads
  });
};

const Impl = require(\\"../implementations/Overloads.js\\");
"
`;

exports[`with processors PromiseTypes.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"PromiseTypes\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'PromiseTypes'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"PromiseTypes\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor PromiseTypes is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class PromiseTypes {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    voidPromiseConsumer(p) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'voidPromiseConsumer' on 'PromiseTypes': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = Promise.resolve(curArg).then(
          value => {},
          reason => reason
        );
        args.push(curArg);
      }
      return this[impl].voidPromiseConsumer(...args);
    }

    promiseConsumer(p) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'promiseConsumer' on 'PromiseTypes': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = Promise.resolve(curArg).then(
          value => {
            value = conversions[\\"double\\"](value, {
              context: \\"Failed to execute 'promiseConsumer' on 'PromiseTypes': parameter 1\\" + \\" promise value\\"
            });

            return value;
          },
          reason => reason
        );
        args.push(curArg);
      }
      return this[impl].promiseConsumer(...args);
    }
  }
  Object.defineProperties(PromiseTypes.prototype, {
    voidPromiseConsumer: { enumerable: true },
    promiseConsumer: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"PromiseTypes\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = PromiseTypes;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: PromiseTypes
  });
};

const Impl = require(\\"../implementations/PromiseTypes.js\\");
"
`;

exports[`with processors Reflect.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"Reflect\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'Reflect'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"Reflect\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor Reflect is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class Reflect {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    get ReflectedBoolean() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl].hasAttributeNS(null, \\"reflectedboolean\\");
    }

    set ReflectedBoolean(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"boolean\\"](V, {
        context: \\"Failed to set the 'ReflectedBoolean' property on 'Reflect': The provided value\\"
      });

      if (V) {
        this[impl].setAttributeNS(null, \\"reflectedboolean\\", \\"\\");
      } else {
        this[impl].removeAttributeNS(null, \\"reflectedboolean\\");
      }
    }

    get ReflectedDOMString() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      const value = this[impl].getAttributeNS(null, \\"reflecteddomstring\\");
      return value === null ? \\"\\" : value;
    }

    set ReflectedDOMString(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"DOMString\\"](V, {
        context: \\"Failed to set the 'ReflectedDOMString' property on 'Reflect': The provided value\\"
      });

      this[impl].setAttributeNS(null, \\"reflecteddomstring\\", V);
    }

    get ReflectedLong() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      const value = parseInt(this[impl].getAttributeNS(null, \\"reflectedlong\\"));
      return isNaN(value) || value < -2147483648 || value > 2147483647 ? 0 : value;
    }

    set ReflectedLong(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"long\\"](V, {
        context: \\"Failed to set the 'ReflectedLong' property on 'Reflect': The provided value\\"
      });

      this[impl].setAttributeNS(null, \\"reflectedlong\\", String(V));
    }

    get ReflectedUnsignedLong() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      const value = parseInt(this[impl].getAttributeNS(null, \\"reflectedunsignedlong\\"));
      return isNaN(value) || value < 0 || value > 2147483647 ? 0 : value;
    }

    set ReflectedUnsignedLong(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"unsigned long\\"](V, {
        context: \\"Failed to set the 'ReflectedUnsignedLong' property on 'Reflect': The provided value\\"
      });

      this[impl].setAttributeNS(null, \\"reflectedunsignedlong\\", String(V > 2147483647 ? 0 : V));
    }

    get ReflectionTest() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      const value = this[impl].getAttributeNS(null, \\"reflection\\");
      return value === null ? \\"\\" : value;
    }

    set ReflectionTest(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"DOMString\\"](V, {
        context: \\"Failed to set the 'ReflectionTest' property on 'Reflect': The provided value\\"
      });

      this[impl].setAttributeNS(null, \\"reflection\\", V);
    }

    get withUnderscore() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      const value = this[impl].getAttributeNS(null, \\"with-underscore\\");
      return value === null ? \\"\\" : value;
    }

    set withUnderscore(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"DOMString\\"](V, {
        context: \\"Failed to set the 'withUnderscore' property on 'Reflect': The provided value\\"
      });

      this[impl].setAttributeNS(null, \\"with-underscore\\", V);
    }
  }
  Object.defineProperties(Reflect.prototype, {
    ReflectedBoolean: { enumerable: true },
    ReflectedDOMString: { enumerable: true },
    ReflectedLong: { enumerable: true },
    ReflectedUnsignedLong: { enumerable: true },
    ReflectionTest: { enumerable: true },
    withUnderscore: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"Reflect\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = Reflect;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: Reflect
  });
};

const Impl = require(\\"../implementations/Reflect.js\\");
"
`;

exports[`with processors RequestDestination.webidl 1`] = `
"\\"use strict\\";

const enumerationValues = new Set([
  \\"\\",
  \\"audio\\",
  \\"document\\",
  \\"embed\\",
  \\"font\\",
  \\"image\\",
  \\"manifest\\",
  \\"object\\",
  \\"report\\",
  \\"script\\",
  \\"sharedworker\\",
  \\"style\\",
  \\"track\\",
  \\"video\\",
  \\"worker\\",
  \\"xslt\\"
]);
exports.enumerationValues = enumerationValues;

exports.convert = function convert(value, { context = \\"The provided value\\" } = {}) {
  const string = \`\${value}\`;
  if (!enumerationValues.has(value)) {
    throw new TypeError(\`\${context} '\${value}' is not a valid enumeration value for RequestDestination\`);
  }
  return string;
};
"
`;

exports[`with processors SeqAndRec.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const convertURL = require(\\"./URL.js\\").convert;
const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"SeqAndRec\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'SeqAndRec'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"SeqAndRec\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor SeqAndRec is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class SeqAndRec {
    constructor() {
      return exports.setup(Object.create(new.target.prototype), globalObject, undefined);
    }

    recordConsumer(rec) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'recordConsumer' on 'SeqAndRec': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (!utils.isObject(curArg)) {
          throw new TypeError(\\"Failed to execute 'recordConsumer' on 'SeqAndRec': parameter 1\\" + \\" is not an object.\\");
        } else {
          const result = Object.create(null);
          for (const key of Reflect.ownKeys(curArg)) {
            const desc = Object.getOwnPropertyDescriptor(curArg, key);
            if (desc && desc.enumerable) {
              let typedKey = key;

              typedKey = conversions[\\"USVString\\"](typedKey, {
                context: \\"Failed to execute 'recordConsumer' on 'SeqAndRec': parameter 1\\" + \\"'s key\\"
              });

              let typedValue = curArg[key];

              typedValue = conversions[\\"double\\"](typedValue, {
                context: \\"Failed to execute 'recordConsumer' on 'SeqAndRec': parameter 1\\" + \\"'s value\\"
              });

              result[typedKey] = typedValue;
            }
          }
          curArg = result;
        }
        args.push(curArg);
      }
      return this[impl].recordConsumer(...args);
    }

    recordConsumer2(rec) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'recordConsumer2' on 'SeqAndRec': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (!utils.isObject(curArg)) {
          throw new TypeError(\\"Failed to execute 'recordConsumer2' on 'SeqAndRec': parameter 1\\" + \\" is not an object.\\");
        } else {
          const result = Object.create(null);
          for (const key of Reflect.ownKeys(curArg)) {
            const desc = Object.getOwnPropertyDescriptor(curArg, key);
            if (desc && desc.enumerable) {
              let typedKey = key;

              typedKey = conversions[\\"USVString\\"](typedKey, {
                context: \\"Failed to execute 'recordConsumer2' on 'SeqAndRec': parameter 1\\" + \\"'s key\\"
              });

              let typedValue = curArg[key];

              typedValue = convertURL(typedValue, {
                context: \\"Failed to execute 'recordConsumer2' on 'SeqAndRec': parameter 1\\" + \\"'s value\\"
              });

              result[typedKey] = typedValue;
            }
          }
          curArg = result;
        }
        args.push(curArg);
      }
      return this[impl].recordConsumer2(...args);
    }

    sequenceConsumer(seq) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'sequenceConsumer' on 'SeqAndRec': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (!utils.isObject(curArg)) {
          throw new TypeError(
            \\"Failed to execute 'sequenceConsumer' on 'SeqAndRec': parameter 1\\" + \\" is not an iterable object.\\"
          );
        } else {
          const V = [];
          const tmp = curArg;
          for (let nextItem of tmp) {
            nextItem = conversions[\\"USVString\\"](nextItem, {
              context: \\"Failed to execute 'sequenceConsumer' on 'SeqAndRec': parameter 1\\" + \\"'s element\\"
            });

            V.push(nextItem);
          }
          curArg = V;
        }
        args.push(curArg);
      }
      return this[impl].sequenceConsumer(...args);
    }

    sequenceConsumer2(seq) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'sequenceConsumer2' on 'SeqAndRec': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (!utils.isObject(curArg)) {
          throw new TypeError(
            \\"Failed to execute 'sequenceConsumer2' on 'SeqAndRec': parameter 1\\" + \\" is not an iterable object.\\"
          );
        } else {
          const V = [];
          const tmp = curArg;
          for (let nextItem of tmp) {
            nextItem = utils.tryImplForWrapper(nextItem);

            V.push(nextItem);
          }
          curArg = V;
        }
        args.push(curArg);
      }
      return this[impl].sequenceConsumer2(...args);
    }

    frozenArrayConsumer(arr) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'frozenArrayConsumer' on 'SeqAndRec': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (!utils.isObject(curArg)) {
          throw new TypeError(
            \\"Failed to execute 'frozenArrayConsumer' on 'SeqAndRec': parameter 1\\" + \\" is not an iterable object.\\"
          );
        } else {
          const V = [];
          const tmp = curArg;
          for (let nextItem of tmp) {
            nextItem = conversions[\\"double\\"](nextItem, {
              context: \\"Failed to execute 'frozenArrayConsumer' on 'SeqAndRec': parameter 1\\" + \\"'s element\\"
            });

            V.push(nextItem);
          }
          curArg = V;
        }
        curArg = Object.freeze(curArg);
        args.push(curArg);
      }
      return this[impl].frozenArrayConsumer(...args);
    }
  }
  Object.defineProperties(SeqAndRec.prototype, {
    recordConsumer: { enumerable: true },
    recordConsumer2: { enumerable: true },
    sequenceConsumer: { enumerable: true },
    sequenceConsumer2: { enumerable: true },
    frozenArrayConsumer: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"SeqAndRec\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = SeqAndRec;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: SeqAndRec
  });
};

const Impl = require(\\"../implementations/SeqAndRec.js\\");
"
`;

exports[`with processors Static.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"Static\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'Static'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"Static\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor Static is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class Static {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    def() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl].def();
    }

    get abc() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"abc\\"];
    }

    set abc(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"DOMString\\"](V, { context: \\"Failed to set the 'abc' property on 'Static': The provided value\\" });

      this[impl][\\"abc\\"] = V;
    }

    static def() {
      return Impl.implementation.def();
    }

    static get abc() {
      return Impl.implementation[\\"abc\\"];
    }

    static set abc(V) {
      return Impl.implementation[\\"abc\\"];
    }
  }
  Object.defineProperties(Static.prototype, {
    def: { enumerable: true },
    abc: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"Static\\", configurable: true }
  });
  Object.defineProperties(Static, { def: { enumerable: true }, abc: { enumerable: true } });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = Static;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: Static
  });
};

const Impl = require(\\"../implementations/Static.js\\");
"
`;

exports[`with processors Storage.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"Storage\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'Storage'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"Storage\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor Storage is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj = new Proxy(obj, proxyHandler);

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class Storage {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    key(index) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'key' on 'Storage': 1 argument required, but only \\" + arguments.length + \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"unsigned long\\"](curArg, { context: \\"Failed to execute 'key' on 'Storage': parameter 1\\" });
        args.push(curArg);
      }
      return this[impl].key(...args);
    }

    getItem(key) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'getItem' on 'Storage': 1 argument required, but only \\" + arguments.length + \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"DOMString\\"](curArg, { context: \\"Failed to execute 'getItem' on 'Storage': parameter 1\\" });
        args.push(curArg);
      }
      return this[impl].getItem(...args);
    }

    setItem(key, value) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 2) {
        throw new TypeError(
          \\"Failed to execute 'setItem' on 'Storage': 2 arguments required, but only \\" + arguments.length + \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"DOMString\\"](curArg, { context: \\"Failed to execute 'setItem' on 'Storage': parameter 1\\" });
        args.push(curArg);
      }
      {
        let curArg = arguments[1];
        curArg = conversions[\\"DOMString\\"](curArg, { context: \\"Failed to execute 'setItem' on 'Storage': parameter 2\\" });
        args.push(curArg);
      }
      return this[impl].setItem(...args);
    }

    removeItem(key) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'removeItem' on 'Storage': 1 argument required, but only \\" + arguments.length + \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'removeItem' on 'Storage': parameter 1\\"
        });
        args.push(curArg);
      }
      return this[impl].removeItem(...args);
    }

    clear() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl].clear();
    }

    get length() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"length\\"];
    }
  }
  Object.defineProperties(Storage.prototype, {
    key: { enumerable: true },
    getItem: { enumerable: true },
    setItem: { enumerable: true },
    removeItem: { enumerable: true },
    clear: { enumerable: true },
    length: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"Storage\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = Storage;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: Storage
  });
};

const proxyHandler = {
  get(target, P, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.get(target, P, receiver);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc === undefined) {
      const parent = Object.getPrototypeOf(target);
      if (parent === null) {
        return undefined;
      }
      return Reflect.get(target, P, receiver);
    }
    if (!desc.get && !desc.set) {
      return desc.value;
    }
    const getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return Reflect.apply(getter, receiver, []);
  },

  has(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.has(target, P);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc !== undefined) {
      return true;
    }
    const parent = Object.getPrototypeOf(target);
    if (parent !== null) {
      return Reflect.has(parent, P);
    }
    return false;
  },

  ownKeys(target) {
    const keys = new Set();

    for (const key of target[impl][utils.supportedPropertyNames]) {
      if (!(key in target)) {
        keys.add(\`\${key}\`);
      }
    }

    for (const key of Reflect.ownKeys(target)) {
      keys.add(key);
    }
    return [...keys];
  },

  getOwnPropertyDescriptor(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.getOwnPropertyDescriptor(target, P);
    }
    let ignoreNamedProps = false;

    if (target[impl][utils.supportsPropertyName](P) && !(P in target) && !ignoreNamedProps) {
      const namedValue = target[impl].getItem(P);

      return {
        writable: true,
        enumerable: true,
        configurable: true,
        value: utils.tryWrapperForImpl(namedValue)
      };
    }

    return Reflect.getOwnPropertyDescriptor(target, P);
  },

  set(target, P, V, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.set(target, P, V, receiver);
    }
    if (target === receiver) {
      if (typeof P === \\"string\\" && !utils.isArrayIndexPropName(P)) {
        let namedValue = V;

        namedValue = conversions[\\"DOMString\\"](namedValue, {
          context: \\"Failed to set the '\\" + P + \\"' property on 'Storage': The provided value\\"
        });

        target[impl].setItem(P, namedValue);

        return true;
      }
    }
    let ownDesc;

    if (ownDesc === undefined) {
      ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
    }
    if (ownDesc === undefined) {
      const parent = Reflect.getPrototypeOf(target);
      if (parent !== null) {
        return Reflect.set(parent, P, V, receiver);
      }
      ownDesc = { writable: true, enumerable: true, configurable: true, value: undefined };
    }
    if (!ownDesc.writable) {
      return false;
    }
    if (!utils.isObject(receiver)) {
      return false;
    }
    const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
    let valueDesc;
    if (existingDesc !== undefined) {
      if (existingDesc.get || existingDesc.set) {
        return false;
      }
      if (!existingDesc.writable) {
        return false;
      }
      valueDesc = { value: V };
    } else {
      valueDesc = { writable: true, enumerable: true, configurable: true, value: V };
    }
    return Reflect.defineProperty(receiver, P, valueDesc);
  },

  defineProperty(target, P, desc) {
    if (typeof P === \\"symbol\\") {
      return Reflect.defineProperty(target, P, desc);
    }
    if (!utils.hasOwn(target, P)) {
      if (desc.get || desc.set) {
        return false;
      }

      let namedValue = desc.value;

      namedValue = conversions[\\"DOMString\\"](namedValue, {
        context: \\"Failed to set the '\\" + P + \\"' property on 'Storage': The provided value\\"
      });

      target[impl].setItem(P, namedValue);

      return true;
    }
    return Reflect.defineProperty(target, P, desc);
  },

  deleteProperty(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.deleteProperty(target, P);
    }

    if (target[impl][utils.supportsPropertyName](P) && !(P in target)) {
      target[impl].removeItem(P);
      return true;
    }

    return Reflect.deleteProperty(target, P);
  },

  preventExtensions() {
    return false;
  }
};

const Impl = require(\\"../implementations/Storage.js\\");
"
`;

exports[`with processors StringifierAttribute.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"StringifierAttribute\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'StringifierAttribute'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"StringifierAttribute\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor StringifierAttribute is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class StringifierAttribute {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    get attr() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"attr\\"];
    }

    toString() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
      return this[impl][\\"attr\\"];
    }
  }
  Object.defineProperties(StringifierAttribute.prototype, {
    attr: { enumerable: true },
    toString: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"StringifierAttribute\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = StringifierAttribute;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: StringifierAttribute
  });
};

const Impl = require(\\"../implementations/StringifierAttribute.js\\");
"
`;

exports[`with processors StringifierDefaultOperation.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"StringifierDefaultOperation\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'StringifierDefaultOperation'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"StringifierDefaultOperation\\"];
  if (ctor === undefined) {
    throw new Error(
      \\"Internal error: constructor StringifierDefaultOperation is not installed on the passed global object\\"
    );
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class StringifierDefaultOperation {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    toString() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl].toString();
    }
  }
  Object.defineProperties(StringifierDefaultOperation.prototype, {
    toString: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"StringifierDefaultOperation\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = StringifierDefaultOperation;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: StringifierDefaultOperation
  });
};

const Impl = require(\\"../implementations/StringifierDefaultOperation.js\\");
"
`;

exports[`with processors StringifierNamedOperation.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"StringifierNamedOperation\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'StringifierNamedOperation'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"StringifierNamedOperation\\"];
  if (ctor === undefined) {
    throw new Error(
      \\"Internal error: constructor StringifierNamedOperation is not installed on the passed global object\\"
    );
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class StringifierNamedOperation {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    operation() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl].operation();
    }

    toString() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl].operation();
    }
  }
  Object.defineProperties(StringifierNamedOperation.prototype, {
    operation: { enumerable: true },
    toString: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"StringifierNamedOperation\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = StringifierNamedOperation;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: StringifierNamedOperation
  });
};

const Impl = require(\\"../implementations/StringifierNamedOperation.js\\");
"
`;

exports[`with processors StringifierOperation.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"StringifierOperation\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'StringifierOperation'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"StringifierOperation\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor StringifierOperation is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class StringifierOperation {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    toString() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl].toString();
    }
  }
  Object.defineProperties(StringifierOperation.prototype, {
    toString: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"StringifierOperation\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = StringifierOperation;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: StringifierOperation
  });
};

const Impl = require(\\"../implementations/StringifierOperation.js\\");
"
`;

exports[`with processors TypedefsAndUnions.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const convertRequestDestination = require(\\"./RequestDestination.js\\").convert;
const isURL = require(\\"./URL.js\\").is;
const convertURL = require(\\"./URL.js\\").convert;
const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"TypedefsAndUnions\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'TypedefsAndUnions'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"TypedefsAndUnions\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor TypedefsAndUnions is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class TypedefsAndUnions {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    numOrStrConsumer(a) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'numOrStrConsumer' on 'TypedefsAndUnions': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (typeof curArg === \\"number\\") {
          curArg = conversions[\\"double\\"](curArg, {
            context: \\"Failed to execute 'numOrStrConsumer' on 'TypedefsAndUnions': parameter 1\\",
            clamp: true
          });
        } else {
          curArg = conversions[\\"DOMString\\"](curArg, {
            context: \\"Failed to execute 'numOrStrConsumer' on 'TypedefsAndUnions': parameter 1\\"
          });
        }
        args.push(curArg);
      }
      return this[impl].numOrStrConsumer(...args);
    }

    numOrEnumConsumer(a) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'numOrEnumConsumer' on 'TypedefsAndUnions': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg === null || curArg === undefined) {
          curArg = null;
        } else {
          if (typeof curArg === \\"number\\") {
            curArg = conversions[\\"double\\"](curArg, {
              context: \\"Failed to execute 'numOrEnumConsumer' on 'TypedefsAndUnions': parameter 1\\"
            });
          } else {
            curArg = convertRequestDestination(curArg, {
              context: \\"Failed to execute 'numOrEnumConsumer' on 'TypedefsAndUnions': parameter 1\\"
            });
          }
        }
        args.push(curArg);
      }
      return this[impl].numOrEnumConsumer(...args);
    }

    numOrStrOrNullConsumer(a) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'numOrStrOrNullConsumer' on 'TypedefsAndUnions': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg === null || curArg === undefined) {
          curArg = null;
        } else {
          if (typeof curArg === \\"number\\") {
            curArg = conversions[\\"double\\"](curArg, {
              context: \\"Failed to execute 'numOrStrOrNullConsumer' on 'TypedefsAndUnions': parameter 1\\",
              clamp: true,
              enforceRange: true
            });
          } else {
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'numOrStrOrNullConsumer' on 'TypedefsAndUnions': parameter 1\\",
              enforceRange: true
            });
          }
        }
        args.push(curArg);
      }
      return this[impl].numOrStrOrNullConsumer(...args);
    }

    numOrStrOrURLOrNullConsumer(a) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'numOrStrOrURLOrNullConsumer' on 'TypedefsAndUnions': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg === null || curArg === undefined) {
          curArg = null;
        } else {
          if (isURL(curArg)) {
            curArg = utils.implForWrapper(curArg);
          } else if (typeof curArg === \\"number\\") {
            curArg = conversions[\\"double\\"](curArg, {
              context: \\"Failed to execute 'numOrStrOrURLOrNullConsumer' on 'TypedefsAndUnions': parameter 1\\",
              clamp: true,
              enforceRange: true
            });
          } else {
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'numOrStrOrURLOrNullConsumer' on 'TypedefsAndUnions': parameter 1\\",
              enforceRange: true
            });
          }
        }
        args.push(curArg);
      }
      return this[impl].numOrStrOrURLOrNullConsumer(...args);
    }

    urlMapInnerConsumer(a) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'urlMapInnerConsumer' on 'TypedefsAndUnions': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (!utils.isObject(curArg)) {
          throw new TypeError(
            \\"Failed to execute 'urlMapInnerConsumer' on 'TypedefsAndUnions': parameter 1\\" + \\" is not an object.\\"
          );
        } else {
          const result = Object.create(null);
          for (const key of Reflect.ownKeys(curArg)) {
            const desc = Object.getOwnPropertyDescriptor(curArg, key);
            if (desc && desc.enumerable) {
              let typedKey = key;

              typedKey = conversions[\\"USVString\\"](typedKey, {
                context: \\"Failed to execute 'urlMapInnerConsumer' on 'TypedefsAndUnions': parameter 1\\" + \\"'s key\\"
              });

              let typedValue = curArg[key];

              typedValue = convertURL(typedValue, {
                context: \\"Failed to execute 'urlMapInnerConsumer' on 'TypedefsAndUnions': parameter 1\\" + \\"'s value\\"
              });

              result[typedKey] = typedValue;
            }
          }
          curArg = result;
        }
        args.push(curArg);
      }
      return this[impl].urlMapInnerConsumer(...args);
    }

    urlMapConsumer(a) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'urlMapConsumer' on 'TypedefsAndUnions': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg === null || curArg === undefined) {
          curArg = null;
        } else {
          if (!utils.isObject(curArg)) {
            throw new TypeError(
              \\"Failed to execute 'urlMapConsumer' on 'TypedefsAndUnions': parameter 1\\" + \\" is not an object.\\"
            );
          } else {
            const result = Object.create(null);
            for (const key of Reflect.ownKeys(curArg)) {
              const desc = Object.getOwnPropertyDescriptor(curArg, key);
              if (desc && desc.enumerable) {
                let typedKey = key;

                typedKey = conversions[\\"USVString\\"](typedKey, {
                  context: \\"Failed to execute 'urlMapConsumer' on 'TypedefsAndUnions': parameter 1\\" + \\"'s key\\"
                });

                let typedValue = curArg[key];

                typedValue = convertURL(typedValue, {
                  context: \\"Failed to execute 'urlMapConsumer' on 'TypedefsAndUnions': parameter 1\\" + \\"'s value\\"
                });

                result[typedKey] = typedValue;
              }
            }
            curArg = result;
          }
        }
        args.push(curArg);
      }
      return this[impl].urlMapConsumer(...args);
    }

    bufferSourceOrURLConsumer(b) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'bufferSourceOrURLConsumer' on 'TypedefsAndUnions': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (isURL(curArg)) {
          curArg = utils.implForWrapper(curArg);
        } else if (utils.isArrayBuffer(curArg)) {
        } else if (ArrayBuffer.isView(curArg)) {
        } else {
          throw new TypeError(
            \\"Failed to execute 'bufferSourceOrURLConsumer' on 'TypedefsAndUnions': parameter 1\\" +
              \\" is not of any supported type.\\"
          );
        }
        args.push(curArg);
      }
      return this[impl].bufferSourceOrURLConsumer(...args);
    }

    arrayBufferViewOrURLMapConsumer(b) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'arrayBufferViewOrURLMapConsumer' on 'TypedefsAndUnions': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg === null || curArg === undefined) {
          curArg = null;
        } else {
          if (ArrayBuffer.isView(curArg)) {
          } else if (utils.isObject(curArg)) {
            if (!utils.isObject(curArg)) {
              throw new TypeError(
                \\"Failed to execute 'arrayBufferViewOrURLMapConsumer' on 'TypedefsAndUnions': parameter 1\\" +
                  \\" record\\" +
                  \\" is not an object.\\"
              );
            } else {
              const result = Object.create(null);
              for (const key of Reflect.ownKeys(curArg)) {
                const desc = Object.getOwnPropertyDescriptor(curArg, key);
                if (desc && desc.enumerable) {
                  let typedKey = key;

                  typedKey = conversions[\\"USVString\\"](typedKey, {
                    context:
                      \\"Failed to execute 'arrayBufferViewOrURLMapConsumer' on 'TypedefsAndUnions': parameter 1\\" +
                      \\" record\\" +
                      \\"'s key\\"
                  });

                  let typedValue = curArg[key];

                  typedValue = convertURL(typedValue, {
                    context:
                      \\"Failed to execute 'arrayBufferViewOrURLMapConsumer' on 'TypedefsAndUnions': parameter 1\\" +
                      \\" record\\" +
                      \\"'s value\\"
                  });

                  result[typedKey] = typedValue;
                }
              }
              curArg = result;
            }
          } else {
            throw new TypeError(
              \\"Failed to execute 'arrayBufferViewOrURLMapConsumer' on 'TypedefsAndUnions': parameter 1\\" +
                \\" is not of any supported type.\\"
            );
          }
        }
        args.push(curArg);
      }
      return this[impl].arrayBufferViewOrURLMapConsumer(...args);
    }

    arrayBufferViewDupConsumer(b) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'arrayBufferViewDupConsumer' on 'TypedefsAndUnions': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (ArrayBuffer.isView(curArg)) {
        } else {
          throw new TypeError(
            \\"Failed to execute 'arrayBufferViewDupConsumer' on 'TypedefsAndUnions': parameter 1\\" +
              \\" is not of any supported type.\\"
          );
        }
        args.push(curArg);
      }
      return this[impl].arrayBufferViewDupConsumer(...args);
    }

    get buf() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return utils.tryWrapperForImpl(this[impl][\\"buf\\"]);
    }

    set buf(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (utils.isArrayBuffer(V)) {
      } else if (
        ArrayBuffer.isView(V) &&
        (V.constructor.name === \\"Uint8Array\\" || V.constructor.name === \\"Uint16Array\\")
      ) {
      } else {
        throw new TypeError(
          \\"Failed to set the 'buf' property on 'TypedefsAndUnions': The provided value\\" +
            \\" is not of any supported type.\\"
        );
      }
      this[impl][\\"buf\\"] = V;
    }

    get time() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"time\\"];
    }

    set time(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"unsigned long long\\"](V, {
        context: \\"Failed to set the 'time' property on 'TypedefsAndUnions': The provided value\\"
      });

      this[impl][\\"time\\"] = V;
    }
  }
  Object.defineProperties(TypedefsAndUnions.prototype, {
    numOrStrConsumer: { enumerable: true },
    numOrEnumConsumer: { enumerable: true },
    numOrStrOrNullConsumer: { enumerable: true },
    numOrStrOrURLOrNullConsumer: { enumerable: true },
    urlMapInnerConsumer: { enumerable: true },
    urlMapConsumer: { enumerable: true },
    bufferSourceOrURLConsumer: { enumerable: true },
    arrayBufferViewOrURLMapConsumer: { enumerable: true },
    arrayBufferViewDupConsumer: { enumerable: true },
    buf: { enumerable: true },
    time: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"TypedefsAndUnions\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = TypedefsAndUnions;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: TypedefsAndUnions
  });
};

const Impl = require(\\"../implementations/TypedefsAndUnions.js\\");
"
`;

exports[`with processors URL.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"URL\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'URL'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"URL\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor URL is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class URL {
    constructor(url) {
      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to construct 'URL': 1 argument required, but only \\" + arguments.length + \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"USVString\\"](curArg, { context: \\"Failed to construct 'URL': parameter 1\\" });
        args.push(curArg);
      }
      {
        let curArg = arguments[1];
        if (curArg !== undefined) {
          curArg = conversions[\\"USVString\\"](curArg, { context: \\"Failed to construct 'URL': parameter 2\\" });
        }
        args.push(curArg);
      }
      return exports.setup(Object.create(new.target.prototype), globalObject, args);
    }

    toJSON() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl].toJSON();
    }

    get href() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"href\\"];
    }

    set href(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, { context: \\"Failed to set the 'href' property on 'URL': The provided value\\" });

      this[impl][\\"href\\"] = V;
    }

    toString() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
      return this[impl][\\"href\\"];
    }

    get origin() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"origin\\"];
    }

    get protocol() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"protocol\\"];
    }

    set protocol(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, {
        context: \\"Failed to set the 'protocol' property on 'URL': The provided value\\"
      });

      this[impl][\\"protocol\\"] = V;
    }

    get username() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"username\\"];
    }

    set username(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, {
        context: \\"Failed to set the 'username' property on 'URL': The provided value\\"
      });

      this[impl][\\"username\\"] = V;
    }

    get password() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"password\\"];
    }

    set password(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, {
        context: \\"Failed to set the 'password' property on 'URL': The provided value\\"
      });

      this[impl][\\"password\\"] = V;
    }

    get host() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"host\\"];
    }

    set host(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, { context: \\"Failed to set the 'host' property on 'URL': The provided value\\" });

      this[impl][\\"host\\"] = V;
    }

    get hostname() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"hostname\\"];
    }

    set hostname(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, {
        context: \\"Failed to set the 'hostname' property on 'URL': The provided value\\"
      });

      this[impl][\\"hostname\\"] = V;
    }

    get port() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"port\\"];
    }

    set port(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, { context: \\"Failed to set the 'port' property on 'URL': The provided value\\" });

      this[impl][\\"port\\"] = V;
    }

    get pathname() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"pathname\\"];
    }

    set pathname(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, {
        context: \\"Failed to set the 'pathname' property on 'URL': The provided value\\"
      });

      this[impl][\\"pathname\\"] = V;
    }

    get search() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"search\\"];
    }

    set search(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, { context: \\"Failed to set the 'search' property on 'URL': The provided value\\" });

      this[impl][\\"search\\"] = V;
    }

    get searchParams() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return utils.getSameObject(this, \\"searchParams\\", () => {
        return utils.tryWrapperForImpl(this[impl][\\"searchParams\\"]);
      });
    }

    get hash() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"hash\\"];
    }

    set hash(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, { context: \\"Failed to set the 'hash' property on 'URL': The provided value\\" });

      this[impl][\\"hash\\"] = V;
    }
  }
  Object.defineProperties(URL.prototype, {
    toJSON: { enumerable: true },
    href: { enumerable: true },
    toString: { enumerable: true },
    origin: { enumerable: true },
    protocol: { enumerable: true },
    username: { enumerable: true },
    password: { enumerable: true },
    host: { enumerable: true },
    hostname: { enumerable: true },
    port: { enumerable: true },
    pathname: { enumerable: true },
    search: { enumerable: true },
    searchParams: { enumerable: true },
    hash: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"URL\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = URL;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: URL
  });
};

const Impl = require(\\"../implementations/URL.js\\");
"
`;

exports[`with processors URLList.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"URLList\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'URLList'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"URLList\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor URLList is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj = new Proxy(obj, proxyHandler);

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class URLList {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    item(index) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'item' on 'URLList': 1 argument required, but only \\" + arguments.length + \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"unsigned long\\"](curArg, {
          context: \\"Failed to execute 'item' on 'URLList': parameter 1\\"
        });
        args.push(curArg);
      }
      return utils.tryWrapperForImpl(this[impl].item(...args));
    }

    get length() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"length\\"];
    }
  }
  Object.defineProperties(URLList.prototype, {
    item: { enumerable: true },
    length: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"URLList\\", configurable: true },
    [Symbol.iterator]: { value: Array.prototype[Symbol.iterator], configurable: true, writable: true },
    keys: { value: Array.prototype.keys, configurable: true, enumerable: true, writable: true },
    values: { value: Array.prototype[Symbol.iterator], configurable: true, enumerable: true, writable: true },
    entries: { value: Array.prototype.entries, configurable: true, enumerable: true, writable: true },
    forEach: { value: Array.prototype.forEach, configurable: true, enumerable: true, writable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = URLList;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: URLList
  });
};

const proxyHandler = {
  get(target, P, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.get(target, P, receiver);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc === undefined) {
      const parent = Object.getPrototypeOf(target);
      if (parent === null) {
        return undefined;
      }
      return Reflect.get(target, P, receiver);
    }
    if (!desc.get && !desc.set) {
      return desc.value;
    }
    const getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return Reflect.apply(getter, receiver, []);
  },

  has(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.has(target, P);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc !== undefined) {
      return true;
    }
    const parent = Object.getPrototypeOf(target);
    if (parent !== null) {
      return Reflect.has(parent, P);
    }
    return false;
  },

  ownKeys(target) {
    const keys = new Set();

    for (const key of target[impl][utils.supportedPropertyIndices]) {
      keys.add(\`\${key}\`);
    }

    for (const key of Reflect.ownKeys(target)) {
      keys.add(key);
    }
    return [...keys];
  },

  getOwnPropertyDescriptor(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.getOwnPropertyDescriptor(target, P);
    }
    let ignoreNamedProps = false;

    if (utils.isArrayIndexPropName(P)) {
      const index = P >>> 0;

      if (target[impl][utils.supportsPropertyIndex](index)) {
        const indexedValue = target[impl].item(index);
        return {
          writable: false,
          enumerable: true,
          configurable: true,
          value: utils.tryWrapperForImpl(indexedValue)
        };
      }
      ignoreNamedProps = true;
    }

    return Reflect.getOwnPropertyDescriptor(target, P);
  },

  set(target, P, V, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.set(target, P, V, receiver);
    }
    if (target === receiver) {
      utils.isArrayIndexPropName(P);
    }
    let ownDesc;

    if (utils.isArrayIndexPropName(P)) {
      const index = P >>> 0;

      if (target[impl][utils.supportsPropertyIndex](index)) {
        const indexedValue = target[impl].item(index);
        ownDesc = {
          writable: false,
          enumerable: true,
          configurable: true,
          value: utils.tryWrapperForImpl(indexedValue)
        };
      }
    }

    if (ownDesc === undefined) {
      ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
    }
    if (ownDesc === undefined) {
      const parent = Reflect.getPrototypeOf(target);
      if (parent !== null) {
        return Reflect.set(parent, P, V, receiver);
      }
      ownDesc = { writable: true, enumerable: true, configurable: true, value: undefined };
    }
    if (!ownDesc.writable) {
      return false;
    }
    if (!utils.isObject(receiver)) {
      return false;
    }
    const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
    let valueDesc;
    if (existingDesc !== undefined) {
      if (existingDesc.get || existingDesc.set) {
        return false;
      }
      if (!existingDesc.writable) {
        return false;
      }
      valueDesc = { value: V };
    } else {
      valueDesc = { writable: true, enumerable: true, configurable: true, value: V };
    }
    return Reflect.defineProperty(receiver, P, valueDesc);
  },

  defineProperty(target, P, desc) {
    if (typeof P === \\"symbol\\") {
      return Reflect.defineProperty(target, P, desc);
    }

    if (utils.isArrayIndexPropName(P)) {
      return false;
    }

    return Reflect.defineProperty(target, P, desc);
  },

  deleteProperty(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.deleteProperty(target, P);
    }

    if (utils.isArrayIndexPropName(P)) {
      const index = P >>> 0;
      return !target[impl][utils.supportsPropertyIndex](index);
    }

    return Reflect.deleteProperty(target, P);
  },

  preventExtensions() {
    return false;
  }
};

const Impl = require(\\"../implementations/URLList.js\\");
"
`;

exports[`with processors URLSearchParams.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"URLSearchParams\\";

const IteratorPrototype = Object.create(utils.IteratorPrototype, {
  next: {
    value: function next() {
      const internal = this[utils.iterInternalSymbol];
      const { target, kind, index } = internal;
      const values = Array.from(target[impl]);
      const len = values.length;
      if (index >= len) {
        return { value: undefined, done: true };
      }

      const pair = values[index];
      internal.index = index + 1;
      const [key, value] = pair.map(utils.tryWrapperForImpl);

      let result;
      switch (kind) {
        case \\"key\\":
          result = key;
          break;
        case \\"value\\":
          result = value;
          break;
        case \\"key+value\\":
          result = [key, value];
          break;
      }
      return { value: result, done: false };
    },
    writable: true,
    enumerable: true,
    configurable: true
  },
  [Symbol.toStringTag]: {
    value: \\"URLSearchParams Iterator\\",
    configurable: true
  }
});

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'URLSearchParams'.\`);
};

exports.createDefaultIterator = function createDefaultIterator(target, kind) {
  const iterator = Object.create(IteratorPrototype);
  Object.defineProperty(iterator, utils.iterInternalSymbol, {
    value: { target, kind, index: 0 },
    configurable: true
  });
  return iterator;
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"URLSearchParams\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor URLSearchParams is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class URLSearchParams {
    constructor() {
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg !== undefined) {
          if (utils.isObject(curArg)) {
            if (curArg[Symbol.iterator] !== undefined) {
              if (!utils.isObject(curArg)) {
                throw new TypeError(
                  \\"Failed to construct 'URLSearchParams': parameter 1\\" + \\" sequence\\" + \\" is not an iterable object.\\"
                );
              } else {
                const V = [];
                const tmp = curArg;
                for (let nextItem of tmp) {
                  if (!utils.isObject(nextItem)) {
                    throw new TypeError(
                      \\"Failed to construct 'URLSearchParams': parameter 1\\" +
                        \\" sequence\\" +
                        \\"'s element\\" +
                        \\" is not an iterable object.\\"
                    );
                  } else {
                    const V = [];
                    const tmp = nextItem;
                    for (let nextItem of tmp) {
                      nextItem = conversions[\\"USVString\\"](nextItem, {
                        context:
                          \\"Failed to construct 'URLSearchParams': parameter 1\\" +
                          \\" sequence\\" +
                          \\"'s element\\" +
                          \\"'s element\\"
                      });

                      V.push(nextItem);
                    }
                    nextItem = V;
                  }

                  V.push(nextItem);
                }
                curArg = V;
              }
            } else {
              if (!utils.isObject(curArg)) {
                throw new TypeError(
                  \\"Failed to construct 'URLSearchParams': parameter 1\\" + \\" record\\" + \\" is not an object.\\"
                );
              } else {
                const result = Object.create(null);
                for (const key of Reflect.ownKeys(curArg)) {
                  const desc = Object.getOwnPropertyDescriptor(curArg, key);
                  if (desc && desc.enumerable) {
                    let typedKey = key;

                    typedKey = conversions[\\"USVString\\"](typedKey, {
                      context: \\"Failed to construct 'URLSearchParams': parameter 1\\" + \\" record\\" + \\"'s key\\"
                    });

                    let typedValue = curArg[key];

                    typedValue = conversions[\\"USVString\\"](typedValue, {
                      context: \\"Failed to construct 'URLSearchParams': parameter 1\\" + \\" record\\" + \\"'s value\\"
                    });

                    result[typedKey] = typedValue;
                  }
                }
                curArg = result;
              }
            }
          } else {
            curArg = conversions[\\"USVString\\"](curArg, {
              context: \\"Failed to construct 'URLSearchParams': parameter 1\\"
            });
          }
        } else {
          curArg = \\"\\";
        }
        args.push(curArg);
      }
      return exports.setup(Object.create(new.target.prototype), globalObject, args);
    }

    append(name, value) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 2) {
        throw new TypeError(
          \\"Failed to execute 'append' on 'URLSearchParams': 2 arguments required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"USVString\\"](curArg, {
          context: \\"Failed to execute 'append' on 'URLSearchParams': parameter 1\\"
        });
        args.push(curArg);
      }
      {
        let curArg = arguments[1];
        curArg = conversions[\\"USVString\\"](curArg, {
          context: \\"Failed to execute 'append' on 'URLSearchParams': parameter 2\\"
        });
        args.push(curArg);
      }
      return this[impl].append(...args);
    }

    delete(name) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'delete' on 'URLSearchParams': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"USVString\\"](curArg, {
          context: \\"Failed to execute 'delete' on 'URLSearchParams': parameter 1\\"
        });
        args.push(curArg);
      }
      return this[impl].delete(...args);
    }

    get(name) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'get' on 'URLSearchParams': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"USVString\\"](curArg, {
          context: \\"Failed to execute 'get' on 'URLSearchParams': parameter 1\\"
        });
        args.push(curArg);
      }
      return this[impl].get(...args);
    }

    getAll(name) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'getAll' on 'URLSearchParams': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"USVString\\"](curArg, {
          context: \\"Failed to execute 'getAll' on 'URLSearchParams': parameter 1\\"
        });
        args.push(curArg);
      }
      return utils.tryWrapperForImpl(this[impl].getAll(...args));
    }

    has(name) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'has' on 'URLSearchParams': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"USVString\\"](curArg, {
          context: \\"Failed to execute 'has' on 'URLSearchParams': parameter 1\\"
        });
        args.push(curArg);
      }
      return this[impl].has(...args);
    }

    set(name, value) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 2) {
        throw new TypeError(
          \\"Failed to execute 'set' on 'URLSearchParams': 2 arguments required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"USVString\\"](curArg, {
          context: \\"Failed to execute 'set' on 'URLSearchParams': parameter 1\\"
        });
        args.push(curArg);
      }
      {
        let curArg = arguments[1];
        curArg = conversions[\\"USVString\\"](curArg, {
          context: \\"Failed to execute 'set' on 'URLSearchParams': parameter 2\\"
        });
        args.push(curArg);
      }
      return this[impl].set(...args);
    }

    sort() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl].sort();
    }

    toString() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl].toString();
    }

    keys() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
      return exports.createDefaultIterator(this, \\"key\\");
    }

    values() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
      return exports.createDefaultIterator(this, \\"value\\");
    }

    entries() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
      return exports.createDefaultIterator(this, \\"key+value\\");
    }

    forEach(callback) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
      if (arguments.length < 1) {
        throw new TypeError(\\"Failed to execute 'forEach' on 'iterable': 1 argument required, \\" + \\"but only 0 present.\\");
      }
      if (typeof callback !== \\"function\\") {
        throw new TypeError(
          \\"Failed to execute 'forEach' on 'iterable': The callback provided \\" + \\"as parameter 1 is not a function.\\"
        );
      }
      const thisArg = arguments[1];
      let pairs = Array.from(this[impl]);
      let i = 0;
      while (i < pairs.length) {
        const [key, value] = pairs[i].map(utils.tryWrapperForImpl);
        callback.call(thisArg, value, key, this);
        pairs = Array.from(this[impl]);
        i++;
      }
    }
  }
  Object.defineProperties(URLSearchParams.prototype, {
    append: { enumerable: true },
    delete: { enumerable: true },
    get: { enumerable: true },
    getAll: { enumerable: true },
    has: { enumerable: true },
    set: { enumerable: true },
    sort: { enumerable: true },
    toString: { enumerable: true },
    keys: { enumerable: true },
    values: { enumerable: true },
    entries: { enumerable: true },
    forEach: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"URLSearchParams\\", configurable: true },
    [Symbol.iterator]: { value: URLSearchParams.prototype.entries, configurable: true, writable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = URLSearchParams;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: URLSearchParams
  });
};

const Impl = require(\\"../implementations/URLSearchParams.js\\");
"
`;

exports[`with processors URLSearchParamsCollection.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"URLSearchParamsCollection\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'URLSearchParamsCollection'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"URLSearchParamsCollection\\"];
  if (ctor === undefined) {
    throw new Error(
      \\"Internal error: constructor URLSearchParamsCollection is not installed on the passed global object\\"
    );
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj = new Proxy(obj, proxyHandler);

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class URLSearchParamsCollection {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    item(index) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'item' on 'URLSearchParamsCollection': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"unsigned long\\"](curArg, {
          context: \\"Failed to execute 'item' on 'URLSearchParamsCollection': parameter 1\\"
        });
        args.push(curArg);
      }
      return utils.tryWrapperForImpl(this[impl].item(...args));
    }

    namedItem(name) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'namedItem' on 'URLSearchParamsCollection': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'namedItem' on 'URLSearchParamsCollection': parameter 1\\"
        });
        args.push(curArg);
      }
      return utils.tryWrapperForImpl(this[impl].namedItem(...args));
    }

    get length() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"length\\"];
    }
  }
  Object.defineProperties(URLSearchParamsCollection.prototype, {
    item: { enumerable: true },
    namedItem: { enumerable: true },
    length: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"URLSearchParamsCollection\\", configurable: true },
    [Symbol.iterator]: { value: Array.prototype[Symbol.iterator], configurable: true, writable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = URLSearchParamsCollection;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: URLSearchParamsCollection
  });
};

const proxyHandler = {
  get(target, P, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.get(target, P, receiver);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc === undefined) {
      const parent = Object.getPrototypeOf(target);
      if (parent === null) {
        return undefined;
      }
      return Reflect.get(target, P, receiver);
    }
    if (!desc.get && !desc.set) {
      return desc.value;
    }
    const getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return Reflect.apply(getter, receiver, []);
  },

  has(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.has(target, P);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc !== undefined) {
      return true;
    }
    const parent = Object.getPrototypeOf(target);
    if (parent !== null) {
      return Reflect.has(parent, P);
    }
    return false;
  },

  ownKeys(target) {
    const keys = new Set();

    for (const key of target[impl][utils.supportedPropertyIndices]) {
      keys.add(\`\${key}\`);
    }

    for (const key of target[impl][utils.supportedPropertyNames]) {
      if (!(key in target)) {
        keys.add(\`\${key}\`);
      }
    }

    for (const key of Reflect.ownKeys(target)) {
      keys.add(key);
    }
    return [...keys];
  },

  getOwnPropertyDescriptor(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.getOwnPropertyDescriptor(target, P);
    }
    let ignoreNamedProps = false;

    if (utils.isArrayIndexPropName(P)) {
      const index = P >>> 0;
      const indexedValue = target[impl].item(index);
      if (indexedValue !== undefined) {
        return {
          writable: false,
          enumerable: true,
          configurable: true,
          value: utils.tryWrapperForImpl(indexedValue)
        };
      }
      ignoreNamedProps = true;
    }

    const namedValue = target[impl].namedItem(P);

    if (namedValue !== null && !(P in target) && !ignoreNamedProps) {
      return {
        writable: false,
        enumerable: false,
        configurable: true,
        value: utils.tryWrapperForImpl(namedValue)
      };
    }

    return Reflect.getOwnPropertyDescriptor(target, P);
  },

  set(target, P, V, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.set(target, P, V, receiver);
    }
    if (target === receiver) {
      utils.isArrayIndexPropName(P);

      typeof P === \\"string\\" && !utils.isArrayIndexPropName(P);
    }
    let ownDesc;

    if (utils.isArrayIndexPropName(P)) {
      const index = P >>> 0;
      const indexedValue = target[impl].item(index);
      if (indexedValue !== undefined) {
        ownDesc = {
          writable: false,
          enumerable: true,
          configurable: true,
          value: utils.tryWrapperForImpl(indexedValue)
        };
      }
    }

    if (ownDesc === undefined) {
      ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
    }
    if (ownDesc === undefined) {
      const parent = Reflect.getPrototypeOf(target);
      if (parent !== null) {
        return Reflect.set(parent, P, V, receiver);
      }
      ownDesc = { writable: true, enumerable: true, configurable: true, value: undefined };
    }
    if (!ownDesc.writable) {
      return false;
    }
    if (!utils.isObject(receiver)) {
      return false;
    }
    const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
    let valueDesc;
    if (existingDesc !== undefined) {
      if (existingDesc.get || existingDesc.set) {
        return false;
      }
      if (!existingDesc.writable) {
        return false;
      }
      valueDesc = { value: V };
    } else {
      valueDesc = { writable: true, enumerable: true, configurable: true, value: V };
    }
    return Reflect.defineProperty(receiver, P, valueDesc);
  },

  defineProperty(target, P, desc) {
    if (typeof P === \\"symbol\\") {
      return Reflect.defineProperty(target, P, desc);
    }

    if (utils.isArrayIndexPropName(P)) {
      return false;
    }
    if (!utils.hasOwn(target, P)) {
      const creating = !(target[impl].namedItem(P) !== null);
      if (!creating) {
        return false;
      }
    }
    return Reflect.defineProperty(target, P, desc);
  },

  deleteProperty(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.deleteProperty(target, P);
    }

    if (utils.isArrayIndexPropName(P)) {
      const index = P >>> 0;
      return !(target[impl].item(index) !== undefined);
    }

    if (target[impl].namedItem(P) !== null && !(P in target)) {
      return false;
    }

    return Reflect.deleteProperty(target, P);
  },

  preventExtensions() {
    return false;
  }
};

const Impl = require(\\"../implementations/URLSearchParamsCollection.js\\");
"
`;

exports[`with processors URLSearchParamsCollection2.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const convertURL = require(\\"./URL.js\\").convert;
const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;
const URLSearchParamsCollection = require(\\"./URLSearchParamsCollection.js\\");

const interfaceName = \\"URLSearchParamsCollection2\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'URLSearchParamsCollection2'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"URLSearchParamsCollection2\\"];
  if (ctor === undefined) {
    throw new Error(
      \\"Internal error: constructor URLSearchParamsCollection2 is not installed on the passed global object\\"
    );
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {
  URLSearchParamsCollection._internalSetup(obj);
};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj = new Proxy(obj, proxyHandler);

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  if (globalObject.URLSearchParamsCollection === undefined) {
    throw new Error(
      \\"Internal error: attempting to evaluate URLSearchParamsCollection2 before URLSearchParamsCollection\\"
    );
  }
  class URLSearchParamsCollection2 extends globalObject.URLSearchParamsCollection {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }
  }
  Object.defineProperties(URLSearchParamsCollection2.prototype, {
    [Symbol.toStringTag]: { value: \\"URLSearchParamsCollection2\\", configurable: true },
    [Symbol.iterator]: { value: Array.prototype[Symbol.iterator], configurable: true, writable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = URLSearchParamsCollection2;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: URLSearchParamsCollection2
  });
};

const proxyHandler = {
  get(target, P, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.get(target, P, receiver);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc === undefined) {
      const parent = Object.getPrototypeOf(target);
      if (parent === null) {
        return undefined;
      }
      return Reflect.get(target, P, receiver);
    }
    if (!desc.get && !desc.set) {
      return desc.value;
    }
    const getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return Reflect.apply(getter, receiver, []);
  },

  has(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.has(target, P);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc !== undefined) {
      return true;
    }
    const parent = Object.getPrototypeOf(target);
    if (parent !== null) {
      return Reflect.has(parent, P);
    }
    return false;
  },

  ownKeys(target) {
    const keys = new Set();

    for (const key of target[impl][utils.supportedPropertyIndices]) {
      keys.add(\`\${key}\`);
    }

    for (const key of target[impl][utils.supportedPropertyNames]) {
      if (!(key in target)) {
        keys.add(\`\${key}\`);
      }
    }

    for (const key of Reflect.ownKeys(target)) {
      keys.add(key);
    }
    return [...keys];
  },

  getOwnPropertyDescriptor(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.getOwnPropertyDescriptor(target, P);
    }
    let ignoreNamedProps = false;

    if (utils.isArrayIndexPropName(P)) {
      const index = P >>> 0;
      const indexedValue = target[impl].item(index);
      if (indexedValue !== undefined) {
        return {
          writable: false,
          enumerable: true,
          configurable: true,
          value: utils.tryWrapperForImpl(indexedValue)
        };
      }
      ignoreNamedProps = true;
    }

    const namedValue = target[impl].namedItem(P);

    if (namedValue !== null && !(P in target) && !ignoreNamedProps) {
      return {
        writable: true,
        enumerable: true,
        configurable: true,
        value: utils.tryWrapperForImpl(namedValue)
      };
    }

    return Reflect.getOwnPropertyDescriptor(target, P);
  },

  set(target, P, V, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.set(target, P, V, receiver);
    }
    if (target === receiver) {
      utils.isArrayIndexPropName(P);

      if (typeof P === \\"string\\" && !utils.isArrayIndexPropName(P)) {
        let namedValue = V;

        namedValue = convertURL(namedValue, {
          context: \\"Failed to set the '\\" + P + \\"' property on 'URLSearchParamsCollection2': The provided value\\"
        });

        const creating = !(target[impl].namedItem(P) !== null);
        if (creating) {
          target[impl][utils.namedSetNew](P, namedValue);
        } else {
          target[impl][utils.namedSetExisting](P, namedValue);
        }

        return true;
      }
    }
    let ownDesc;

    if (utils.isArrayIndexPropName(P)) {
      const index = P >>> 0;
      const indexedValue = target[impl].item(index);
      if (indexedValue !== undefined) {
        ownDesc = {
          writable: false,
          enumerable: true,
          configurable: true,
          value: utils.tryWrapperForImpl(indexedValue)
        };
      }
    }

    if (ownDesc === undefined) {
      ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
    }
    if (ownDesc === undefined) {
      const parent = Reflect.getPrototypeOf(target);
      if (parent !== null) {
        return Reflect.set(parent, P, V, receiver);
      }
      ownDesc = { writable: true, enumerable: true, configurable: true, value: undefined };
    }
    if (!ownDesc.writable) {
      return false;
    }
    if (!utils.isObject(receiver)) {
      return false;
    }
    const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
    let valueDesc;
    if (existingDesc !== undefined) {
      if (existingDesc.get || existingDesc.set) {
        return false;
      }
      if (!existingDesc.writable) {
        return false;
      }
      valueDesc = { value: V };
    } else {
      valueDesc = { writable: true, enumerable: true, configurable: true, value: V };
    }
    return Reflect.defineProperty(receiver, P, valueDesc);
  },

  defineProperty(target, P, desc) {
    if (typeof P === \\"symbol\\") {
      return Reflect.defineProperty(target, P, desc);
    }

    if (utils.isArrayIndexPropName(P)) {
      return false;
    }
    if (!utils.hasOwn(target, P)) {
      if (desc.get || desc.set) {
        return false;
      }

      let namedValue = desc.value;

      namedValue = convertURL(namedValue, {
        context: \\"Failed to set the '\\" + P + \\"' property on 'URLSearchParamsCollection2': The provided value\\"
      });

      const creating = !(target[impl].namedItem(P) !== null);
      if (creating) {
        target[impl][utils.namedSetNew](P, namedValue);
      } else {
        target[impl][utils.namedSetExisting](P, namedValue);
      }

      return true;
    }
    return Reflect.defineProperty(target, P, desc);
  },

  deleteProperty(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.deleteProperty(target, P);
    }

    if (utils.isArrayIndexPropName(P)) {
      const index = P >>> 0;
      return !(target[impl].item(index) !== undefined);
    }

    if (target[impl].namedItem(P) !== null && !(P in target)) {
      return false;
    }

    return Reflect.deleteProperty(target, P);
  },

  preventExtensions() {
    return false;
  }
};

const Impl = require(\\"../implementations/URLSearchParamsCollection2.js\\");
"
`;

exports[`with processors UnderscoredProperties.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"UnderscoredProperties\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'UnderscoredProperties'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"UnderscoredProperties\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor UnderscoredProperties is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class UnderscoredProperties {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    operation(sequence) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'operation' on 'UnderscoredProperties': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (!utils.isObject(curArg)) {
          throw new TypeError(
            \\"Failed to execute 'operation' on 'UnderscoredProperties': parameter 1\\" + \\" is not an iterable object.\\"
          );
        } else {
          const V = [];
          const tmp = curArg;
          for (let nextItem of tmp) {
            nextItem = conversions[\\"DOMString\\"](nextItem, {
              context: \\"Failed to execute 'operation' on 'UnderscoredProperties': parameter 1\\" + \\"'s element\\"
            });

            V.push(nextItem);
          }
          curArg = V;
        }
        args.push(curArg);
      }
      return this[impl].operation(...args);
    }

    get attribute() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"attribute\\"];
    }

    set attribute(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"byte\\"](V, {
        context: \\"Failed to set the 'attribute' property on 'UnderscoredProperties': The provided value\\"
      });

      this[impl][\\"attribute\\"] = V;
    }

    static static(void_) {
      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'static' on 'UnderscoredProperties': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'static' on 'UnderscoredProperties': parameter 1\\"
        });
        args.push(curArg);
      }
      return Impl.implementation.static(...args);
    }
  }
  Object.defineProperties(UnderscoredProperties.prototype, {
    operation: { enumerable: true },
    attribute: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"UnderscoredProperties\\", configurable: true },
    const: { value: 42, enumerable: true }
  });
  Object.defineProperties(UnderscoredProperties, {
    static: { enumerable: true },
    const: { value: 42, enumerable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = UnderscoredProperties;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: UnderscoredProperties
  });
};

const Impl = require(\\"../implementations/UnderscoredProperties.js\\");
"
`;

exports[`with processors Unforgeable.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"Unforgeable\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'Unforgeable'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"Unforgeable\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor Unforgeable is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {
  Object.defineProperties(
    obj,
    Object.getOwnPropertyDescriptors({
      assign(url) {
        if (!this || !exports.is(this)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        if (arguments.length < 1) {
          throw new TypeError(
            \\"Failed to execute 'assign' on 'Unforgeable': 1 argument required, but only \\" +
              arguments.length +
              \\" present.\\"
          );
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions[\\"USVString\\"](curArg, {
            context: \\"Failed to execute 'assign' on 'Unforgeable': parameter 1\\"
          });
          args.push(curArg);
        }
        return this[impl].assign(...args);
      },
      get href() {
        if (!this || !exports.is(this)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return obj[impl][\\"href\\"];
      },
      set href(V) {
        if (!this || !exports.is(this)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        V = conversions[\\"USVString\\"](V, {
          context: \\"Failed to set the 'href' property on 'Unforgeable': The provided value\\"
        });

        obj[impl][\\"href\\"] = V;
      },
      toString() {
        if (!this || !exports.is(this)) {
          throw new TypeError(\\"Illegal invocation\\");
        }
        return obj[impl][\\"href\\"];
      },
      get origin() {
        if (!this || !exports.is(this)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return obj[impl][\\"origin\\"];
      },
      get protocol() {
        if (!this || !exports.is(this)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return obj[impl][\\"protocol\\"];
      },
      set protocol(V) {
        if (!this || !exports.is(this)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        V = conversions[\\"USVString\\"](V, {
          context: \\"Failed to set the 'protocol' property on 'Unforgeable': The provided value\\"
        });

        obj[impl][\\"protocol\\"] = V;
      }
    })
  );

  Object.defineProperties(obj, {
    assign: { configurable: false, writable: false },
    href: { configurable: false },
    toString: { configurable: false, writable: false },
    origin: { configurable: false },
    protocol: { configurable: false }
  });
};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class Unforgeable {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }
  }
  Object.defineProperties(Unforgeable.prototype, {
    [Symbol.toStringTag]: { value: \\"Unforgeable\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = Unforgeable;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: Unforgeable
  });
};

const Impl = require(\\"../implementations/Unforgeable.js\\");
"
`;

exports[`with processors UnforgeableMap.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"UnforgeableMap\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'UnforgeableMap'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"UnforgeableMap\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor UnforgeableMap is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {
  Object.defineProperties(
    obj,
    Object.getOwnPropertyDescriptors({
      get a() {
        if (!this || !exports.is(this)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return obj[impl][\\"a\\"];
      }
    })
  );

  Object.defineProperties(obj, { a: { configurable: false } });
};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj = new Proxy(obj, proxyHandler);

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class UnforgeableMap {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }
  }
  Object.defineProperties(UnforgeableMap.prototype, {
    [Symbol.toStringTag]: { value: \\"UnforgeableMap\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = UnforgeableMap;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: UnforgeableMap
  });
};

const proxyHandler = {
  get(target, P, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.get(target, P, receiver);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc === undefined) {
      const parent = Object.getPrototypeOf(target);
      if (parent === null) {
        return undefined;
      }
      return Reflect.get(target, P, receiver);
    }
    if (!desc.get && !desc.set) {
      return desc.value;
    }
    const getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return Reflect.apply(getter, receiver, []);
  },

  has(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.has(target, P);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc !== undefined) {
      return true;
    }
    const parent = Object.getPrototypeOf(target);
    if (parent !== null) {
      return Reflect.has(parent, P);
    }
    return false;
  },

  ownKeys(target) {
    const keys = new Set();

    for (const key of target[impl][utils.supportedPropertyNames]) {
      if (!(key in target)) {
        keys.add(\`\${key}\`);
      }
    }

    for (const key of Reflect.ownKeys(target)) {
      keys.add(key);
    }
    return [...keys];
  },

  getOwnPropertyDescriptor(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.getOwnPropertyDescriptor(target, P);
    }
    let ignoreNamedProps = false;

    if (target[impl][utils.supportsPropertyName](P) && !(P in target) && !ignoreNamedProps) {
      const namedValue = target[impl][utils.namedGet](P);

      return {
        writable: true,
        enumerable: true,
        configurable: true,
        value: utils.tryWrapperForImpl(namedValue)
      };
    }

    return Reflect.getOwnPropertyDescriptor(target, P);
  },

  set(target, P, V, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.set(target, P, V, receiver);
    }
    if (target === receiver) {
      if (typeof P === \\"string\\" && !utils.isArrayIndexPropName(P)) {
        let namedValue = V;

        namedValue = conversions[\\"DOMString\\"](namedValue, {
          context: \\"Failed to set the '\\" + P + \\"' property on 'UnforgeableMap': The provided value\\"
        });

        const creating = !target[impl][utils.supportsPropertyName](P);
        if (creating) {
          target[impl][utils.namedSetNew](P, namedValue);
        } else {
          target[impl][utils.namedSetExisting](P, namedValue);
        }

        return true;
      }
    }
    let ownDesc;

    if (ownDesc === undefined) {
      ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
    }
    if (ownDesc === undefined) {
      const parent = Reflect.getPrototypeOf(target);
      if (parent !== null) {
        return Reflect.set(parent, P, V, receiver);
      }
      ownDesc = { writable: true, enumerable: true, configurable: true, value: undefined };
    }
    if (!ownDesc.writable) {
      return false;
    }
    if (!utils.isObject(receiver)) {
      return false;
    }
    const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
    let valueDesc;
    if (existingDesc !== undefined) {
      if (existingDesc.get || existingDesc.set) {
        return false;
      }
      if (!existingDesc.writable) {
        return false;
      }
      valueDesc = { value: V };
    } else {
      valueDesc = { writable: true, enumerable: true, configurable: true, value: V };
    }
    return Reflect.defineProperty(receiver, P, valueDesc);
  },

  defineProperty(target, P, desc) {
    if (typeof P === \\"symbol\\") {
      return Reflect.defineProperty(target, P, desc);
    }
    if (![\\"a\\"].includes(P)) {
      if (!utils.hasOwn(target, P)) {
        if (desc.get || desc.set) {
          return false;
        }

        let namedValue = desc.value;

        namedValue = conversions[\\"DOMString\\"](namedValue, {
          context: \\"Failed to set the '\\" + P + \\"' property on 'UnforgeableMap': The provided value\\"
        });

        const creating = !target[impl][utils.supportsPropertyName](P);
        if (creating) {
          target[impl][utils.namedSetNew](P, namedValue);
        } else {
          target[impl][utils.namedSetExisting](P, namedValue);
        }

        return true;
      }
    }
    return Reflect.defineProperty(target, P, desc);
  },

  deleteProperty(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.deleteProperty(target, P);
    }

    if (target[impl][utils.supportsPropertyName](P) && !(P in target)) {
      return false;
    }

    return Reflect.deleteProperty(target, P);
  },

  preventExtensions() {
    return false;
  }
};

const Impl = require(\\"../implementations/UnforgeableMap.js\\");
"
`;

exports[`with processors Unscopable.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"Unscopable\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'Unscopable'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"Unscopable\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor Unscopable is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class Unscopable {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    get unscopableTest() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"unscopableTest\\"];
    }

    set unscopableTest(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"boolean\\"](V, {
        context: \\"Failed to set the 'unscopableTest' property on 'Unscopable': The provided value\\"
      });

      this[impl][\\"unscopableTest\\"] = V;
    }

    get unscopableMixin() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"unscopableMixin\\"];
    }

    set unscopableMixin(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"boolean\\"](V, {
        context: \\"Failed to set the 'unscopableMixin' property on 'Unscopable': The provided value\\"
      });

      this[impl][\\"unscopableMixin\\"] = V;
    }
  }
  Object.defineProperties(Unscopable.prototype, {
    unscopableTest: { enumerable: true },
    unscopableMixin: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"Unscopable\\", configurable: true },
    [Symbol.unscopables]: {
      value: { unscopableTest: true, unscopableMixin: true, __proto__: null },
      configurable: true
    }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = Unscopable;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: Unscopable
  });
};

const Impl = require(\\"../implementations/Unscopable.js\\");
"
`;

exports[`with processors Variadic.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const convertURL = require(\\"./URL.js\\").convert;
const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"Variadic\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'Variadic'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"Variadic\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor Variadic is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class Variadic {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    simple1() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
      const args = [];
      for (let i = 0; i < arguments.length; i++) {
        let curArg = arguments[i];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'simple1' on 'Variadic': parameter \\" + (i + 1)
        });
        args.push(curArg);
      }
      return this[impl].simple1(...args);
    }

    simple2(first) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'simple2' on 'Variadic': 1 argument required, but only \\" + arguments.length + \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'simple2' on 'Variadic': parameter 1\\"
        });
        args.push(curArg);
      }
      for (let i = 1; i < arguments.length; i++) {
        let curArg = arguments[i];
        curArg = convertURL(curArg, { context: \\"Failed to execute 'simple2' on 'Variadic': parameter \\" + (i + 1) });
        args.push(curArg);
      }
      return this[impl].simple2(...args);
    }

    overloaded1() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
      const args = [];
      switch (arguments.length) {
        case 0:
          break;
        default: {
          let curArg = arguments[0];
          if (typeof curArg === \\"number\\") {
            for (let i = 0; i < arguments.length; i++) {
              let curArg = arguments[i];
              curArg = conversions[\\"unsigned long\\"](curArg, {
                context: \\"Failed to execute 'overloaded1' on 'Variadic': parameter \\" + (i + 1)
              });
              args.push(curArg);
            }
          } else {
            for (let i = 0; i < arguments.length; i++) {
              let curArg = arguments[i];
              curArg = conversions[\\"DOMString\\"](curArg, {
                context: \\"Failed to execute 'overloaded1' on 'Variadic': parameter \\" + (i + 1)
              });
              args.push(curArg);
            }
          }
        }
      }
      return this[impl].overloaded1(...args);
    }

    overloaded2(first) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'overloaded2' on 'Variadic': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      switch (arguments.length) {
        case 1:
          {
            let curArg = arguments[0];
            if (typeof curArg === \\"number\\") {
              {
                let curArg = arguments[0];
                curArg = conversions[\\"unsigned long\\"](curArg, {
                  context: \\"Failed to execute 'overloaded2' on 'Variadic': parameter 1\\"
                });
                args.push(curArg);
              }
            } else {
              {
                let curArg = arguments[0];
                curArg = conversions[\\"DOMString\\"](curArg, {
                  context: \\"Failed to execute 'overloaded2' on 'Variadic': parameter 1\\"
                });
                args.push(curArg);
              }
            }
          }
          break;
        default: {
          let curArg = arguments[0];
          if (typeof curArg === \\"number\\") {
            {
              let curArg = arguments[0];
              curArg = conversions[\\"unsigned long\\"](curArg, {
                context: \\"Failed to execute 'overloaded2' on 'Variadic': parameter 1\\"
              });
              args.push(curArg);
            }
            for (let i = 1; i < arguments.length; i++) {
              let curArg = arguments[i];
              curArg = conversions[\\"DOMString\\"](curArg, {
                context: \\"Failed to execute 'overloaded2' on 'Variadic': parameter \\" + (i + 1)
              });
              args.push(curArg);
            }
          } else {
            {
              let curArg = arguments[0];
              curArg = conversions[\\"DOMString\\"](curArg, {
                context: \\"Failed to execute 'overloaded2' on 'Variadic': parameter 1\\"
              });
              args.push(curArg);
            }
            for (let i = 1; i < arguments.length; i++) {
              let curArg = arguments[i];
              curArg = conversions[\\"DOMString\\"](curArg, {
                context: \\"Failed to execute 'overloaded2' on 'Variadic': parameter \\" + (i + 1)
              });
              args.push(curArg);
            }
          }
        }
      }
      return this[impl].overloaded2(...args);
    }
  }
  Object.defineProperties(Variadic.prototype, {
    simple1: { enumerable: true },
    simple2: { enumerable: true },
    overloaded1: { enumerable: true },
    overloaded2: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"Variadic\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = Variadic;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: Variadic
  });
};

const Impl = require(\\"../implementations/Variadic.js\\");
"
`;

exports[`with processors ZeroArgConstructor.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"ZeroArgConstructor\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'ZeroArgConstructor'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"ZeroArgConstructor\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor ZeroArgConstructor is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class ZeroArgConstructor {
    constructor() {
      return exports.setup(Object.create(new.target.prototype), globalObject, undefined);
    }
  }
  Object.defineProperties(ZeroArgConstructor.prototype, {
    [Symbol.toStringTag]: { value: \\"ZeroArgConstructor\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = ZeroArgConstructor;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: ZeroArgConstructor
  });
};

const Impl = require(\\"../implementations/ZeroArgConstructor.js\\");
"
`;

exports[`without processors BufferSourceTypes.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"BufferSourceTypes\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'BufferSourceTypes'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"BufferSourceTypes\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor BufferSourceTypes is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class BufferSourceTypes {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    bs(source) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'bs' on 'BufferSourceTypes': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (utils.isArrayBuffer(curArg)) {
        } else if (ArrayBuffer.isView(curArg)) {
        } else {
          throw new TypeError(
            \\"Failed to execute 'bs' on 'BufferSourceTypes': parameter 1\\" + \\" is not of any supported type.\\"
          );
        }
        args.push(curArg);
      }
      return this[impl].bs(...args);
    }

    ab(ab) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'ab' on 'BufferSourceTypes': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"ArrayBuffer\\"](curArg, {
          context: \\"Failed to execute 'ab' on 'BufferSourceTypes': parameter 1\\"
        });
        args.push(curArg);
      }
      return this[impl].ab(...args);
    }

    abv(abv) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'abv' on 'BufferSourceTypes': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (ArrayBuffer.isView(curArg)) {
        } else {
          throw new TypeError(
            \\"Failed to execute 'abv' on 'BufferSourceTypes': parameter 1\\" + \\" is not of any supported type.\\"
          );
        }
        args.push(curArg);
      }
      return this[impl].abv(...args);
    }

    u8a(u8) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'u8a' on 'BufferSourceTypes': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"Uint8Array\\"](curArg, {
          context: \\"Failed to execute 'u8a' on 'BufferSourceTypes': parameter 1\\"
        });
        args.push(curArg);
      }
      return this[impl].u8a(...args);
    }

    abUnion(ab) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'abUnion' on 'BufferSourceTypes': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (utils.isArrayBuffer(curArg)) {
        } else {
          curArg = conversions[\\"DOMString\\"](curArg, {
            context: \\"Failed to execute 'abUnion' on 'BufferSourceTypes': parameter 1\\"
          });
        }
        args.push(curArg);
      }
      return this[impl].abUnion(...args);
    }

    u8aUnion(ab) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'u8aUnion' on 'BufferSourceTypes': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (ArrayBuffer.isView(curArg) && curArg.constructor.name === \\"Uint8Array\\") {
        } else {
          curArg = conversions[\\"DOMString\\"](curArg, {
            context: \\"Failed to execute 'u8aUnion' on 'BufferSourceTypes': parameter 1\\"
          });
        }
        args.push(curArg);
      }
      return this[impl].u8aUnion(...args);
    }
  }
  Object.defineProperties(BufferSourceTypes.prototype, {
    bs: { enumerable: true },
    ab: { enumerable: true },
    abv: { enumerable: true },
    u8a: { enumerable: true },
    abUnion: { enumerable: true },
    u8aUnion: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"BufferSourceTypes\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = BufferSourceTypes;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: BufferSourceTypes
  });
};

const Impl = require(\\"../implementations/BufferSourceTypes.js\\");
"
`;

exports[`without processors CEReactions.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"CEReactions\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'CEReactions'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"CEReactions\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor CEReactions is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  {
    let proxyHandler = proxyHandlerCache.get(globalObject);
    if (proxyHandler === undefined) {
      proxyHandler = new ProxyHandler(globalObject);
      proxyHandlerCache.set(globalObject, proxyHandler);
    }
    obj = new Proxy(obj, proxyHandler);
  }

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class CEReactions {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    method() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl].method();
    }

    get attr() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"attr\\"];
    }

    set attr(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"DOMString\\"](V, {
        context: \\"Failed to set the 'attr' property on 'CEReactions': The provided value\\"
      });

      this[impl][\\"attr\\"] = V;
    }
  }
  Object.defineProperties(CEReactions.prototype, {
    method: { enumerable: true },
    attr: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"CEReactions\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = CEReactions;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: CEReactions
  });
};

const proxyHandlerCache = new WeakMap();
class ProxyHandler {
  constructor(globalObject) {
    this._globalObject = globalObject;
  }

  get(target, P, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.get(target, P, receiver);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc === undefined) {
      const parent = Object.getPrototypeOf(target);
      if (parent === null) {
        return undefined;
      }
      return Reflect.get(target, P, receiver);
    }
    if (!desc.get && !desc.set) {
      return desc.value;
    }
    const getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return Reflect.apply(getter, receiver, []);
  }

  has(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.has(target, P);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc !== undefined) {
      return true;
    }
    const parent = Object.getPrototypeOf(target);
    if (parent !== null) {
      return Reflect.has(parent, P);
    }
    return false;
  }

  ownKeys(target) {
    const keys = new Set();

    for (const key of target[impl][utils.supportedPropertyNames]) {
      if (!(key in target)) {
        keys.add(\`\${key}\`);
      }
    }

    for (const key of Reflect.ownKeys(target)) {
      keys.add(key);
    }
    return [...keys];
  }

  getOwnPropertyDescriptor(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.getOwnPropertyDescriptor(target, P);
    }
    let ignoreNamedProps = false;

    if (target[impl][utils.supportsPropertyName](P) && !(P in target) && !ignoreNamedProps) {
      const namedValue = target[impl][utils.namedGet](P);

      return {
        writable: true,
        enumerable: true,
        configurable: true,
        value: utils.tryWrapperForImpl(namedValue)
      };
    }

    return Reflect.getOwnPropertyDescriptor(target, P);
  }

  set(target, P, V, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.set(target, P, V, receiver);
    }
    if (target === receiver) {
      const globalObject = this._globalObject;

      if (typeof P === \\"string\\" && !utils.isArrayIndexPropName(P)) {
        let namedValue = V;

        namedValue = conversions[\\"DOMString\\"](namedValue, {
          context: \\"Failed to set the '\\" + P + \\"' property on 'CEReactions': The provided value\\"
        });

        const creating = !target[impl][utils.supportsPropertyName](P);
        if (creating) {
          target[impl][utils.namedSetNew](P, namedValue);
        } else {
          target[impl][utils.namedSetExisting](P, namedValue);
        }

        return true;
      }
    }
    let ownDesc;

    if (ownDesc === undefined) {
      ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
    }
    if (ownDesc === undefined) {
      const parent = Reflect.getPrototypeOf(target);
      if (parent !== null) {
        return Reflect.set(parent, P, V, receiver);
      }
      ownDesc = { writable: true, enumerable: true, configurable: true, value: undefined };
    }
    if (!ownDesc.writable) {
      return false;
    }
    if (!utils.isObject(receiver)) {
      return false;
    }
    const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
    let valueDesc;
    if (existingDesc !== undefined) {
      if (existingDesc.get || existingDesc.set) {
        return false;
      }
      if (!existingDesc.writable) {
        return false;
      }
      valueDesc = { value: V };
    } else {
      valueDesc = { writable: true, enumerable: true, configurable: true, value: V };
    }
    return Reflect.defineProperty(receiver, P, valueDesc);
  }

  defineProperty(target, P, desc) {
    if (typeof P === \\"symbol\\") {
      return Reflect.defineProperty(target, P, desc);
    }

    const globalObject = this._globalObject;
    if (!utils.hasOwn(target, P)) {
      if (desc.get || desc.set) {
        return false;
      }

      let namedValue = desc.value;

      namedValue = conversions[\\"DOMString\\"](namedValue, {
        context: \\"Failed to set the '\\" + P + \\"' property on 'CEReactions': The provided value\\"
      });

      const creating = !target[impl][utils.supportsPropertyName](P);
      if (creating) {
        target[impl][utils.namedSetNew](P, namedValue);
      } else {
        target[impl][utils.namedSetExisting](P, namedValue);
      }

      return true;
    }
    return Reflect.defineProperty(target, P, desc);
  }

  deleteProperty(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.deleteProperty(target, P);
    }

    const globalObject = this._globalObject;

    if (target[impl][utils.supportsPropertyName](P) && !(P in target)) {
      target[impl][utils.namedDelete](P);
      return true;
    }

    return Reflect.deleteProperty(target, P);
  }

  preventExtensions() {
    return false;
  }
}

const Impl = require(\\"../implementations/CEReactions.js\\");
"
`;

exports[`without processors DOMImplementation.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"DOMImplementation\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'DOMImplementation'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"DOMImplementation\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor DOMImplementation is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class DOMImplementation {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    createDocumentType(qualifiedName, publicId, systemId) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 3) {
        throw new TypeError(
          \\"Failed to execute 'createDocumentType' on 'DOMImplementation': 3 arguments required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'createDocumentType' on 'DOMImplementation': parameter 1\\"
        });
        args.push(curArg);
      }
      {
        let curArg = arguments[1];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'createDocumentType' on 'DOMImplementation': parameter 2\\"
        });
        args.push(curArg);
      }
      {
        let curArg = arguments[2];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'createDocumentType' on 'DOMImplementation': parameter 3\\"
        });
        args.push(curArg);
      }
      return utils.tryWrapperForImpl(this[impl].createDocumentType(...args));
    }

    createDocument(namespace, qualifiedName) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 2) {
        throw new TypeError(
          \\"Failed to execute 'createDocument' on 'DOMImplementation': 2 arguments required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg === null || curArg === undefined) {
          curArg = null;
        } else {
          curArg = conversions[\\"DOMString\\"](curArg, {
            context: \\"Failed to execute 'createDocument' on 'DOMImplementation': parameter 1\\"
          });
        }
        args.push(curArg);
      }
      {
        let curArg = arguments[1];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'createDocument' on 'DOMImplementation': parameter 2\\",
          treatNullAsEmptyString: true
        });
        args.push(curArg);
      }
      {
        let curArg = arguments[2];
        if (curArg !== undefined) {
          if (curArg === null || curArg === undefined) {
            curArg = null;
          } else {
            curArg = utils.tryImplForWrapper(curArg);
          }
        } else {
          curArg = null;
        }
        args.push(curArg);
      }
      return utils.tryWrapperForImpl(this[impl].createDocument(...args));
    }

    createHTMLDocument() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg !== undefined) {
          curArg = conversions[\\"DOMString\\"](curArg, {
            context: \\"Failed to execute 'createHTMLDocument' on 'DOMImplementation': parameter 1\\"
          });
        }
        args.push(curArg);
      }
      return utils.tryWrapperForImpl(this[impl].createHTMLDocument(...args));
    }

    hasFeature() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl].hasFeature();
    }
  }
  Object.defineProperties(DOMImplementation.prototype, {
    createDocumentType: { enumerable: true },
    createDocument: { enumerable: true },
    createHTMLDocument: { enumerable: true },
    hasFeature: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"DOMImplementation\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = DOMImplementation;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: DOMImplementation
  });
};

const Impl = require(\\"../implementations/DOMImplementation.js\\");
"
`;

exports[`without processors Dictionary.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const convertURL = require(\\"./URL.js\\").convert;
const convertURLSearchParams = require(\\"./URLSearchParams.js\\").convert;

exports.convertInherit = function convertInherit(obj, ret, { context = \\"The provided value\\" } = {}) {
  {
    const key = \\"boolWithDefault\\";
    let value = obj === undefined || obj === null ? undefined : obj[key];
    if (value !== undefined) {
      value = conversions[\\"boolean\\"](value, { context: context + \\" has member boolWithDefault that\\" });

      ret[key] = value;
    } else {
      ret[key] = false;
    }
  }

  {
    const key = \\"requiredInterface\\";
    let value = obj === undefined || obj === null ? undefined : obj[key];
    if (value !== undefined) {
      value = convertURL(value, { context: context + \\" has member requiredInterface that\\" });

      ret[key] = value;
    } else {
      throw new TypeError(\\"requiredInterface is required in 'Dictionary'\\");
    }
  }

  {
    const key = \\"seq\\";
    let value = obj === undefined || obj === null ? undefined : obj[key];
    if (value !== undefined) {
      if (!utils.isObject(value)) {
        throw new TypeError(context + \\" has member seq that\\" + \\" is not an iterable object.\\");
      } else {
        const V = [];
        const tmp = value;
        for (let nextItem of tmp) {
          nextItem = convertURLSearchParams(nextItem, { context: context + \\" has member seq that\\" + \\"'s element\\" });

          V.push(nextItem);
        }
        value = V;
      }

      ret[key] = value;
    }
  }

  {
    const key = \\"vanillaString\\";
    let value = obj === undefined || obj === null ? undefined : obj[key];
    if (value !== undefined) {
      value = conversions[\\"DOMString\\"](value, { context: context + \\" has member vanillaString that\\" });

      ret[key] = value;
    }
  }
};

exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (obj !== undefined && typeof obj !== \\"object\\" && typeof obj !== \\"function\\") {
    throw new TypeError(\`\${context} is not an object.\`);
  }

  const ret = Object.create(null);
  module.exports.convertInherit(obj, ret, { context });
  return ret;
};
"
`;

exports[`without processors DictionaryConvert.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const convertDictionary = require(\\"./Dictionary.js\\").convert;
const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"DictionaryConvert\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'DictionaryConvert'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"DictionaryConvert\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor DictionaryConvert is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class DictionaryConvert {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    op() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg !== undefined) {
          curArg = conversions[\\"DOMString\\"](curArg, {
            context: \\"Failed to execute 'op' on 'DictionaryConvert': parameter 1\\"
          });
        }
        args.push(curArg);
      }
      {
        let curArg = arguments[1];
        curArg = convertDictionary(curArg, { context: \\"Failed to execute 'op' on 'DictionaryConvert': parameter 2\\" });
        args.push(curArg);
      }
      return this[impl].op(...args);
    }
  }
  Object.defineProperties(DictionaryConvert.prototype, {
    op: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"DictionaryConvert\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = DictionaryConvert;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: DictionaryConvert
  });
};

const Impl = require(\\"../implementations/DictionaryConvert.js\\");
"
`;

exports[`without processors Enum.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const convertRequestDestination = require(\\"./RequestDestination.js\\").convert;
const RequestDestination = require(\\"./RequestDestination.js\\");
const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"Enum\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'Enum'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"Enum\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor Enum is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class Enum {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    op(destination) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'op' on 'Enum': 1 argument required, but only \\" + arguments.length + \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = convertRequestDestination(curArg, { context: \\"Failed to execute 'op' on 'Enum': parameter 1\\" });
        args.push(curArg);
      }
      return this[impl].op(...args);
    }

    get attr() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return utils.tryWrapperForImpl(this[impl][\\"attr\\"]);
    }

    set attr(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = \`\${V}\`;
      if (!RequestDestination.enumerationValues.has(V)) {
        return;
      }

      this[impl][\\"attr\\"] = V;
    }
  }
  Object.defineProperties(Enum.prototype, {
    op: { enumerable: true },
    attr: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"Enum\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = Enum;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: Enum
  });
};

const Impl = require(\\"../implementations/Enum.js\\");
"
`;

exports[`without processors Global.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"Global\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'Global'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"Global\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor Global is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {
  Object.defineProperties(
    obj,
    Object.getOwnPropertyDescriptors({
      op() {
        if (!this || !exports.is(this)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return this[impl].op();
      },
      unforgeableOp() {
        if (!this || !exports.is(this)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return this[impl].unforgeableOp();
      },
      get attr() {
        if (!this || !exports.is(this)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return obj[impl][\\"attr\\"];
      },
      set attr(V) {
        if (!this || !exports.is(this)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        V = conversions[\\"DOMString\\"](V, {
          context: \\"Failed to set the 'attr' property on 'Global': The provided value\\"
        });

        obj[impl][\\"attr\\"] = V;
      },
      get unforgeableAttr() {
        if (!this || !exports.is(this)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return obj[impl][\\"unforgeableAttr\\"];
      },
      set unforgeableAttr(V) {
        if (!this || !exports.is(this)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        V = conversions[\\"DOMString\\"](V, {
          context: \\"Failed to set the 'unforgeableAttr' property on 'Global': The provided value\\"
        });

        obj[impl][\\"unforgeableAttr\\"] = V;
      },
      get length() {
        if (!this || !exports.is(this)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return obj[impl][\\"length\\"];
      },
      set length(V) {
        if (!this || !exports.is(this)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        V = conversions[\\"unsigned long\\"](V, {
          context: \\"Failed to set the 'length' property on 'Global': The provided value\\"
        });

        obj[impl][\\"length\\"] = V;
      },
      [Symbol.iterator]: Array.prototype[Symbol.iterator],
      keys: Array.prototype.keys,
      values: Array.prototype[Symbol.iterator],
      entries: Array.prototype.entries,
      forEach: Array.prototype.forEach
    })
  );

  Object.defineProperties(obj, {
    unforgeableOp: { configurable: false, writable: false },
    unforgeableAttr: { configurable: false },
    [Symbol.iterator]: { enumerable: false }
  });
};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class Global {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }
  }
  Object.defineProperties(Global.prototype, { [Symbol.toStringTag]: { value: \\"Global\\", configurable: true } });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = Global;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: Global
  });
};

const Impl = require(\\"../implementations/Global.js\\");
"
`;

exports[`without processors HTMLConstructor.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"HTMLConstructor\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'HTMLConstructor'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"HTMLConstructor\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor HTMLConstructor is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class HTMLConstructor {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }
  }
  Object.defineProperties(HTMLConstructor.prototype, {
    [Symbol.toStringTag]: { value: \\"HTMLConstructor\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = HTMLConstructor;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: HTMLConstructor
  });
};

const Impl = require(\\"../implementations/HTMLConstructor.js\\");
"
`;

exports[`without processors LegacyArrayClass.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"LegacyArrayClass\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'LegacyArrayClass'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"LegacyArrayClass\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor LegacyArrayClass is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class LegacyArrayClass {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    get length() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"length\\"];
    }
  }
  Object.setPrototypeOf(LegacyArrayClass.prototype, Array.prototype);
  Object.defineProperties(LegacyArrayClass.prototype, {
    length: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"LegacyArrayClass\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = LegacyArrayClass;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: LegacyArrayClass
  });
};

const Impl = require(\\"../implementations/LegacyArrayClass.js\\");
"
`;

exports[`without processors MixedIn.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"MixedIn\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'MixedIn'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"MixedIn\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor MixedIn is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class MixedIn {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    mixedInOp() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl].mixedInOp();
    }

    ifaceMixinOp() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl].ifaceMixinOp();
    }

    get mixedInAttr() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"mixedInAttr\\"];
    }

    set mixedInAttr(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"DOMString\\"](V, {
        context: \\"Failed to set the 'mixedInAttr' property on 'MixedIn': The provided value\\"
      });

      this[impl][\\"mixedInAttr\\"] = V;
    }

    get ifaceMixinAttr() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"ifaceMixinAttr\\"];
    }

    set ifaceMixinAttr(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"DOMString\\"](V, {
        context: \\"Failed to set the 'ifaceMixinAttr' property on 'MixedIn': The provided value\\"
      });

      this[impl][\\"ifaceMixinAttr\\"] = V;
    }
  }
  Object.defineProperties(MixedIn.prototype, {
    mixedInOp: { enumerable: true },
    ifaceMixinOp: { enumerable: true },
    mixedInAttr: { enumerable: true },
    ifaceMixinAttr: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"MixedIn\\", configurable: true },
    mixedInConst: { value: 43, enumerable: true },
    ifaceMixinConst: { value: 42, enumerable: true }
  });
  Object.defineProperties(MixedIn, {
    mixedInConst: { value: 43, enumerable: true },
    ifaceMixinConst: { value: 42, enumerable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = MixedIn;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: MixedIn
  });
};

const Impl = require(\\"../implementations/MixedIn.js\\");
"
`;

exports[`without processors Overloads.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const isURL = require(\\"./URL.js\\").is;
const convertURL = require(\\"./URL.js\\").convert;
const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"Overloads\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'Overloads'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"Overloads\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor Overloads is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class Overloads {
    constructor() {
      const args = [];
      switch (arguments.length) {
        case 0:
          break;
        default: {
          let curArg = arguments[0];
          if (isURL(curArg)) {
            {
              let curArg = arguments[0];
              curArg = convertURL(curArg, { context: \\"Failed to construct 'Overloads': parameter 1\\" });
              args.push(curArg);
            }
          } else {
            {
              let curArg = arguments[0];
              curArg = conversions[\\"DOMString\\"](curArg, { context: \\"Failed to construct 'Overloads': parameter 1\\" });
              args.push(curArg);
            }
          }
        }
      }
      return exports.setup(Object.create(new.target.prototype), globalObject, args);
    }

    compatible(arg1) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'compatible' on 'Overloads': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      switch (arguments.length) {
        case 1:
          {
            let curArg = arguments[0];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'compatible' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
          break;
        case 2:
          {
            let curArg = arguments[0];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'compatible' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'compatible' on 'Overloads': parameter 2\\"
            });
            args.push(curArg);
          }
          break;
        default:
          {
            let curArg = arguments[0];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'compatible' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'compatible' on 'Overloads': parameter 2\\"
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[2];
            if (curArg !== undefined) {
              curArg = conversions[\\"long\\"](curArg, {
                context: \\"Failed to execute 'compatible' on 'Overloads': parameter 3\\"
              });
            } else {
              curArg = 0;
            }
            args.push(curArg);
          }
      }
      return utils.tryWrapperForImpl(this[impl].compatible(...args));
    }

    incompatible1(arg1) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'incompatible1' on 'Overloads': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (typeof curArg === \\"number\\") {
          {
            let curArg = arguments[0];
            curArg = conversions[\\"long\\"](curArg, {
              context: \\"Failed to execute 'incompatible1' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
        } else {
          {
            let curArg = arguments[0];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'incompatible1' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
        }
      }
      return this[impl].incompatible1(...args);
    }

    incompatible2(arg1) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'incompatible2' on 'Overloads': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      switch (arguments.length) {
        case 1:
          {
            let curArg = arguments[0];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'incompatible2' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
          break;
        default:
          {
            let curArg = arguments[0];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'incompatible2' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'incompatible2' on 'Overloads': parameter 2\\"
            });
            args.push(curArg);
          }
      }
      return this[impl].incompatible2(...args);
    }

    incompatible3(arg1) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'incompatible3' on 'Overloads': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      switch (arguments.length) {
        case 1:
          {
            let curArg = arguments[0];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'incompatible3' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
          break;
        case 2:
          {
            let curArg = arguments[0];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'incompatible3' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            if (curArg === undefined) {
              {
                let curArg = arguments[1];
                if (curArg !== undefined) {
                  curArg = convertURL(curArg, {
                    context: \\"Failed to execute 'incompatible3' on 'Overloads': parameter 2\\"
                  });
                }
                args.push(curArg);
              }
            } else if (isURL(curArg)) {
              {
                let curArg = arguments[1];
                if (curArg !== undefined) {
                  curArg = convertURL(curArg, {
                    context: \\"Failed to execute 'incompatible3' on 'Overloads': parameter 2\\"
                  });
                }
                args.push(curArg);
              }
            } else if (utils.isArrayBuffer(curArg)) {
              {
                let curArg = arguments[1];
                if (utils.isArrayBuffer(curArg)) {
                } else if (ArrayBuffer.isView(curArg)) {
                } else {
                  throw new TypeError(
                    \\"Failed to execute 'incompatible3' on 'Overloads': parameter 2\\" + \\" is not of any supported type.\\"
                  );
                }
                args.push(curArg);
              }
            } else if (ArrayBuffer.isView(curArg)) {
              {
                let curArg = arguments[1];
                if (utils.isArrayBuffer(curArg)) {
                } else if (ArrayBuffer.isView(curArg)) {
                } else {
                  throw new TypeError(
                    \\"Failed to execute 'incompatible3' on 'Overloads': parameter 2\\" + \\" is not of any supported type.\\"
                  );
                }
                args.push(curArg);
              }
            } else {
              {
                let curArg = arguments[1];
                curArg = conversions[\\"DOMString\\"](curArg, {
                  context: \\"Failed to execute 'incompatible3' on 'Overloads': parameter 2\\"
                });
                args.push(curArg);
              }
            }
          }
          break;
        case 3:
          throw new TypeError(
            \\"Failed to execute 'incompatible3' on 'Overloads': only \\" + arguments.length + \\" arguments present.\\"
          );
          break;
        default:
          {
            let curArg = arguments[0];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'incompatible3' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            curArg = conversions[\\"long\\"](curArg, {
              context: \\"Failed to execute 'incompatible3' on 'Overloads': parameter 2\\"
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[2];
            if (utils.isArrayBuffer(curArg)) {
            } else if (ArrayBuffer.isView(curArg)) {
            } else {
              throw new TypeError(
                \\"Failed to execute 'incompatible3' on 'Overloads': parameter 3\\" + \\" is not of any supported type.\\"
              );
            }
            args.push(curArg);
          }
          {
            let curArg = arguments[3];
            if (utils.isArrayBuffer(curArg)) {
            } else if (ArrayBuffer.isView(curArg)) {
            } else {
              throw new TypeError(
                \\"Failed to execute 'incompatible3' on 'Overloads': parameter 4\\" + \\" is not of any supported type.\\"
              );
            }
            args.push(curArg);
          }
      }
      return this[impl].incompatible3(...args);
    }
  }
  Object.defineProperties(Overloads.prototype, {
    compatible: { enumerable: true },
    incompatible1: { enumerable: true },
    incompatible2: { enumerable: true },
    incompatible3: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"Overloads\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = Overloads;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: Overloads
  });
};

const Impl = require(\\"../implementations/Overloads.js\\");
"
`;

exports[`without processors PromiseTypes.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"PromiseTypes\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'PromiseTypes'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"PromiseTypes\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor PromiseTypes is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class PromiseTypes {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    voidPromiseConsumer(p) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'voidPromiseConsumer' on 'PromiseTypes': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = Promise.resolve(curArg).then(
          value => {},
          reason => reason
        );
        args.push(curArg);
      }
      return this[impl].voidPromiseConsumer(...args);
    }

    promiseConsumer(p) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'promiseConsumer' on 'PromiseTypes': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = Promise.resolve(curArg).then(
          value => {
            value = conversions[\\"double\\"](value, {
              context: \\"Failed to execute 'promiseConsumer' on 'PromiseTypes': parameter 1\\" + \\" promise value\\"
            });

            return value;
          },
          reason => reason
        );
        args.push(curArg);
      }
      return this[impl].promiseConsumer(...args);
    }
  }
  Object.defineProperties(PromiseTypes.prototype, {
    voidPromiseConsumer: { enumerable: true },
    promiseConsumer: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"PromiseTypes\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = PromiseTypes;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: PromiseTypes
  });
};

const Impl = require(\\"../implementations/PromiseTypes.js\\");
"
`;

exports[`without processors Reflect.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"Reflect\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'Reflect'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"Reflect\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor Reflect is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class Reflect {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    get ReflectedBoolean() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl].hasAttributeNS(null, \\"reflectedboolean\\");
    }

    set ReflectedBoolean(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"boolean\\"](V, {
        context: \\"Failed to set the 'ReflectedBoolean' property on 'Reflect': The provided value\\"
      });

      if (V) {
        this[impl].setAttributeNS(null, \\"reflectedboolean\\", \\"\\");
      } else {
        this[impl].removeAttributeNS(null, \\"reflectedboolean\\");
      }
    }

    get ReflectedDOMString() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      const value = this[impl].getAttributeNS(null, \\"reflecteddomstring\\");
      return value === null ? \\"\\" : value;
    }

    set ReflectedDOMString(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"DOMString\\"](V, {
        context: \\"Failed to set the 'ReflectedDOMString' property on 'Reflect': The provided value\\"
      });

      this[impl].setAttributeNS(null, \\"reflecteddomstring\\", V);
    }

    get ReflectedLong() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      const value = parseInt(this[impl].getAttributeNS(null, \\"reflectedlong\\"));
      return isNaN(value) || value < -2147483648 || value > 2147483647 ? 0 : value;
    }

    set ReflectedLong(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"long\\"](V, {
        context: \\"Failed to set the 'ReflectedLong' property on 'Reflect': The provided value\\"
      });

      this[impl].setAttributeNS(null, \\"reflectedlong\\", String(V));
    }

    get ReflectedUnsignedLong() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      const value = parseInt(this[impl].getAttributeNS(null, \\"reflectedunsignedlong\\"));
      return isNaN(value) || value < 0 || value > 2147483647 ? 0 : value;
    }

    set ReflectedUnsignedLong(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"unsigned long\\"](V, {
        context: \\"Failed to set the 'ReflectedUnsignedLong' property on 'Reflect': The provided value\\"
      });

      this[impl].setAttributeNS(null, \\"reflectedunsignedlong\\", String(V > 2147483647 ? 0 : V));
    }

    get ReflectionTest() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      const value = this[impl].getAttributeNS(null, \\"reflection\\");
      return value === null ? \\"\\" : value;
    }

    set ReflectionTest(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"DOMString\\"](V, {
        context: \\"Failed to set the 'ReflectionTest' property on 'Reflect': The provided value\\"
      });

      this[impl].setAttributeNS(null, \\"reflection\\", V);
    }

    get withUnderscore() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      const value = this[impl].getAttributeNS(null, \\"with-underscore\\");
      return value === null ? \\"\\" : value;
    }

    set withUnderscore(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"DOMString\\"](V, {
        context: \\"Failed to set the 'withUnderscore' property on 'Reflect': The provided value\\"
      });

      this[impl].setAttributeNS(null, \\"with-underscore\\", V);
    }
  }
  Object.defineProperties(Reflect.prototype, {
    ReflectedBoolean: { enumerable: true },
    ReflectedDOMString: { enumerable: true },
    ReflectedLong: { enumerable: true },
    ReflectedUnsignedLong: { enumerable: true },
    ReflectionTest: { enumerable: true },
    withUnderscore: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"Reflect\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = Reflect;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: Reflect
  });
};

const Impl = require(\\"../implementations/Reflect.js\\");
"
`;

exports[`without processors RequestDestination.webidl 1`] = `
"\\"use strict\\";

const enumerationValues = new Set([
  \\"\\",
  \\"audio\\",
  \\"document\\",
  \\"embed\\",
  \\"font\\",
  \\"image\\",
  \\"manifest\\",
  \\"object\\",
  \\"report\\",
  \\"script\\",
  \\"sharedworker\\",
  \\"style\\",
  \\"track\\",
  \\"video\\",
  \\"worker\\",
  \\"xslt\\"
]);
exports.enumerationValues = enumerationValues;

exports.convert = function convert(value, { context = \\"The provided value\\" } = {}) {
  const string = \`\${value}\`;
  if (!enumerationValues.has(value)) {
    throw new TypeError(\`\${context} '\${value}' is not a valid enumeration value for RequestDestination\`);
  }
  return string;
};
"
`;

exports[`without processors SeqAndRec.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const convertURL = require(\\"./URL.js\\").convert;
const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"SeqAndRec\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'SeqAndRec'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"SeqAndRec\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor SeqAndRec is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class SeqAndRec {
    constructor() {
      return exports.setup(Object.create(new.target.prototype), globalObject, undefined);
    }

    recordConsumer(rec) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'recordConsumer' on 'SeqAndRec': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (!utils.isObject(curArg)) {
          throw new TypeError(\\"Failed to execute 'recordConsumer' on 'SeqAndRec': parameter 1\\" + \\" is not an object.\\");
        } else {
          const result = Object.create(null);
          for (const key of Reflect.ownKeys(curArg)) {
            const desc = Object.getOwnPropertyDescriptor(curArg, key);
            if (desc && desc.enumerable) {
              let typedKey = key;

              typedKey = conversions[\\"USVString\\"](typedKey, {
                context: \\"Failed to execute 'recordConsumer' on 'SeqAndRec': parameter 1\\" + \\"'s key\\"
              });

              let typedValue = curArg[key];

              typedValue = conversions[\\"double\\"](typedValue, {
                context: \\"Failed to execute 'recordConsumer' on 'SeqAndRec': parameter 1\\" + \\"'s value\\"
              });

              result[typedKey] = typedValue;
            }
          }
          curArg = result;
        }
        args.push(curArg);
      }
      return this[impl].recordConsumer(...args);
    }

    recordConsumer2(rec) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'recordConsumer2' on 'SeqAndRec': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (!utils.isObject(curArg)) {
          throw new TypeError(\\"Failed to execute 'recordConsumer2' on 'SeqAndRec': parameter 1\\" + \\" is not an object.\\");
        } else {
          const result = Object.create(null);
          for (const key of Reflect.ownKeys(curArg)) {
            const desc = Object.getOwnPropertyDescriptor(curArg, key);
            if (desc && desc.enumerable) {
              let typedKey = key;

              typedKey = conversions[\\"USVString\\"](typedKey, {
                context: \\"Failed to execute 'recordConsumer2' on 'SeqAndRec': parameter 1\\" + \\"'s key\\"
              });

              let typedValue = curArg[key];

              typedValue = convertURL(typedValue, {
                context: \\"Failed to execute 'recordConsumer2' on 'SeqAndRec': parameter 1\\" + \\"'s value\\"
              });

              result[typedKey] = typedValue;
            }
          }
          curArg = result;
        }
        args.push(curArg);
      }
      return this[impl].recordConsumer2(...args);
    }

    sequenceConsumer(seq) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'sequenceConsumer' on 'SeqAndRec': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (!utils.isObject(curArg)) {
          throw new TypeError(
            \\"Failed to execute 'sequenceConsumer' on 'SeqAndRec': parameter 1\\" + \\" is not an iterable object.\\"
          );
        } else {
          const V = [];
          const tmp = curArg;
          for (let nextItem of tmp) {
            nextItem = conversions[\\"USVString\\"](nextItem, {
              context: \\"Failed to execute 'sequenceConsumer' on 'SeqAndRec': parameter 1\\" + \\"'s element\\"
            });

            V.push(nextItem);
          }
          curArg = V;
        }
        args.push(curArg);
      }
      return this[impl].sequenceConsumer(...args);
    }

    sequenceConsumer2(seq) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'sequenceConsumer2' on 'SeqAndRec': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (!utils.isObject(curArg)) {
          throw new TypeError(
            \\"Failed to execute 'sequenceConsumer2' on 'SeqAndRec': parameter 1\\" + \\" is not an iterable object.\\"
          );
        } else {
          const V = [];
          const tmp = curArg;
          for (let nextItem of tmp) {
            nextItem = utils.tryImplForWrapper(nextItem);

            V.push(nextItem);
          }
          curArg = V;
        }
        args.push(curArg);
      }
      return this[impl].sequenceConsumer2(...args);
    }

    frozenArrayConsumer(arr) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'frozenArrayConsumer' on 'SeqAndRec': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (!utils.isObject(curArg)) {
          throw new TypeError(
            \\"Failed to execute 'frozenArrayConsumer' on 'SeqAndRec': parameter 1\\" + \\" is not an iterable object.\\"
          );
        } else {
          const V = [];
          const tmp = curArg;
          for (let nextItem of tmp) {
            nextItem = conversions[\\"double\\"](nextItem, {
              context: \\"Failed to execute 'frozenArrayConsumer' on 'SeqAndRec': parameter 1\\" + \\"'s element\\"
            });

            V.push(nextItem);
          }
          curArg = V;
        }
        curArg = Object.freeze(curArg);
        args.push(curArg);
      }
      return this[impl].frozenArrayConsumer(...args);
    }
  }
  Object.defineProperties(SeqAndRec.prototype, {
    recordConsumer: { enumerable: true },
    recordConsumer2: { enumerable: true },
    sequenceConsumer: { enumerable: true },
    sequenceConsumer2: { enumerable: true },
    frozenArrayConsumer: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"SeqAndRec\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = SeqAndRec;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: SeqAndRec
  });
};

const Impl = require(\\"../implementations/SeqAndRec.js\\");
"
`;

exports[`without processors Static.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"Static\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'Static'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"Static\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor Static is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class Static {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    def() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl].def();
    }

    get abc() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"abc\\"];
    }

    set abc(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"DOMString\\"](V, { context: \\"Failed to set the 'abc' property on 'Static': The provided value\\" });

      this[impl][\\"abc\\"] = V;
    }

    static def() {
      return Impl.implementation.def();
    }

    static get abc() {
      return Impl.implementation[\\"abc\\"];
    }

    static set abc(V) {
      return Impl.implementation[\\"abc\\"];
    }
  }
  Object.defineProperties(Static.prototype, {
    def: { enumerable: true },
    abc: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"Static\\", configurable: true }
  });
  Object.defineProperties(Static, { def: { enumerable: true }, abc: { enumerable: true } });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = Static;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: Static
  });
};

const Impl = require(\\"../implementations/Static.js\\");
"
`;

exports[`without processors Storage.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"Storage\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'Storage'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"Storage\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor Storage is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj = new Proxy(obj, proxyHandler);

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class Storage {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    key(index) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'key' on 'Storage': 1 argument required, but only \\" + arguments.length + \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"unsigned long\\"](curArg, { context: \\"Failed to execute 'key' on 'Storage': parameter 1\\" });
        args.push(curArg);
      }
      return this[impl].key(...args);
    }

    getItem(key) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'getItem' on 'Storage': 1 argument required, but only \\" + arguments.length + \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"DOMString\\"](curArg, { context: \\"Failed to execute 'getItem' on 'Storage': parameter 1\\" });
        args.push(curArg);
      }
      return this[impl].getItem(...args);
    }

    setItem(key, value) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 2) {
        throw new TypeError(
          \\"Failed to execute 'setItem' on 'Storage': 2 arguments required, but only \\" + arguments.length + \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"DOMString\\"](curArg, { context: \\"Failed to execute 'setItem' on 'Storage': parameter 1\\" });
        args.push(curArg);
      }
      {
        let curArg = arguments[1];
        curArg = conversions[\\"DOMString\\"](curArg, { context: \\"Failed to execute 'setItem' on 'Storage': parameter 2\\" });
        args.push(curArg);
      }
      return this[impl].setItem(...args);
    }

    removeItem(key) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'removeItem' on 'Storage': 1 argument required, but only \\" + arguments.length + \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'removeItem' on 'Storage': parameter 1\\"
        });
        args.push(curArg);
      }
      return this[impl].removeItem(...args);
    }

    clear() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl].clear();
    }

    get length() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"length\\"];
    }
  }
  Object.defineProperties(Storage.prototype, {
    key: { enumerable: true },
    getItem: { enumerable: true },
    setItem: { enumerable: true },
    removeItem: { enumerable: true },
    clear: { enumerable: true },
    length: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"Storage\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = Storage;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: Storage
  });
};

const proxyHandler = {
  get(target, P, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.get(target, P, receiver);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc === undefined) {
      const parent = Object.getPrototypeOf(target);
      if (parent === null) {
        return undefined;
      }
      return Reflect.get(target, P, receiver);
    }
    if (!desc.get && !desc.set) {
      return desc.value;
    }
    const getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return Reflect.apply(getter, receiver, []);
  },

  has(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.has(target, P);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc !== undefined) {
      return true;
    }
    const parent = Object.getPrototypeOf(target);
    if (parent !== null) {
      return Reflect.has(parent, P);
    }
    return false;
  },

  ownKeys(target) {
    const keys = new Set();

    for (const key of target[impl][utils.supportedPropertyNames]) {
      if (!(key in target)) {
        keys.add(\`\${key}\`);
      }
    }

    for (const key of Reflect.ownKeys(target)) {
      keys.add(key);
    }
    return [...keys];
  },

  getOwnPropertyDescriptor(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.getOwnPropertyDescriptor(target, P);
    }
    let ignoreNamedProps = false;

    if (target[impl][utils.supportsPropertyName](P) && !(P in target) && !ignoreNamedProps) {
      const namedValue = target[impl].getItem(P);

      return {
        writable: true,
        enumerable: true,
        configurable: true,
        value: utils.tryWrapperForImpl(namedValue)
      };
    }

    return Reflect.getOwnPropertyDescriptor(target, P);
  },

  set(target, P, V, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.set(target, P, V, receiver);
    }
    if (target === receiver) {
      if (typeof P === \\"string\\" && !utils.isArrayIndexPropName(P)) {
        let namedValue = V;

        namedValue = conversions[\\"DOMString\\"](namedValue, {
          context: \\"Failed to set the '\\" + P + \\"' property on 'Storage': The provided value\\"
        });

        target[impl].setItem(P, namedValue);

        return true;
      }
    }
    let ownDesc;

    if (ownDesc === undefined) {
      ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
    }
    if (ownDesc === undefined) {
      const parent = Reflect.getPrototypeOf(target);
      if (parent !== null) {
        return Reflect.set(parent, P, V, receiver);
      }
      ownDesc = { writable: true, enumerable: true, configurable: true, value: undefined };
    }
    if (!ownDesc.writable) {
      return false;
    }
    if (!utils.isObject(receiver)) {
      return false;
    }
    const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
    let valueDesc;
    if (existingDesc !== undefined) {
      if (existingDesc.get || existingDesc.set) {
        return false;
      }
      if (!existingDesc.writable) {
        return false;
      }
      valueDesc = { value: V };
    } else {
      valueDesc = { writable: true, enumerable: true, configurable: true, value: V };
    }
    return Reflect.defineProperty(receiver, P, valueDesc);
  },

  defineProperty(target, P, desc) {
    if (typeof P === \\"symbol\\") {
      return Reflect.defineProperty(target, P, desc);
    }
    if (!utils.hasOwn(target, P)) {
      if (desc.get || desc.set) {
        return false;
      }

      let namedValue = desc.value;

      namedValue = conversions[\\"DOMString\\"](namedValue, {
        context: \\"Failed to set the '\\" + P + \\"' property on 'Storage': The provided value\\"
      });

      target[impl].setItem(P, namedValue);

      return true;
    }
    return Reflect.defineProperty(target, P, desc);
  },

  deleteProperty(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.deleteProperty(target, P);
    }

    if (target[impl][utils.supportsPropertyName](P) && !(P in target)) {
      target[impl].removeItem(P);
      return true;
    }

    return Reflect.deleteProperty(target, P);
  },

  preventExtensions() {
    return false;
  }
};

const Impl = require(\\"../implementations/Storage.js\\");
"
`;

exports[`without processors StringifierAttribute.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"StringifierAttribute\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'StringifierAttribute'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"StringifierAttribute\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor StringifierAttribute is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class StringifierAttribute {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    get attr() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"attr\\"];
    }

    toString() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
      return this[impl][\\"attr\\"];
    }
  }
  Object.defineProperties(StringifierAttribute.prototype, {
    attr: { enumerable: true },
    toString: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"StringifierAttribute\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = StringifierAttribute;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: StringifierAttribute
  });
};

const Impl = require(\\"../implementations/StringifierAttribute.js\\");
"
`;

exports[`without processors StringifierDefaultOperation.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"StringifierDefaultOperation\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'StringifierDefaultOperation'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"StringifierDefaultOperation\\"];
  if (ctor === undefined) {
    throw new Error(
      \\"Internal error: constructor StringifierDefaultOperation is not installed on the passed global object\\"
    );
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class StringifierDefaultOperation {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    toString() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl].toString();
    }
  }
  Object.defineProperties(StringifierDefaultOperation.prototype, {
    toString: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"StringifierDefaultOperation\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = StringifierDefaultOperation;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: StringifierDefaultOperation
  });
};

const Impl = require(\\"../implementations/StringifierDefaultOperation.js\\");
"
`;

exports[`without processors StringifierNamedOperation.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"StringifierNamedOperation\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'StringifierNamedOperation'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"StringifierNamedOperation\\"];
  if (ctor === undefined) {
    throw new Error(
      \\"Internal error: constructor StringifierNamedOperation is not installed on the passed global object\\"
    );
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class StringifierNamedOperation {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    operation() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl].operation();
    }

    toString() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl].operation();
    }
  }
  Object.defineProperties(StringifierNamedOperation.prototype, {
    operation: { enumerable: true },
    toString: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"StringifierNamedOperation\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = StringifierNamedOperation;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: StringifierNamedOperation
  });
};

const Impl = require(\\"../implementations/StringifierNamedOperation.js\\");
"
`;

exports[`without processors StringifierOperation.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"StringifierOperation\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'StringifierOperation'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"StringifierOperation\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor StringifierOperation is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class StringifierOperation {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    toString() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl].toString();
    }
  }
  Object.defineProperties(StringifierOperation.prototype, {
    toString: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"StringifierOperation\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = StringifierOperation;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: StringifierOperation
  });
};

const Impl = require(\\"../implementations/StringifierOperation.js\\");
"
`;

exports[`without processors TypedefsAndUnions.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const convertRequestDestination = require(\\"./RequestDestination.js\\").convert;
const isURL = require(\\"./URL.js\\").is;
const convertURL = require(\\"./URL.js\\").convert;
const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"TypedefsAndUnions\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'TypedefsAndUnions'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"TypedefsAndUnions\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor TypedefsAndUnions is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class TypedefsAndUnions {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    numOrStrConsumer(a) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'numOrStrConsumer' on 'TypedefsAndUnions': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (typeof curArg === \\"number\\") {
          curArg = conversions[\\"double\\"](curArg, {
            context: \\"Failed to execute 'numOrStrConsumer' on 'TypedefsAndUnions': parameter 1\\",
            clamp: true
          });
        } else {
          curArg = conversions[\\"DOMString\\"](curArg, {
            context: \\"Failed to execute 'numOrStrConsumer' on 'TypedefsAndUnions': parameter 1\\"
          });
        }
        args.push(curArg);
      }
      return this[impl].numOrStrConsumer(...args);
    }

    numOrEnumConsumer(a) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'numOrEnumConsumer' on 'TypedefsAndUnions': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg === null || curArg === undefined) {
          curArg = null;
        } else {
          if (typeof curArg === \\"number\\") {
            curArg = conversions[\\"double\\"](curArg, {
              context: \\"Failed to execute 'numOrEnumConsumer' on 'TypedefsAndUnions': parameter 1\\"
            });
          } else {
            curArg = convertRequestDestination(curArg, {
              context: \\"Failed to execute 'numOrEnumConsumer' on 'TypedefsAndUnions': parameter 1\\"
            });
          }
        }
        args.push(curArg);
      }
      return this[impl].numOrEnumConsumer(...args);
    }

    numOrStrOrNullConsumer(a) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'numOrStrOrNullConsumer' on 'TypedefsAndUnions': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg === null || curArg === undefined) {
          curArg = null;
        } else {
          if (typeof curArg === \\"number\\") {
            curArg = conversions[\\"double\\"](curArg, {
              context: \\"Failed to execute 'numOrStrOrNullConsumer' on 'TypedefsAndUnions': parameter 1\\",
              clamp: true,
              enforceRange: true
            });
          } else {
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'numOrStrOrNullConsumer' on 'TypedefsAndUnions': parameter 1\\",
              enforceRange: true
            });
          }
        }
        args.push(curArg);
      }
      return this[impl].numOrStrOrNullConsumer(...args);
    }

    numOrStrOrURLOrNullConsumer(a) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'numOrStrOrURLOrNullConsumer' on 'TypedefsAndUnions': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg === null || curArg === undefined) {
          curArg = null;
        } else {
          if (isURL(curArg)) {
            curArg = utils.implForWrapper(curArg);
          } else if (typeof curArg === \\"number\\") {
            curArg = conversions[\\"double\\"](curArg, {
              context: \\"Failed to execute 'numOrStrOrURLOrNullConsumer' on 'TypedefsAndUnions': parameter 1\\",
              clamp: true,
              enforceRange: true
            });
          } else {
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'numOrStrOrURLOrNullConsumer' on 'TypedefsAndUnions': parameter 1\\",
              enforceRange: true
            });
          }
        }
        args.push(curArg);
      }
      return this[impl].numOrStrOrURLOrNullConsumer(...args);
    }

    urlMapInnerConsumer(a) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'urlMapInnerConsumer' on 'TypedefsAndUnions': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (!utils.isObject(curArg)) {
          throw new TypeError(
            \\"Failed to execute 'urlMapInnerConsumer' on 'TypedefsAndUnions': parameter 1\\" + \\" is not an object.\\"
          );
        } else {
          const result = Object.create(null);
          for (const key of Reflect.ownKeys(curArg)) {
            const desc = Object.getOwnPropertyDescriptor(curArg, key);
            if (desc && desc.enumerable) {
              let typedKey = key;

              typedKey = conversions[\\"USVString\\"](typedKey, {
                context: \\"Failed to execute 'urlMapInnerConsumer' on 'TypedefsAndUnions': parameter 1\\" + \\"'s key\\"
              });

              let typedValue = curArg[key];

              typedValue = convertURL(typedValue, {
                context: \\"Failed to execute 'urlMapInnerConsumer' on 'TypedefsAndUnions': parameter 1\\" + \\"'s value\\"
              });

              result[typedKey] = typedValue;
            }
          }
          curArg = result;
        }
        args.push(curArg);
      }
      return this[impl].urlMapInnerConsumer(...args);
    }

    urlMapConsumer(a) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'urlMapConsumer' on 'TypedefsAndUnions': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg === null || curArg === undefined) {
          curArg = null;
        } else {
          if (!utils.isObject(curArg)) {
            throw new TypeError(
              \\"Failed to execute 'urlMapConsumer' on 'TypedefsAndUnions': parameter 1\\" + \\" is not an object.\\"
            );
          } else {
            const result = Object.create(null);
            for (const key of Reflect.ownKeys(curArg)) {
              const desc = Object.getOwnPropertyDescriptor(curArg, key);
              if (desc && desc.enumerable) {
                let typedKey = key;

                typedKey = conversions[\\"USVString\\"](typedKey, {
                  context: \\"Failed to execute 'urlMapConsumer' on 'TypedefsAndUnions': parameter 1\\" + \\"'s key\\"
                });

                let typedValue = curArg[key];

                typedValue = convertURL(typedValue, {
                  context: \\"Failed to execute 'urlMapConsumer' on 'TypedefsAndUnions': parameter 1\\" + \\"'s value\\"
                });

                result[typedKey] = typedValue;
              }
            }
            curArg = result;
          }
        }
        args.push(curArg);
      }
      return this[impl].urlMapConsumer(...args);
    }

    bufferSourceOrURLConsumer(b) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'bufferSourceOrURLConsumer' on 'TypedefsAndUnions': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (isURL(curArg)) {
          curArg = utils.implForWrapper(curArg);
        } else if (utils.isArrayBuffer(curArg)) {
        } else if (ArrayBuffer.isView(curArg)) {
        } else {
          throw new TypeError(
            \\"Failed to execute 'bufferSourceOrURLConsumer' on 'TypedefsAndUnions': parameter 1\\" +
              \\" is not of any supported type.\\"
          );
        }
        args.push(curArg);
      }
      return this[impl].bufferSourceOrURLConsumer(...args);
    }

    arrayBufferViewOrURLMapConsumer(b) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'arrayBufferViewOrURLMapConsumer' on 'TypedefsAndUnions': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg === null || curArg === undefined) {
          curArg = null;
        } else {
          if (ArrayBuffer.isView(curArg)) {
          } else if (utils.isObject(curArg)) {
            if (!utils.isObject(curArg)) {
              throw new TypeError(
                \\"Failed to execute 'arrayBufferViewOrURLMapConsumer' on 'TypedefsAndUnions': parameter 1\\" +
                  \\" record\\" +
                  \\" is not an object.\\"
              );
            } else {
              const result = Object.create(null);
              for (const key of Reflect.ownKeys(curArg)) {
                const desc = Object.getOwnPropertyDescriptor(curArg, key);
                if (desc && desc.enumerable) {
                  let typedKey = key;

                  typedKey = conversions[\\"USVString\\"](typedKey, {
                    context:
                      \\"Failed to execute 'arrayBufferViewOrURLMapConsumer' on 'TypedefsAndUnions': parameter 1\\" +
                      \\" record\\" +
                      \\"'s key\\"
                  });

                  let typedValue = curArg[key];

                  typedValue = convertURL(typedValue, {
                    context:
                      \\"Failed to execute 'arrayBufferViewOrURLMapConsumer' on 'TypedefsAndUnions': parameter 1\\" +
                      \\" record\\" +
                      \\"'s value\\"
                  });

                  result[typedKey] = typedValue;
                }
              }
              curArg = result;
            }
          } else {
            throw new TypeError(
              \\"Failed to execute 'arrayBufferViewOrURLMapConsumer' on 'TypedefsAndUnions': parameter 1\\" +
                \\" is not of any supported type.\\"
            );
          }
        }
        args.push(curArg);
      }
      return this[impl].arrayBufferViewOrURLMapConsumer(...args);
    }

    arrayBufferViewDupConsumer(b) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'arrayBufferViewDupConsumer' on 'TypedefsAndUnions': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (ArrayBuffer.isView(curArg)) {
        } else {
          throw new TypeError(
            \\"Failed to execute 'arrayBufferViewDupConsumer' on 'TypedefsAndUnions': parameter 1\\" +
              \\" is not of any supported type.\\"
          );
        }
        args.push(curArg);
      }
      return this[impl].arrayBufferViewDupConsumer(...args);
    }

    get buf() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return utils.tryWrapperForImpl(this[impl][\\"buf\\"]);
    }

    set buf(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (utils.isArrayBuffer(V)) {
      } else if (
        ArrayBuffer.isView(V) &&
        (V.constructor.name === \\"Uint8Array\\" || V.constructor.name === \\"Uint16Array\\")
      ) {
      } else {
        throw new TypeError(
          \\"Failed to set the 'buf' property on 'TypedefsAndUnions': The provided value\\" +
            \\" is not of any supported type.\\"
        );
      }
      this[impl][\\"buf\\"] = V;
    }

    get time() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"time\\"];
    }

    set time(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"unsigned long long\\"](V, {
        context: \\"Failed to set the 'time' property on 'TypedefsAndUnions': The provided value\\"
      });

      this[impl][\\"time\\"] = V;
    }
  }
  Object.defineProperties(TypedefsAndUnions.prototype, {
    numOrStrConsumer: { enumerable: true },
    numOrEnumConsumer: { enumerable: true },
    numOrStrOrNullConsumer: { enumerable: true },
    numOrStrOrURLOrNullConsumer: { enumerable: true },
    urlMapInnerConsumer: { enumerable: true },
    urlMapConsumer: { enumerable: true },
    bufferSourceOrURLConsumer: { enumerable: true },
    arrayBufferViewOrURLMapConsumer: { enumerable: true },
    arrayBufferViewDupConsumer: { enumerable: true },
    buf: { enumerable: true },
    time: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"TypedefsAndUnions\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = TypedefsAndUnions;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: TypedefsAndUnions
  });
};

const Impl = require(\\"../implementations/TypedefsAndUnions.js\\");
"
`;

exports[`without processors URL.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"URL\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'URL'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"URL\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor URL is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class URL {
    constructor(url) {
      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to construct 'URL': 1 argument required, but only \\" + arguments.length + \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"USVString\\"](curArg, { context: \\"Failed to construct 'URL': parameter 1\\" });
        args.push(curArg);
      }
      {
        let curArg = arguments[1];
        if (curArg !== undefined) {
          curArg = conversions[\\"USVString\\"](curArg, { context: \\"Failed to construct 'URL': parameter 2\\" });
        }
        args.push(curArg);
      }
      return exports.setup(Object.create(new.target.prototype), globalObject, args);
    }

    toJSON() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl].toJSON();
    }

    get href() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"href\\"];
    }

    set href(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, { context: \\"Failed to set the 'href' property on 'URL': The provided value\\" });

      this[impl][\\"href\\"] = V;
    }

    toString() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
      return this[impl][\\"href\\"];
    }

    get origin() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"origin\\"];
    }

    get protocol() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"protocol\\"];
    }

    set protocol(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, {
        context: \\"Failed to set the 'protocol' property on 'URL': The provided value\\"
      });

      this[impl][\\"protocol\\"] = V;
    }

    get username() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"username\\"];
    }

    set username(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, {
        context: \\"Failed to set the 'username' property on 'URL': The provided value\\"
      });

      this[impl][\\"username\\"] = V;
    }

    get password() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"password\\"];
    }

    set password(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, {
        context: \\"Failed to set the 'password' property on 'URL': The provided value\\"
      });

      this[impl][\\"password\\"] = V;
    }

    get host() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"host\\"];
    }

    set host(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, { context: \\"Failed to set the 'host' property on 'URL': The provided value\\" });

      this[impl][\\"host\\"] = V;
    }

    get hostname() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"hostname\\"];
    }

    set hostname(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, {
        context: \\"Failed to set the 'hostname' property on 'URL': The provided value\\"
      });

      this[impl][\\"hostname\\"] = V;
    }

    get port() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"port\\"];
    }

    set port(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, { context: \\"Failed to set the 'port' property on 'URL': The provided value\\" });

      this[impl][\\"port\\"] = V;
    }

    get pathname() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"pathname\\"];
    }

    set pathname(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, {
        context: \\"Failed to set the 'pathname' property on 'URL': The provided value\\"
      });

      this[impl][\\"pathname\\"] = V;
    }

    get search() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"search\\"];
    }

    set search(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, { context: \\"Failed to set the 'search' property on 'URL': The provided value\\" });

      this[impl][\\"search\\"] = V;
    }

    get searchParams() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return utils.getSameObject(this, \\"searchParams\\", () => {
        return utils.tryWrapperForImpl(this[impl][\\"searchParams\\"]);
      });
    }

    get hash() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"hash\\"];
    }

    set hash(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, { context: \\"Failed to set the 'hash' property on 'URL': The provided value\\" });

      this[impl][\\"hash\\"] = V;
    }
  }
  Object.defineProperties(URL.prototype, {
    toJSON: { enumerable: true },
    href: { enumerable: true },
    toString: { enumerable: true },
    origin: { enumerable: true },
    protocol: { enumerable: true },
    username: { enumerable: true },
    password: { enumerable: true },
    host: { enumerable: true },
    hostname: { enumerable: true },
    port: { enumerable: true },
    pathname: { enumerable: true },
    search: { enumerable: true },
    searchParams: { enumerable: true },
    hash: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"URL\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = URL;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: URL
  });
};

const Impl = require(\\"../implementations/URL.js\\");
"
`;

exports[`without processors URLList.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"URLList\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'URLList'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"URLList\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor URLList is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj = new Proxy(obj, proxyHandler);

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class URLList {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    item(index) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'item' on 'URLList': 1 argument required, but only \\" + arguments.length + \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"unsigned long\\"](curArg, {
          context: \\"Failed to execute 'item' on 'URLList': parameter 1\\"
        });
        args.push(curArg);
      }
      return utils.tryWrapperForImpl(this[impl].item(...args));
    }

    get length() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"length\\"];
    }
  }
  Object.defineProperties(URLList.prototype, {
    item: { enumerable: true },
    length: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"URLList\\", configurable: true },
    [Symbol.iterator]: { value: Array.prototype[Symbol.iterator], configurable: true, writable: true },
    keys: { value: Array.prototype.keys, configurable: true, enumerable: true, writable: true },
    values: { value: Array.prototype[Symbol.iterator], configurable: true, enumerable: true, writable: true },
    entries: { value: Array.prototype.entries, configurable: true, enumerable: true, writable: true },
    forEach: { value: Array.prototype.forEach, configurable: true, enumerable: true, writable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = URLList;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: URLList
  });
};

const proxyHandler = {
  get(target, P, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.get(target, P, receiver);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc === undefined) {
      const parent = Object.getPrototypeOf(target);
      if (parent === null) {
        return undefined;
      }
      return Reflect.get(target, P, receiver);
    }
    if (!desc.get && !desc.set) {
      return desc.value;
    }
    const getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return Reflect.apply(getter, receiver, []);
  },

  has(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.has(target, P);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc !== undefined) {
      return true;
    }
    const parent = Object.getPrototypeOf(target);
    if (parent !== null) {
      return Reflect.has(parent, P);
    }
    return false;
  },

  ownKeys(target) {
    const keys = new Set();

    for (const key of target[impl][utils.supportedPropertyIndices]) {
      keys.add(\`\${key}\`);
    }

    for (const key of Reflect.ownKeys(target)) {
      keys.add(key);
    }
    return [...keys];
  },

  getOwnPropertyDescriptor(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.getOwnPropertyDescriptor(target, P);
    }
    let ignoreNamedProps = false;

    if (utils.isArrayIndexPropName(P)) {
      const index = P >>> 0;

      if (target[impl][utils.supportsPropertyIndex](index)) {
        const indexedValue = target[impl].item(index);
        return {
          writable: false,
          enumerable: true,
          configurable: true,
          value: utils.tryWrapperForImpl(indexedValue)
        };
      }
      ignoreNamedProps = true;
    }

    return Reflect.getOwnPropertyDescriptor(target, P);
  },

  set(target, P, V, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.set(target, P, V, receiver);
    }
    if (target === receiver) {
      utils.isArrayIndexPropName(P);
    }
    let ownDesc;

    if (utils.isArrayIndexPropName(P)) {
      const index = P >>> 0;

      if (target[impl][utils.supportsPropertyIndex](index)) {
        const indexedValue = target[impl].item(index);
        ownDesc = {
          writable: false,
          enumerable: true,
          configurable: true,
          value: utils.tryWrapperForImpl(indexedValue)
        };
      }
    }

    if (ownDesc === undefined) {
      ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
    }
    if (ownDesc === undefined) {
      const parent = Reflect.getPrototypeOf(target);
      if (parent !== null) {
        return Reflect.set(parent, P, V, receiver);
      }
      ownDesc = { writable: true, enumerable: true, configurable: true, value: undefined };
    }
    if (!ownDesc.writable) {
      return false;
    }
    if (!utils.isObject(receiver)) {
      return false;
    }
    const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
    let valueDesc;
    if (existingDesc !== undefined) {
      if (existingDesc.get || existingDesc.set) {
        return false;
      }
      if (!existingDesc.writable) {
        return false;
      }
      valueDesc = { value: V };
    } else {
      valueDesc = { writable: true, enumerable: true, configurable: true, value: V };
    }
    return Reflect.defineProperty(receiver, P, valueDesc);
  },

  defineProperty(target, P, desc) {
    if (typeof P === \\"symbol\\") {
      return Reflect.defineProperty(target, P, desc);
    }

    if (utils.isArrayIndexPropName(P)) {
      return false;
    }

    return Reflect.defineProperty(target, P, desc);
  },

  deleteProperty(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.deleteProperty(target, P);
    }

    if (utils.isArrayIndexPropName(P)) {
      const index = P >>> 0;
      return !target[impl][utils.supportsPropertyIndex](index);
    }

    return Reflect.deleteProperty(target, P);
  },

  preventExtensions() {
    return false;
  }
};

const Impl = require(\\"../implementations/URLList.js\\");
"
`;

exports[`without processors URLSearchParams.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"URLSearchParams\\";

const IteratorPrototype = Object.create(utils.IteratorPrototype, {
  next: {
    value: function next() {
      const internal = this[utils.iterInternalSymbol];
      const { target, kind, index } = internal;
      const values = Array.from(target[impl]);
      const len = values.length;
      if (index >= len) {
        return { value: undefined, done: true };
      }

      const pair = values[index];
      internal.index = index + 1;
      const [key, value] = pair.map(utils.tryWrapperForImpl);

      let result;
      switch (kind) {
        case \\"key\\":
          result = key;
          break;
        case \\"value\\":
          result = value;
          break;
        case \\"key+value\\":
          result = [key, value];
          break;
      }
      return { value: result, done: false };
    },
    writable: true,
    enumerable: true,
    configurable: true
  },
  [Symbol.toStringTag]: {
    value: \\"URLSearchParams Iterator\\",
    configurable: true
  }
});

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'URLSearchParams'.\`);
};

exports.createDefaultIterator = function createDefaultIterator(target, kind) {
  const iterator = Object.create(IteratorPrototype);
  Object.defineProperty(iterator, utils.iterInternalSymbol, {
    value: { target, kind, index: 0 },
    configurable: true
  });
  return iterator;
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"URLSearchParams\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor URLSearchParams is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class URLSearchParams {
    constructor() {
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg !== undefined) {
          if (utils.isObject(curArg)) {
            if (curArg[Symbol.iterator] !== undefined) {
              if (!utils.isObject(curArg)) {
                throw new TypeError(
                  \\"Failed to construct 'URLSearchParams': parameter 1\\" + \\" sequence\\" + \\" is not an iterable object.\\"
                );
              } else {
                const V = [];
                const tmp = curArg;
                for (let nextItem of tmp) {
                  if (!utils.isObject(nextItem)) {
                    throw new TypeError(
                      \\"Failed to construct 'URLSearchParams': parameter 1\\" +
                        \\" sequence\\" +
                        \\"'s element\\" +
                        \\" is not an iterable object.\\"
                    );
                  } else {
                    const V = [];
                    const tmp = nextItem;
                    for (let nextItem of tmp) {
                      nextItem = conversions[\\"USVString\\"](nextItem, {
                        context:
                          \\"Failed to construct 'URLSearchParams': parameter 1\\" +
                          \\" sequence\\" +
                          \\"'s element\\" +
                          \\"'s element\\"
                      });

                      V.push(nextItem);
                    }
                    nextItem = V;
                  }

                  V.push(nextItem);
                }
                curArg = V;
              }
            } else {
              if (!utils.isObject(curArg)) {
                throw new TypeError(
                  \\"Failed to construct 'URLSearchParams': parameter 1\\" + \\" record\\" + \\" is not an object.\\"
                );
              } else {
                const result = Object.create(null);
                for (const key of Reflect.ownKeys(curArg)) {
                  const desc = Object.getOwnPropertyDescriptor(curArg, key);
                  if (desc && desc.enumerable) {
                    let typedKey = key;

                    typedKey = conversions[\\"USVString\\"](typedKey, {
                      context: \\"Failed to construct 'URLSearchParams': parameter 1\\" + \\" record\\" + \\"'s key\\"
                    });

                    let typedValue = curArg[key];

                    typedValue = conversions[\\"USVString\\"](typedValue, {
                      context: \\"Failed to construct 'URLSearchParams': parameter 1\\" + \\" record\\" + \\"'s value\\"
                    });

                    result[typedKey] = typedValue;
                  }
                }
                curArg = result;
              }
            }
          } else {
            curArg = conversions[\\"USVString\\"](curArg, {
              context: \\"Failed to construct 'URLSearchParams': parameter 1\\"
            });
          }
        } else {
          curArg = \\"\\";
        }
        args.push(curArg);
      }
      return exports.setup(Object.create(new.target.prototype), globalObject, args);
    }

    append(name, value) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 2) {
        throw new TypeError(
          \\"Failed to execute 'append' on 'URLSearchParams': 2 arguments required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"USVString\\"](curArg, {
          context: \\"Failed to execute 'append' on 'URLSearchParams': parameter 1\\"
        });
        args.push(curArg);
      }
      {
        let curArg = arguments[1];
        curArg = conversions[\\"USVString\\"](curArg, {
          context: \\"Failed to execute 'append' on 'URLSearchParams': parameter 2\\"
        });
        args.push(curArg);
      }
      return this[impl].append(...args);
    }

    delete(name) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'delete' on 'URLSearchParams': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"USVString\\"](curArg, {
          context: \\"Failed to execute 'delete' on 'URLSearchParams': parameter 1\\"
        });
        args.push(curArg);
      }
      return this[impl].delete(...args);
    }

    get(name) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'get' on 'URLSearchParams': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"USVString\\"](curArg, {
          context: \\"Failed to execute 'get' on 'URLSearchParams': parameter 1\\"
        });
        args.push(curArg);
      }
      return this[impl].get(...args);
    }

    getAll(name) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'getAll' on 'URLSearchParams': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"USVString\\"](curArg, {
          context: \\"Failed to execute 'getAll' on 'URLSearchParams': parameter 1\\"
        });
        args.push(curArg);
      }
      return utils.tryWrapperForImpl(this[impl].getAll(...args));
    }

    has(name) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'has' on 'URLSearchParams': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"USVString\\"](curArg, {
          context: \\"Failed to execute 'has' on 'URLSearchParams': parameter 1\\"
        });
        args.push(curArg);
      }
      return this[impl].has(...args);
    }

    set(name, value) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 2) {
        throw new TypeError(
          \\"Failed to execute 'set' on 'URLSearchParams': 2 arguments required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"USVString\\"](curArg, {
          context: \\"Failed to execute 'set' on 'URLSearchParams': parameter 1\\"
        });
        args.push(curArg);
      }
      {
        let curArg = arguments[1];
        curArg = conversions[\\"USVString\\"](curArg, {
          context: \\"Failed to execute 'set' on 'URLSearchParams': parameter 2\\"
        });
        args.push(curArg);
      }
      return this[impl].set(...args);
    }

    sort() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl].sort();
    }

    toString() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl].toString();
    }

    keys() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
      return exports.createDefaultIterator(this, \\"key\\");
    }

    values() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
      return exports.createDefaultIterator(this, \\"value\\");
    }

    entries() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
      return exports.createDefaultIterator(this, \\"key+value\\");
    }

    forEach(callback) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
      if (arguments.length < 1) {
        throw new TypeError(\\"Failed to execute 'forEach' on 'iterable': 1 argument required, \\" + \\"but only 0 present.\\");
      }
      if (typeof callback !== \\"function\\") {
        throw new TypeError(
          \\"Failed to execute 'forEach' on 'iterable': The callback provided \\" + \\"as parameter 1 is not a function.\\"
        );
      }
      const thisArg = arguments[1];
      let pairs = Array.from(this[impl]);
      let i = 0;
      while (i < pairs.length) {
        const [key, value] = pairs[i].map(utils.tryWrapperForImpl);
        callback.call(thisArg, value, key, this);
        pairs = Array.from(this[impl]);
        i++;
      }
    }
  }
  Object.defineProperties(URLSearchParams.prototype, {
    append: { enumerable: true },
    delete: { enumerable: true },
    get: { enumerable: true },
    getAll: { enumerable: true },
    has: { enumerable: true },
    set: { enumerable: true },
    sort: { enumerable: true },
    toString: { enumerable: true },
    keys: { enumerable: true },
    values: { enumerable: true },
    entries: { enumerable: true },
    forEach: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"URLSearchParams\\", configurable: true },
    [Symbol.iterator]: { value: URLSearchParams.prototype.entries, configurable: true, writable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = URLSearchParams;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: URLSearchParams
  });
};

const Impl = require(\\"../implementations/URLSearchParams.js\\");
"
`;

exports[`without processors URLSearchParamsCollection.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"URLSearchParamsCollection\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'URLSearchParamsCollection'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"URLSearchParamsCollection\\"];
  if (ctor === undefined) {
    throw new Error(
      \\"Internal error: constructor URLSearchParamsCollection is not installed on the passed global object\\"
    );
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj = new Proxy(obj, proxyHandler);

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class URLSearchParamsCollection {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    item(index) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'item' on 'URLSearchParamsCollection': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"unsigned long\\"](curArg, {
          context: \\"Failed to execute 'item' on 'URLSearchParamsCollection': parameter 1\\"
        });
        args.push(curArg);
      }
      return utils.tryWrapperForImpl(this[impl].item(...args));
    }

    namedItem(name) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'namedItem' on 'URLSearchParamsCollection': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'namedItem' on 'URLSearchParamsCollection': parameter 1\\"
        });
        args.push(curArg);
      }
      return utils.tryWrapperForImpl(this[impl].namedItem(...args));
    }

    get length() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"length\\"];
    }
  }
  Object.defineProperties(URLSearchParamsCollection.prototype, {
    item: { enumerable: true },
    namedItem: { enumerable: true },
    length: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"URLSearchParamsCollection\\", configurable: true },
    [Symbol.iterator]: { value: Array.prototype[Symbol.iterator], configurable: true, writable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = URLSearchParamsCollection;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: URLSearchParamsCollection
  });
};

const proxyHandler = {
  get(target, P, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.get(target, P, receiver);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc === undefined) {
      const parent = Object.getPrototypeOf(target);
      if (parent === null) {
        return undefined;
      }
      return Reflect.get(target, P, receiver);
    }
    if (!desc.get && !desc.set) {
      return desc.value;
    }
    const getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return Reflect.apply(getter, receiver, []);
  },

  has(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.has(target, P);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc !== undefined) {
      return true;
    }
    const parent = Object.getPrototypeOf(target);
    if (parent !== null) {
      return Reflect.has(parent, P);
    }
    return false;
  },

  ownKeys(target) {
    const keys = new Set();

    for (const key of target[impl][utils.supportedPropertyIndices]) {
      keys.add(\`\${key}\`);
    }

    for (const key of target[impl][utils.supportedPropertyNames]) {
      if (!(key in target)) {
        keys.add(\`\${key}\`);
      }
    }

    for (const key of Reflect.ownKeys(target)) {
      keys.add(key);
    }
    return [...keys];
  },

  getOwnPropertyDescriptor(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.getOwnPropertyDescriptor(target, P);
    }
    let ignoreNamedProps = false;

    if (utils.isArrayIndexPropName(P)) {
      const index = P >>> 0;
      const indexedValue = target[impl].item(index);
      if (indexedValue !== undefined) {
        return {
          writable: false,
          enumerable: true,
          configurable: true,
          value: utils.tryWrapperForImpl(indexedValue)
        };
      }
      ignoreNamedProps = true;
    }

    const namedValue = target[impl].namedItem(P);

    if (namedValue !== null && !(P in target) && !ignoreNamedProps) {
      return {
        writable: false,
        enumerable: false,
        configurable: true,
        value: utils.tryWrapperForImpl(namedValue)
      };
    }

    return Reflect.getOwnPropertyDescriptor(target, P);
  },

  set(target, P, V, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.set(target, P, V, receiver);
    }
    if (target === receiver) {
      utils.isArrayIndexPropName(P);

      typeof P === \\"string\\" && !utils.isArrayIndexPropName(P);
    }
    let ownDesc;

    if (utils.isArrayIndexPropName(P)) {
      const index = P >>> 0;
      const indexedValue = target[impl].item(index);
      if (indexedValue !== undefined) {
        ownDesc = {
          writable: false,
          enumerable: true,
          configurable: true,
          value: utils.tryWrapperForImpl(indexedValue)
        };
      }
    }

    if (ownDesc === undefined) {
      ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
    }
    if (ownDesc === undefined) {
      const parent = Reflect.getPrototypeOf(target);
      if (parent !== null) {
        return Reflect.set(parent, P, V, receiver);
      }
      ownDesc = { writable: true, enumerable: true, configurable: true, value: undefined };
    }
    if (!ownDesc.writable) {
      return false;
    }
    if (!utils.isObject(receiver)) {
      return false;
    }
    const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
    let valueDesc;
    if (existingDesc !== undefined) {
      if (existingDesc.get || existingDesc.set) {
        return false;
      }
      if (!existingDesc.writable) {
        return false;
      }
      valueDesc = { value: V };
    } else {
      valueDesc = { writable: true, enumerable: true, configurable: true, value: V };
    }
    return Reflect.defineProperty(receiver, P, valueDesc);
  },

  defineProperty(target, P, desc) {
    if (typeof P === \\"symbol\\") {
      return Reflect.defineProperty(target, P, desc);
    }

    if (utils.isArrayIndexPropName(P)) {
      return false;
    }
    if (!utils.hasOwn(target, P)) {
      const creating = !(target[impl].namedItem(P) !== null);
      if (!creating) {
        return false;
      }
    }
    return Reflect.defineProperty(target, P, desc);
  },

  deleteProperty(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.deleteProperty(target, P);
    }

    if (utils.isArrayIndexPropName(P)) {
      const index = P >>> 0;
      return !(target[impl].item(index) !== undefined);
    }

    if (target[impl].namedItem(P) !== null && !(P in target)) {
      return false;
    }

    return Reflect.deleteProperty(target, P);
  },

  preventExtensions() {
    return false;
  }
};

const Impl = require(\\"../implementations/URLSearchParamsCollection.js\\");
"
`;

exports[`without processors URLSearchParamsCollection2.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const convertURL = require(\\"./URL.js\\").convert;
const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;
const URLSearchParamsCollection = require(\\"./URLSearchParamsCollection.js\\");

const interfaceName = \\"URLSearchParamsCollection2\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'URLSearchParamsCollection2'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"URLSearchParamsCollection2\\"];
  if (ctor === undefined) {
    throw new Error(
      \\"Internal error: constructor URLSearchParamsCollection2 is not installed on the passed global object\\"
    );
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {
  URLSearchParamsCollection._internalSetup(obj);
};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj = new Proxy(obj, proxyHandler);

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  if (globalObject.URLSearchParamsCollection === undefined) {
    throw new Error(
      \\"Internal error: attempting to evaluate URLSearchParamsCollection2 before URLSearchParamsCollection\\"
    );
  }
  class URLSearchParamsCollection2 extends globalObject.URLSearchParamsCollection {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }
  }
  Object.defineProperties(URLSearchParamsCollection2.prototype, {
    [Symbol.toStringTag]: { value: \\"URLSearchParamsCollection2\\", configurable: true },
    [Symbol.iterator]: { value: Array.prototype[Symbol.iterator], configurable: true, writable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = URLSearchParamsCollection2;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: URLSearchParamsCollection2
  });
};

const proxyHandler = {
  get(target, P, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.get(target, P, receiver);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc === undefined) {
      const parent = Object.getPrototypeOf(target);
      if (parent === null) {
        return undefined;
      }
      return Reflect.get(target, P, receiver);
    }
    if (!desc.get && !desc.set) {
      return desc.value;
    }
    const getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return Reflect.apply(getter, receiver, []);
  },

  has(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.has(target, P);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc !== undefined) {
      return true;
    }
    const parent = Object.getPrototypeOf(target);
    if (parent !== null) {
      return Reflect.has(parent, P);
    }
    return false;
  },

  ownKeys(target) {
    const keys = new Set();

    for (const key of target[impl][utils.supportedPropertyIndices]) {
      keys.add(\`\${key}\`);
    }

    for (const key of target[impl][utils.supportedPropertyNames]) {
      if (!(key in target)) {
        keys.add(\`\${key}\`);
      }
    }

    for (const key of Reflect.ownKeys(target)) {
      keys.add(key);
    }
    return [...keys];
  },

  getOwnPropertyDescriptor(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.getOwnPropertyDescriptor(target, P);
    }
    let ignoreNamedProps = false;

    if (utils.isArrayIndexPropName(P)) {
      const index = P >>> 0;
      const indexedValue = target[impl].item(index);
      if (indexedValue !== undefined) {
        return {
          writable: false,
          enumerable: true,
          configurable: true,
          value: utils.tryWrapperForImpl(indexedValue)
        };
      }
      ignoreNamedProps = true;
    }

    const namedValue = target[impl].namedItem(P);

    if (namedValue !== null && !(P in target) && !ignoreNamedProps) {
      return {
        writable: true,
        enumerable: true,
        configurable: true,
        value: utils.tryWrapperForImpl(namedValue)
      };
    }

    return Reflect.getOwnPropertyDescriptor(target, P);
  },

  set(target, P, V, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.set(target, P, V, receiver);
    }
    if (target === receiver) {
      utils.isArrayIndexPropName(P);

      if (typeof P === \\"string\\" && !utils.isArrayIndexPropName(P)) {
        let namedValue = V;

        namedValue = convertURL(namedValue, {
          context: \\"Failed to set the '\\" + P + \\"' property on 'URLSearchParamsCollection2': The provided value\\"
        });

        const creating = !(target[impl].namedItem(P) !== null);
        if (creating) {
          target[impl][utils.namedSetNew](P, namedValue);
        } else {
          target[impl][utils.namedSetExisting](P, namedValue);
        }

        return true;
      }
    }
    let ownDesc;

    if (utils.isArrayIndexPropName(P)) {
      const index = P >>> 0;
      const indexedValue = target[impl].item(index);
      if (indexedValue !== undefined) {
        ownDesc = {
          writable: false,
          enumerable: true,
          configurable: true,
          value: utils.tryWrapperForImpl(indexedValue)
        };
      }
    }

    if (ownDesc === undefined) {
      ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
    }
    if (ownDesc === undefined) {
      const parent = Reflect.getPrototypeOf(target);
      if (parent !== null) {
        return Reflect.set(parent, P, V, receiver);
      }
      ownDesc = { writable: true, enumerable: true, configurable: true, value: undefined };
    }
    if (!ownDesc.writable) {
      return false;
    }
    if (!utils.isObject(receiver)) {
      return false;
    }
    const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
    let valueDesc;
    if (existingDesc !== undefined) {
      if (existingDesc.get || existingDesc.set) {
        return false;
      }
      if (!existingDesc.writable) {
        return false;
      }
      valueDesc = { value: V };
    } else {
      valueDesc = { writable: true, enumerable: true, configurable: true, value: V };
    }
    return Reflect.defineProperty(receiver, P, valueDesc);
  },

  defineProperty(target, P, desc) {
    if (typeof P === \\"symbol\\") {
      return Reflect.defineProperty(target, P, desc);
    }

    if (utils.isArrayIndexPropName(P)) {
      return false;
    }
    if (!utils.hasOwn(target, P)) {
      if (desc.get || desc.set) {
        return false;
      }

      let namedValue = desc.value;

      namedValue = convertURL(namedValue, {
        context: \\"Failed to set the '\\" + P + \\"' property on 'URLSearchParamsCollection2': The provided value\\"
      });

      const creating = !(target[impl].namedItem(P) !== null);
      if (creating) {
        target[impl][utils.namedSetNew](P, namedValue);
      } else {
        target[impl][utils.namedSetExisting](P, namedValue);
      }

      return true;
    }
    return Reflect.defineProperty(target, P, desc);
  },

  deleteProperty(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.deleteProperty(target, P);
    }

    if (utils.isArrayIndexPropName(P)) {
      const index = P >>> 0;
      return !(target[impl].item(index) !== undefined);
    }

    if (target[impl].namedItem(P) !== null && !(P in target)) {
      return false;
    }

    return Reflect.deleteProperty(target, P);
  },

  preventExtensions() {
    return false;
  }
};

const Impl = require(\\"../implementations/URLSearchParamsCollection2.js\\");
"
`;

exports[`without processors UnderscoredProperties.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"UnderscoredProperties\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'UnderscoredProperties'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"UnderscoredProperties\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor UnderscoredProperties is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class UnderscoredProperties {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    operation(sequence) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'operation' on 'UnderscoredProperties': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (!utils.isObject(curArg)) {
          throw new TypeError(
            \\"Failed to execute 'operation' on 'UnderscoredProperties': parameter 1\\" + \\" is not an iterable object.\\"
          );
        } else {
          const V = [];
          const tmp = curArg;
          for (let nextItem of tmp) {
            nextItem = conversions[\\"DOMString\\"](nextItem, {
              context: \\"Failed to execute 'operation' on 'UnderscoredProperties': parameter 1\\" + \\"'s element\\"
            });

            V.push(nextItem);
          }
          curArg = V;
        }
        args.push(curArg);
      }
      return this[impl].operation(...args);
    }

    get attribute() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"attribute\\"];
    }

    set attribute(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"byte\\"](V, {
        context: \\"Failed to set the 'attribute' property on 'UnderscoredProperties': The provided value\\"
      });

      this[impl][\\"attribute\\"] = V;
    }

    static static(void_) {
      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'static' on 'UnderscoredProperties': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'static' on 'UnderscoredProperties': parameter 1\\"
        });
        args.push(curArg);
      }
      return Impl.implementation.static(...args);
    }
  }
  Object.defineProperties(UnderscoredProperties.prototype, {
    operation: { enumerable: true },
    attribute: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"UnderscoredProperties\\", configurable: true },
    const: { value: 42, enumerable: true }
  });
  Object.defineProperties(UnderscoredProperties, {
    static: { enumerable: true },
    const: { value: 42, enumerable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = UnderscoredProperties;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: UnderscoredProperties
  });
};

const Impl = require(\\"../implementations/UnderscoredProperties.js\\");
"
`;

exports[`without processors Unforgeable.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"Unforgeable\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'Unforgeable'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"Unforgeable\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor Unforgeable is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {
  Object.defineProperties(
    obj,
    Object.getOwnPropertyDescriptors({
      assign(url) {
        if (!this || !exports.is(this)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        if (arguments.length < 1) {
          throw new TypeError(
            \\"Failed to execute 'assign' on 'Unforgeable': 1 argument required, but only \\" +
              arguments.length +
              \\" present.\\"
          );
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions[\\"USVString\\"](curArg, {
            context: \\"Failed to execute 'assign' on 'Unforgeable': parameter 1\\"
          });
          args.push(curArg);
        }
        return this[impl].assign(...args);
      },
      get href() {
        if (!this || !exports.is(this)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return obj[impl][\\"href\\"];
      },
      set href(V) {
        if (!this || !exports.is(this)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        V = conversions[\\"USVString\\"](V, {
          context: \\"Failed to set the 'href' property on 'Unforgeable': The provided value\\"
        });

        obj[impl][\\"href\\"] = V;
      },
      toString() {
        if (!this || !exports.is(this)) {
          throw new TypeError(\\"Illegal invocation\\");
        }
        return obj[impl][\\"href\\"];
      },
      get origin() {
        if (!this || !exports.is(this)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return obj[impl][\\"origin\\"];
      },
      get protocol() {
        if (!this || !exports.is(this)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return obj[impl][\\"protocol\\"];
      },
      set protocol(V) {
        if (!this || !exports.is(this)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        V = conversions[\\"USVString\\"](V, {
          context: \\"Failed to set the 'protocol' property on 'Unforgeable': The provided value\\"
        });

        obj[impl][\\"protocol\\"] = V;
      }
    })
  );

  Object.defineProperties(obj, {
    assign: { configurable: false, writable: false },
    href: { configurable: false },
    toString: { configurable: false, writable: false },
    origin: { configurable: false },
    protocol: { configurable: false }
  });
};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class Unforgeable {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }
  }
  Object.defineProperties(Unforgeable.prototype, {
    [Symbol.toStringTag]: { value: \\"Unforgeable\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = Unforgeable;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: Unforgeable
  });
};

const Impl = require(\\"../implementations/Unforgeable.js\\");
"
`;

exports[`without processors UnforgeableMap.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"UnforgeableMap\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'UnforgeableMap'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"UnforgeableMap\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor UnforgeableMap is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {
  Object.defineProperties(
    obj,
    Object.getOwnPropertyDescriptors({
      get a() {
        if (!this || !exports.is(this)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return obj[impl][\\"a\\"];
      }
    })
  );

  Object.defineProperties(obj, { a: { configurable: false } });
};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj = new Proxy(obj, proxyHandler);

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class UnforgeableMap {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }
  }
  Object.defineProperties(UnforgeableMap.prototype, {
    [Symbol.toStringTag]: { value: \\"UnforgeableMap\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = UnforgeableMap;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: UnforgeableMap
  });
};

const proxyHandler = {
  get(target, P, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.get(target, P, receiver);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc === undefined) {
      const parent = Object.getPrototypeOf(target);
      if (parent === null) {
        return undefined;
      }
      return Reflect.get(target, P, receiver);
    }
    if (!desc.get && !desc.set) {
      return desc.value;
    }
    const getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return Reflect.apply(getter, receiver, []);
  },

  has(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.has(target, P);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc !== undefined) {
      return true;
    }
    const parent = Object.getPrototypeOf(target);
    if (parent !== null) {
      return Reflect.has(parent, P);
    }
    return false;
  },

  ownKeys(target) {
    const keys = new Set();

    for (const key of target[impl][utils.supportedPropertyNames]) {
      if (!(key in target)) {
        keys.add(\`\${key}\`);
      }
    }

    for (const key of Reflect.ownKeys(target)) {
      keys.add(key);
    }
    return [...keys];
  },

  getOwnPropertyDescriptor(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.getOwnPropertyDescriptor(target, P);
    }
    let ignoreNamedProps = false;

    if (target[impl][utils.supportsPropertyName](P) && !(P in target) && !ignoreNamedProps) {
      const namedValue = target[impl][utils.namedGet](P);

      return {
        writable: true,
        enumerable: true,
        configurable: true,
        value: utils.tryWrapperForImpl(namedValue)
      };
    }

    return Reflect.getOwnPropertyDescriptor(target, P);
  },

  set(target, P, V, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.set(target, P, V, receiver);
    }
    if (target === receiver) {
      if (typeof P === \\"string\\" && !utils.isArrayIndexPropName(P)) {
        let namedValue = V;

        namedValue = conversions[\\"DOMString\\"](namedValue, {
          context: \\"Failed to set the '\\" + P + \\"' property on 'UnforgeableMap': The provided value\\"
        });

        const creating = !target[impl][utils.supportsPropertyName](P);
        if (creating) {
          target[impl][utils.namedSetNew](P, namedValue);
        } else {
          target[impl][utils.namedSetExisting](P, namedValue);
        }

        return true;
      }
    }
    let ownDesc;

    if (ownDesc === undefined) {
      ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
    }
    if (ownDesc === undefined) {
      const parent = Reflect.getPrototypeOf(target);
      if (parent !== null) {
        return Reflect.set(parent, P, V, receiver);
      }
      ownDesc = { writable: true, enumerable: true, configurable: true, value: undefined };
    }
    if (!ownDesc.writable) {
      return false;
    }
    if (!utils.isObject(receiver)) {
      return false;
    }
    const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
    let valueDesc;
    if (existingDesc !== undefined) {
      if (existingDesc.get || existingDesc.set) {
        return false;
      }
      if (!existingDesc.writable) {
        return false;
      }
      valueDesc = { value: V };
    } else {
      valueDesc = { writable: true, enumerable: true, configurable: true, value: V };
    }
    return Reflect.defineProperty(receiver, P, valueDesc);
  },

  defineProperty(target, P, desc) {
    if (typeof P === \\"symbol\\") {
      return Reflect.defineProperty(target, P, desc);
    }
    if (![\\"a\\"].includes(P)) {
      if (!utils.hasOwn(target, P)) {
        if (desc.get || desc.set) {
          return false;
        }

        let namedValue = desc.value;

        namedValue = conversions[\\"DOMString\\"](namedValue, {
          context: \\"Failed to set the '\\" + P + \\"' property on 'UnforgeableMap': The provided value\\"
        });

        const creating = !target[impl][utils.supportsPropertyName](P);
        if (creating) {
          target[impl][utils.namedSetNew](P, namedValue);
        } else {
          target[impl][utils.namedSetExisting](P, namedValue);
        }

        return true;
      }
    }
    return Reflect.defineProperty(target, P, desc);
  },

  deleteProperty(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.deleteProperty(target, P);
    }

    if (target[impl][utils.supportsPropertyName](P) && !(P in target)) {
      return false;
    }

    return Reflect.deleteProperty(target, P);
  },

  preventExtensions() {
    return false;
  }
};

const Impl = require(\\"../implementations/UnforgeableMap.js\\");
"
`;

exports[`without processors Unscopable.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"Unscopable\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'Unscopable'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"Unscopable\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor Unscopable is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class Unscopable {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    get unscopableTest() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"unscopableTest\\"];
    }

    set unscopableTest(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"boolean\\"](V, {
        context: \\"Failed to set the 'unscopableTest' property on 'Unscopable': The provided value\\"
      });

      this[impl][\\"unscopableTest\\"] = V;
    }

    get unscopableMixin() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return this[impl][\\"unscopableMixin\\"];
    }

    set unscopableMixin(V) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"boolean\\"](V, {
        context: \\"Failed to set the 'unscopableMixin' property on 'Unscopable': The provided value\\"
      });

      this[impl][\\"unscopableMixin\\"] = V;
    }
  }
  Object.defineProperties(Unscopable.prototype, {
    unscopableTest: { enumerable: true },
    unscopableMixin: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"Unscopable\\", configurable: true },
    [Symbol.unscopables]: {
      value: { unscopableTest: true, unscopableMixin: true, __proto__: null },
      configurable: true
    }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = Unscopable;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: Unscopable
  });
};

const Impl = require(\\"../implementations/Unscopable.js\\");
"
`;

exports[`without processors Variadic.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const convertURL = require(\\"./URL.js\\").convert;
const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"Variadic\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'Variadic'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"Variadic\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor Variadic is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class Variadic {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    simple1() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
      const args = [];
      for (let i = 0; i < arguments.length; i++) {
        let curArg = arguments[i];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'simple1' on 'Variadic': parameter \\" + (i + 1)
        });
        args.push(curArg);
      }
      return this[impl].simple1(...args);
    }

    simple2(first) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'simple2' on 'Variadic': 1 argument required, but only \\" + arguments.length + \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'simple2' on 'Variadic': parameter 1\\"
        });
        args.push(curArg);
      }
      for (let i = 1; i < arguments.length; i++) {
        let curArg = arguments[i];
        curArg = convertURL(curArg, { context: \\"Failed to execute 'simple2' on 'Variadic': parameter \\" + (i + 1) });
        args.push(curArg);
      }
      return this[impl].simple2(...args);
    }

    overloaded1() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
      const args = [];
      switch (arguments.length) {
        case 0:
          break;
        default: {
          let curArg = arguments[0];
          if (typeof curArg === \\"number\\") {
            for (let i = 0; i < arguments.length; i++) {
              let curArg = arguments[i];
              curArg = conversions[\\"unsigned long\\"](curArg, {
                context: \\"Failed to execute 'overloaded1' on 'Variadic': parameter \\" + (i + 1)
              });
              args.push(curArg);
            }
          } else {
            for (let i = 0; i < arguments.length; i++) {
              let curArg = arguments[i];
              curArg = conversions[\\"DOMString\\"](curArg, {
                context: \\"Failed to execute 'overloaded1' on 'Variadic': parameter \\" + (i + 1)
              });
              args.push(curArg);
            }
          }
        }
      }
      return this[impl].overloaded1(...args);
    }

    overloaded2(first) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'overloaded2' on 'Variadic': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      switch (arguments.length) {
        case 1:
          {
            let curArg = arguments[0];
            if (typeof curArg === \\"number\\") {
              {
                let curArg = arguments[0];
                curArg = conversions[\\"unsigned long\\"](curArg, {
                  context: \\"Failed to execute 'overloaded2' on 'Variadic': parameter 1\\"
                });
                args.push(curArg);
              }
            } else {
              {
                let curArg = arguments[0];
                curArg = conversions[\\"DOMString\\"](curArg, {
                  context: \\"Failed to execute 'overloaded2' on 'Variadic': parameter 1\\"
                });
                args.push(curArg);
              }
            }
          }
          break;
        default: {
          let curArg = arguments[0];
          if (typeof curArg === \\"number\\") {
            {
              let curArg = arguments[0];
              curArg = conversions[\\"unsigned long\\"](curArg, {
                context: \\"Failed to execute 'overloaded2' on 'Variadic': parameter 1\\"
              });
              args.push(curArg);
            }
            for (let i = 1; i < arguments.length; i++) {
              let curArg = arguments[i];
              curArg = conversions[\\"DOMString\\"](curArg, {
                context: \\"Failed to execute 'overloaded2' on 'Variadic': parameter \\" + (i + 1)
              });
              args.push(curArg);
            }
          } else {
            {
              let curArg = arguments[0];
              curArg = conversions[\\"DOMString\\"](curArg, {
                context: \\"Failed to execute 'overloaded2' on 'Variadic': parameter 1\\"
              });
              args.push(curArg);
            }
            for (let i = 1; i < arguments.length; i++) {
              let curArg = arguments[i];
              curArg = conversions[\\"DOMString\\"](curArg, {
                context: \\"Failed to execute 'overloaded2' on 'Variadic': parameter \\" + (i + 1)
              });
              args.push(curArg);
            }
          }
        }
      }
      return this[impl].overloaded2(...args);
    }
  }
  Object.defineProperties(Variadic.prototype, {
    simple1: { enumerable: true },
    simple2: { enumerable: true },
    overloaded1: { enumerable: true },
    overloaded2: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"Variadic\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = Variadic;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: Variadic
  });
};

const Impl = require(\\"../implementations/Variadic.js\\");
"
`;

exports[`without processors ZeroArgConstructor.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const impl = utils.implSymbol;
const ctorRegistry = utils.ctorRegistrySymbol;

const interfaceName = \\"ZeroArgConstructor\\";

exports.is = function is(obj) {
  return utils.isObject(obj) && utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation;
};
exports.isImpl = function isImpl(obj) {
  return utils.isObject(obj) && obj instanceof Impl.implementation;
};
exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (exports.is(obj)) {
    return utils.implForWrapper(obj);
  }
  throw new TypeError(\`\${context} is not of type 'ZeroArgConstructor'.\`);
};

exports.create = function create(globalObject, constructorArgs, privateData) {
  if (globalObject[ctorRegistry] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistry][\\"ZeroArgConstructor\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor ZeroArgConstructor is not installed on the passed global object\\");
  }

  let obj = Object.create(ctor.prototype);
  obj = exports.setup(obj, globalObject, constructorArgs, privateData);
  return obj;
};
exports.createImpl = function createImpl(globalObject, constructorArgs, privateData) {
  const obj = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(obj);
};
exports._internalSetup = function _internalSetup(obj) {};
exports.setup = function setup(obj, globalObject, constructorArgs = [], privateData = {}) {
  privateData.wrapper = obj;

  exports._internalSetup(obj);
  Object.defineProperty(obj, impl, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  obj[impl][utils.wrapperSymbol] = obj;
  if (Impl.init) {
    Impl.init(obj[impl], privateData);
  }
  return obj;
};

exports.install = function install(globalObject) {
  class ZeroArgConstructor {
    constructor() {
      return exports.setup(Object.create(new.target.prototype), globalObject, undefined);
    }
  }
  Object.defineProperties(ZeroArgConstructor.prototype, {
    [Symbol.toStringTag]: { value: \\"ZeroArgConstructor\\", configurable: true }
  });
  if (globalObject[ctorRegistry] === undefined) {
    globalObject[ctorRegistry] = Object.create(null);
  }
  globalObject[ctorRegistry][interfaceName] = ZeroArgConstructor;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: ZeroArgConstructor
  });
};

const Impl = require(\\"../implementations/ZeroArgConstructor.js\\");
"
`;
