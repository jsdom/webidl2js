// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Transformer API addSource implementation file custom path 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"Foo\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'Foo'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"Foo\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor Foo is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class Foo {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }
  }
  Object.defineProperties(Foo.prototype, { [Symbol.toStringTag]: { value: \\"Foo\\", configurable: true } });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = Foo;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: Foo
  });
};

const Impl = require(\\"../fixtures/custom-path/impl-file.js\\");
"
`;

exports[`with processors AsyncCallbackInterface.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

exports.convert = function convert(value, { context = \\"The provided value\\" } = {}) {
  if (!utils.isObject(value)) {
    throw new TypeError(\`\${context} is not an object.\`);
  }

  function callTheUserObjectsOperation() {
    let thisArg = utils.tryWrapperForImpl(this);
    let O = value;
    let X = O;

    try {
      if (typeof O !== \\"function\\") {
        X = O[\\"asyncMethod\\"];
        if (typeof X !== \\"function\\") {
          throw new TypeError(\`\${context} does not correctly implement AsyncCallbackInterface.\`);
        }
        thisArg = O;
      }

      let callResult = Reflect.apply(X, thisArg, []);

      callResult = Promise.resolve(callResult).then(
        value => {
          value = conversions[\\"any\\"](value, { context: context + \\" promise value\\" });

          return value;
        },
        reason => reason
      );

      return callResult;
    } catch (err) {
      return Promise.reject(err);
    }
  }

  callTheUserObjectsOperation[utils.wrapperSymbol] = value;
  callTheUserObjectsOperation.objectReference = value;

  return callTheUserObjectsOperation;
};

exports.install = (globalObject, globalNames) => {};
"
`;

exports[`with processors BufferSourceTypes.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"BufferSourceTypes\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'BufferSourceTypes'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"BufferSourceTypes\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor BufferSourceTypes is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class BufferSourceTypes {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    bs(source) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'bs' on 'BufferSourceTypes': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (utils.isArrayBuffer(curArg)) {
        } else if (ArrayBuffer.isView(curArg)) {
        } else {
          throw new TypeError(
            \\"Failed to execute 'bs' on 'BufferSourceTypes': parameter 1\\" + \\" is not of any supported type.\\"
          );
        }
        args.push(curArg);
      }
      return esValue[implSymbol].bs(...args);
    }

    ab(ab) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'ab' on 'BufferSourceTypes': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"ArrayBuffer\\"](curArg, {
          context: \\"Failed to execute 'ab' on 'BufferSourceTypes': parameter 1\\"
        });
        args.push(curArg);
      }
      return esValue[implSymbol].ab(...args);
    }

    abv(abv) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'abv' on 'BufferSourceTypes': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (ArrayBuffer.isView(curArg)) {
        } else {
          throw new TypeError(
            \\"Failed to execute 'abv' on 'BufferSourceTypes': parameter 1\\" + \\" is not of any supported type.\\"
          );
        }
        args.push(curArg);
      }
      return esValue[implSymbol].abv(...args);
    }

    u8a(u8) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'u8a' on 'BufferSourceTypes': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"Uint8Array\\"](curArg, {
          context: \\"Failed to execute 'u8a' on 'BufferSourceTypes': parameter 1\\"
        });
        args.push(curArg);
      }
      return esValue[implSymbol].u8a(...args);
    }

    abUnion(ab) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'abUnion' on 'BufferSourceTypes': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (utils.isArrayBuffer(curArg)) {
        } else {
          curArg = conversions[\\"DOMString\\"](curArg, {
            context: \\"Failed to execute 'abUnion' on 'BufferSourceTypes': parameter 1\\"
          });
        }
        args.push(curArg);
      }
      return esValue[implSymbol].abUnion(...args);
    }

    u8aUnion(ab) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'u8aUnion' on 'BufferSourceTypes': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (ArrayBuffer.isView(curArg) && curArg.constructor.name === \\"Uint8Array\\") {
        } else {
          curArg = conversions[\\"DOMString\\"](curArg, {
            context: \\"Failed to execute 'u8aUnion' on 'BufferSourceTypes': parameter 1\\"
          });
        }
        args.push(curArg);
      }
      return esValue[implSymbol].u8aUnion(...args);
    }
  }
  Object.defineProperties(BufferSourceTypes.prototype, {
    bs: { enumerable: true },
    ab: { enumerable: true },
    abv: { enumerable: true },
    u8a: { enumerable: true },
    abUnion: { enumerable: true },
    u8aUnion: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"BufferSourceTypes\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = BufferSourceTypes;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: BufferSourceTypes
  });
};

const Impl = require(\\"../implementations/BufferSourceTypes.js\\");
"
`;

exports[`with processors CEReactions.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const CEReactions = require(\\"../CEReactions.js\\");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"CEReactions\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'CEReactions'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"CEReactions\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor CEReactions is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

function makeProxy(wrapper, globalObject) {
  let proxyHandler = proxyHandlerCache.get(globalObject);
  if (proxyHandler === undefined) {
    proxyHandler = new ProxyHandler(globalObject);
    proxyHandlerCache.set(globalObject, proxyHandler);
  }
  return new Proxy(wrapper, proxyHandler);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper = makeProxy(wrapper, globalObject);

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper = makeProxy(wrapper, globalObject);

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class CEReactions {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    method() {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      CEReactions.preSteps(globalObject);
      try {
        return esValue[implSymbol].method();
      } finally {
        CEReactions.postSteps(globalObject);
      }
    }

    promiseOperation() {
      try {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        CEReactions.preSteps(globalObject);
        try {
          return utils.tryWrapperForImpl(esValue[implSymbol].promiseOperation());
        } finally {
          CEReactions.postSteps(globalObject);
        }
      } catch (e) {
        return Promise.reject(e);
      }
    }

    get attr() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      CEReactions.preSteps(globalObject);
      try {
        return esValue[implSymbol][\\"attr\\"];
      } finally {
        CEReactions.postSteps(globalObject);
      }
    }

    set attr(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"DOMString\\"](V, {
        context: \\"Failed to set the 'attr' property on 'CEReactions': The provided value\\"
      });

      CEReactions.preSteps(globalObject);
      try {
        esValue[implSymbol][\\"attr\\"] = V;
      } finally {
        CEReactions.postSteps(globalObject);
      }
    }

    get promiseAttribute() {
      try {
        const esValue = this !== null && this !== undefined ? this : globalObject;

        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        CEReactions.preSteps(globalObject);
        try {
          return utils.tryWrapperForImpl(esValue[implSymbol][\\"promiseAttribute\\"]);
        } finally {
          CEReactions.postSteps(globalObject);
        }
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }
  Object.defineProperties(CEReactions.prototype, {
    method: { enumerable: true },
    promiseOperation: { enumerable: true },
    attr: { enumerable: true },
    promiseAttribute: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"CEReactions\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = CEReactions;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: CEReactions
  });
};

const proxyHandlerCache = new WeakMap();
class ProxyHandler {
  constructor(globalObject) {
    this._globalObject = globalObject;
  }

  get(target, P, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.get(target, P, receiver);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc === undefined) {
      const parent = Object.getPrototypeOf(target);
      if (parent === null) {
        return undefined;
      }
      return Reflect.get(target, P, receiver);
    }
    if (!desc.get && !desc.set) {
      return desc.value;
    }
    const getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return Reflect.apply(getter, receiver, []);
  }

  has(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.has(target, P);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc !== undefined) {
      return true;
    }
    const parent = Object.getPrototypeOf(target);
    if (parent !== null) {
      return Reflect.has(parent, P);
    }
    return false;
  }

  ownKeys(target) {
    const keys = new Set();

    for (const key of target[implSymbol][utils.supportedPropertyNames]) {
      if (!(key in target)) {
        keys.add(\`\${key}\`);
      }
    }

    for (const key of Reflect.ownKeys(target)) {
      keys.add(key);
    }
    return [...keys];
  }

  getOwnPropertyDescriptor(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.getOwnPropertyDescriptor(target, P);
    }
    let ignoreNamedProps = false;

    if (target[implSymbol][utils.supportsPropertyName](P) && !(P in target) && !ignoreNamedProps) {
      const namedValue = target[implSymbol][utils.namedGet](P);

      return {
        writable: true,
        enumerable: true,
        configurable: true,
        value: utils.tryWrapperForImpl(namedValue)
      };
    }

    return Reflect.getOwnPropertyDescriptor(target, P);
  }

  set(target, P, V, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.set(target, P, V, receiver);
    }
    if (target === receiver) {
      const globalObject = this._globalObject;

      if (typeof P === \\"string\\" && !utils.isArrayIndexPropName(P)) {
        let namedValue = V;

        namedValue = conversions[\\"DOMString\\"](namedValue, {
          context: \\"Failed to set the '\\" + P + \\"' property on 'CEReactions': The provided value\\"
        });

        CEReactions.preSteps(globalObject);
        try {
          const creating = !target[implSymbol][utils.supportsPropertyName](P);
          if (creating) {
            target[implSymbol][utils.namedSetNew](P, namedValue);
          } else {
            target[implSymbol][utils.namedSetExisting](P, namedValue);
          }
        } finally {
          CEReactions.postSteps(globalObject);
        }

        return true;
      }
    }
    let ownDesc;

    if (ownDesc === undefined) {
      ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
    }
    if (ownDesc === undefined) {
      const parent = Reflect.getPrototypeOf(target);
      if (parent !== null) {
        return Reflect.set(parent, P, V, receiver);
      }
      ownDesc = { writable: true, enumerable: true, configurable: true, value: undefined };
    }
    if (!ownDesc.writable) {
      return false;
    }
    if (!utils.isObject(receiver)) {
      return false;
    }
    const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
    let valueDesc;
    if (existingDesc !== undefined) {
      if (existingDesc.get || existingDesc.set) {
        return false;
      }
      if (!existingDesc.writable) {
        return false;
      }
      valueDesc = { value: V };
    } else {
      valueDesc = { writable: true, enumerable: true, configurable: true, value: V };
    }
    return Reflect.defineProperty(receiver, P, valueDesc);
  }

  defineProperty(target, P, desc) {
    if (typeof P === \\"symbol\\") {
      return Reflect.defineProperty(target, P, desc);
    }

    const globalObject = this._globalObject;
    if (!utils.hasOwn(target, P)) {
      if (desc.get || desc.set) {
        return false;
      }

      let namedValue = desc.value;

      namedValue = conversions[\\"DOMString\\"](namedValue, {
        context: \\"Failed to set the '\\" + P + \\"' property on 'CEReactions': The provided value\\"
      });

      CEReactions.preSteps(globalObject);
      try {
        const creating = !target[implSymbol][utils.supportsPropertyName](P);
        if (creating) {
          target[implSymbol][utils.namedSetNew](P, namedValue);
        } else {
          target[implSymbol][utils.namedSetExisting](P, namedValue);
        }
      } finally {
        CEReactions.postSteps(globalObject);
      }

      return true;
    }
    return Reflect.defineProperty(target, P, desc);
  }

  deleteProperty(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.deleteProperty(target, P);
    }

    const globalObject = this._globalObject;

    if (target[implSymbol][utils.supportsPropertyName](P) && !(P in target)) {
      CEReactions.preSteps(globalObject);
      try {
        target[implSymbol][utils.namedDelete](P);
        return true;
      } finally {
        CEReactions.postSteps(globalObject);
      }
    }

    return Reflect.deleteProperty(target, P);
  }

  preventExtensions() {
    return false;
  }
}

const Impl = require(\\"../implementations/CEReactions.js\\");
"
`;

exports[`with processors DOMImplementation.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"DOMImplementation\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'DOMImplementation'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"DOMImplementation\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor DOMImplementation is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class DOMImplementation {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    createDocumentType(qualifiedName, publicId, systemId) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 3) {
        throw new TypeError(
          \\"Failed to execute 'createDocumentType' on 'DOMImplementation': 3 arguments required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'createDocumentType' on 'DOMImplementation': parameter 1\\"
        });
        args.push(curArg);
      }
      {
        let curArg = arguments[1];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'createDocumentType' on 'DOMImplementation': parameter 2\\"
        });
        args.push(curArg);
      }
      {
        let curArg = arguments[2];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'createDocumentType' on 'DOMImplementation': parameter 3\\"
        });
        args.push(curArg);
      }
      return utils.tryWrapperForImpl(esValue[implSymbol].createDocumentType(...args));
    }

    createDocument(namespace, qualifiedName) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 2) {
        throw new TypeError(
          \\"Failed to execute 'createDocument' on 'DOMImplementation': 2 arguments required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg === null || curArg === undefined) {
          curArg = null;
        } else {
          curArg = conversions[\\"DOMString\\"](curArg, {
            context: \\"Failed to execute 'createDocument' on 'DOMImplementation': parameter 1\\"
          });
        }
        args.push(curArg);
      }
      {
        let curArg = arguments[1];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'createDocument' on 'DOMImplementation': parameter 2\\",
          treatNullAsEmptyString: true
        });
        args.push(curArg);
      }
      {
        let curArg = arguments[2];
        if (curArg !== undefined) {
          if (curArg === null || curArg === undefined) {
            curArg = null;
          } else {
            curArg = utils.tryImplForWrapper(curArg);
          }
        } else {
          curArg = null;
        }
        args.push(curArg);
      }
      return utils.tryWrapperForImpl(esValue[implSymbol].createDocument(...args));
    }

    createHTMLDocument() {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg !== undefined) {
          curArg = conversions[\\"DOMString\\"](curArg, {
            context: \\"Failed to execute 'createHTMLDocument' on 'DOMImplementation': parameter 1\\"
          });
        }
        args.push(curArg);
      }
      return utils.tryWrapperForImpl(esValue[implSymbol].createHTMLDocument(...args));
    }

    hasFeature() {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol].hasFeature();
    }
  }
  Object.defineProperties(DOMImplementation.prototype, {
    createDocumentType: { enumerable: true },
    createDocument: { enumerable: true },
    createHTMLDocument: { enumerable: true },
    hasFeature: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"DOMImplementation\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = DOMImplementation;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: DOMImplementation
  });
};

const Impl = require(\\"../implementations/DOMImplementation.js\\");
"
`;

exports[`with processors DOMRect.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"DOMRect\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'DOMRect'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"DOMRect\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor DOMRect is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\", \\"Worker\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class DOMRect {
    constructor() {
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg !== undefined) {
          curArg = conversions[\\"unrestricted double\\"](curArg, {
            context: \\"Failed to construct 'DOMRect': parameter 1\\"
          });
        } else {
          curArg = 0;
        }
        args.push(curArg);
      }
      {
        let curArg = arguments[1];
        if (curArg !== undefined) {
          curArg = conversions[\\"unrestricted double\\"](curArg, {
            context: \\"Failed to construct 'DOMRect': parameter 2\\"
          });
        } else {
          curArg = 0;
        }
        args.push(curArg);
      }
      {
        let curArg = arguments[2];
        if (curArg !== undefined) {
          curArg = conversions[\\"unrestricted double\\"](curArg, {
            context: \\"Failed to construct 'DOMRect': parameter 3\\"
          });
        } else {
          curArg = 0;
        }
        args.push(curArg);
      }
      {
        let curArg = arguments[3];
        if (curArg !== undefined) {
          curArg = conversions[\\"unrestricted double\\"](curArg, {
            context: \\"Failed to construct 'DOMRect': parameter 4\\"
          });
        } else {
          curArg = 0;
        }
        args.push(curArg);
      }
      return exports.setup(Object.create(new.target.prototype), globalObject, args);
    }

    get x() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"x\\"];
    }

    set x(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"unrestricted double\\"](V, {
        context: \\"Failed to set the 'x' property on 'DOMRect': The provided value\\"
      });

      esValue[implSymbol][\\"x\\"] = V;
    }

    get y() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"y\\"];
    }

    set y(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"unrestricted double\\"](V, {
        context: \\"Failed to set the 'y' property on 'DOMRect': The provided value\\"
      });

      esValue[implSymbol][\\"y\\"] = V;
    }

    get width() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"width\\"];
    }

    set width(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"unrestricted double\\"](V, {
        context: \\"Failed to set the 'width' property on 'DOMRect': The provided value\\"
      });

      esValue[implSymbol][\\"width\\"] = V;
    }

    get height() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"height\\"];
    }

    set height(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"unrestricted double\\"](V, {
        context: \\"Failed to set the 'height' property on 'DOMRect': The provided value\\"
      });

      esValue[implSymbol][\\"height\\"] = V;
    }

    static fromRect() {
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg !== undefined) {
          curArg = utils.tryImplForWrapper(curArg);
        }
        args.push(curArg);
      }
      return utils.tryWrapperForImpl(Impl.implementation.fromRect(...args));
    }
  }
  Object.defineProperties(DOMRect.prototype, {
    x: { enumerable: true },
    y: { enumerable: true },
    width: { enumerable: true },
    height: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"DOMRect\\", configurable: true }
  });
  Object.defineProperties(DOMRect, { fromRect: { enumerable: true } });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = DOMRect;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: DOMRect
  });

  if (globalNames.includes(\\"Window\\")) {
    Object.defineProperty(globalObject, \\"SVGRect\\", {
      configurable: true,
      writable: true,
      value: DOMRect
    });
  }
};

const Impl = require(\\"../implementations/DOMRect.js\\");
"
`;

exports[`with processors Dictionary.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const URL = require(\\"./URL.js\\");
const URLSearchParams = require(\\"./URLSearchParams.js\\");

exports._convertInherit = (obj, ret, { context = \\"The provided value\\" } = {}) => {
  {
    const key = \\"boolWithDefault\\";
    let value = obj === undefined || obj === null ? undefined : obj[key];
    if (value !== undefined) {
      value = conversions[\\"boolean\\"](value, { context: context + \\" has member 'boolWithDefault' that\\" });

      ret[key] = value;
    } else {
      ret[key] = false;
    }
  }

  {
    const key = \\"requiredInterface\\";
    let value = obj === undefined || obj === null ? undefined : obj[key];
    if (value !== undefined) {
      value = URL.convert(value, { context: context + \\" has member 'requiredInterface' that\\" });

      ret[key] = value;
    } else {
      throw new TypeError(\\"requiredInterface is required in 'Dictionary'\\");
    }
  }

  {
    const key = \\"seq\\";
    let value = obj === undefined || obj === null ? undefined : obj[key];
    if (value !== undefined) {
      if (!utils.isObject(value)) {
        throw new TypeError(context + \\" has member 'seq' that\\" + \\" is not an iterable object.\\");
      } else {
        const V = [];
        const tmp = value;
        for (let nextItem of tmp) {
          nextItem = URLSearchParams.convert(nextItem, { context: context + \\" has member 'seq' that\\" + \\"'s element\\" });

          V.push(nextItem);
        }
        value = V;
      }

      ret[key] = value;
    }
  }

  {
    const key = \\"vanillaString\\";
    let value = obj === undefined || obj === null ? undefined : obj[key];
    if (value !== undefined) {
      value = conversions[\\"DOMString\\"](value, { context: context + \\" has member 'vanillaString' that\\" });

      ret[key] = value;
    }
  }
};

exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (obj !== undefined && typeof obj !== \\"object\\" && typeof obj !== \\"function\\") {
    throw new TypeError(\`\${context} is not an object.\`);
  }

  const ret = Object.create(null);
  exports._convertInherit(obj, ret, { context });
  return ret;
};
"
`;

exports[`with processors DictionaryConvert.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const Dictionary = require(\\"./Dictionary.js\\");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"DictionaryConvert\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'DictionaryConvert'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"DictionaryConvert\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor DictionaryConvert is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class DictionaryConvert {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    op() {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg !== undefined) {
          curArg = conversions[\\"DOMString\\"](curArg, {
            context: \\"Failed to execute 'op' on 'DictionaryConvert': parameter 1\\"
          });
        }
        args.push(curArg);
      }
      {
        let curArg = arguments[1];
        curArg = Dictionary.convert(curArg, { context: \\"Failed to execute 'op' on 'DictionaryConvert': parameter 2\\" });
        args.push(curArg);
      }
      return esValue[implSymbol].op(...args);
    }
  }
  Object.defineProperties(DictionaryConvert.prototype, {
    op: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"DictionaryConvert\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = DictionaryConvert;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: DictionaryConvert
  });
};

const Impl = require(\\"../implementations/DictionaryConvert.js\\");
"
`;

exports[`with processors Enum.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const RequestDestination = require(\\"./RequestDestination.js\\");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"Enum\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'Enum'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"Enum\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor Enum is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class Enum {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    op(destination) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'op' on 'Enum': 1 argument required, but only \\" + arguments.length + \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = RequestDestination.convert(curArg, { context: \\"Failed to execute 'op' on 'Enum': parameter 1\\" });
        args.push(curArg);
      }
      return esValue[implSymbol].op(...args);
    }

    get attr() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][\\"attr\\"]);
    }

    set attr(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = \`\${V}\`;
      if (!RequestDestination.enumerationValues.has(V)) {
        return;
      }

      esValue[implSymbol][\\"attr\\"] = V;
    }
  }
  Object.defineProperties(Enum.prototype, {
    op: { enumerable: true },
    attr: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"Enum\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = Enum;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: Enum
  });
};

const Impl = require(\\"../implementations/Enum.js\\");
"
`;

exports[`with processors EventListener.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

exports.convert = function convert(value, { context = \\"The provided value\\" } = {}) {
  if (!utils.isObject(value)) {
    throw new TypeError(\`\${context} is not an object.\`);
  }

  function callTheUserObjectsOperation(event) {
    let thisArg = utils.tryWrapperForImpl(this);
    let O = value;
    let X = O;

    if (typeof O !== \\"function\\") {
      X = O[\\"handleEvent\\"];
      if (typeof X !== \\"function\\") {
        throw new TypeError(\`\${context} does not correctly implement EventListener.\`);
      }
      thisArg = O;
    }

    event = utils.tryWrapperForImpl(event);

    let callResult = Reflect.apply(X, thisArg, [event]);
  }

  callTheUserObjectsOperation[utils.wrapperSymbol] = value;
  callTheUserObjectsOperation.objectReference = value;

  return callTheUserObjectsOperation;
};

exports.install = (globalObject, globalNames) => {};
"
`;

exports[`with processors EventTarget.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const EventListener = require(\\"./EventListener.js\\");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"EventTarget\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'EventTarget'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"EventTarget\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor EventTarget is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\", \\"Worker\\", \\"AudioWorklet\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class EventTarget {
    constructor() {
      return exports.setup(Object.create(new.target.prototype), globalObject, undefined);
    }

    addEventListener(type, callback) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 2) {
        throw new TypeError(
          \\"Failed to execute 'addEventListener' on 'EventTarget': 2 arguments required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'addEventListener' on 'EventTarget': parameter 1\\"
        });
        args.push(curArg);
      }
      {
        let curArg = arguments[1];
        if (curArg === null || curArg === undefined) {
          curArg = null;
        } else {
          curArg = EventListener.convert(curArg, {
            context: \\"Failed to execute 'addEventListener' on 'EventTarget': parameter 2\\"
          });
        }
        args.push(curArg);
      }
      return esValue[implSymbol].addEventListener(...args);
    }
  }
  Object.defineProperties(EventTarget.prototype, {
    addEventListener: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"EventTarget\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = EventTarget;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: EventTarget
  });
};

const Impl = require(\\"../implementations/EventTarget.js\\");
"
`;

exports[`with processors Global.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"Global\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'Global'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"Global\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor Global is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {
  Object.defineProperties(
    wrapper,
    Object.getOwnPropertyDescriptors({
      op() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return esValue[implSymbol].op();
      },
      unforgeableOp() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return esValue[implSymbol].unforgeableOp();
      },
      get attr() {
        const esValue = this !== null && this !== undefined ? this : globalObject;

        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return esValue[implSymbol][\\"attr\\"];
      },
      set attr(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;

        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        V = conversions[\\"DOMString\\"](V, {
          context: \\"Failed to set the 'attr' property on 'Global': The provided value\\"
        });

        esValue[implSymbol][\\"attr\\"] = V;
      },
      get unforgeableAttr() {
        const esValue = this !== null && this !== undefined ? this : globalObject;

        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return esValue[implSymbol][\\"unforgeableAttr\\"];
      },
      set unforgeableAttr(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;

        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        V = conversions[\\"DOMString\\"](V, {
          context: \\"Failed to set the 'unforgeableAttr' property on 'Global': The provided value\\"
        });

        esValue[implSymbol][\\"unforgeableAttr\\"] = V;
      },
      get length() {
        const esValue = this !== null && this !== undefined ? this : globalObject;

        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return esValue[implSymbol][\\"length\\"];
      },
      set length(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;

        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        V = conversions[\\"unsigned long\\"](V, {
          context: \\"Failed to set the 'length' property on 'Global': The provided value\\"
        });

        esValue[implSymbol][\\"length\\"] = V;
      },
      [Symbol.iterator]: Array.prototype[Symbol.iterator],
      keys: Array.prototype.keys,
      values: Array.prototype[Symbol.iterator],
      entries: Array.prototype.entries,
      forEach: Array.prototype.forEach
    })
  );

  Object.defineProperties(wrapper, {
    unforgeableOp: { configurable: false, writable: false },
    unforgeableAttr: { configurable: false },
    [Symbol.iterator]: { enumerable: false }
  });
};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Global\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class Global {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    static staticOp() {
      return Impl.implementation.staticOp();
    }

    static get staticAttr() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      return Impl.implementation[\\"staticAttr\\"];
    }

    static set staticAttr(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      return Impl.implementation[\\"staticAttr\\"];
    }
  }
  Object.defineProperties(Global.prototype, { [Symbol.toStringTag]: { value: \\"Global\\", configurable: true } });
  Object.defineProperties(Global, { staticOp: { enumerable: true }, staticAttr: { enumerable: true } });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = Global;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: Global
  });
};

const Impl = require(\\"../implementations/Global.js\\");
"
`;

exports[`with processors HTMLConstructor.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const HTMLConstructor_HTMLConstructor = require(\\"../HTMLConstructor.js\\").HTMLConstructor;
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"HTMLConstructor\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'HTMLConstructor'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"HTMLConstructor\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor HTMLConstructor is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class HTMLConstructor {
    constructor() {
      return HTMLConstructor_HTMLConstructor(globalObject, interfaceName);
    }
  }
  Object.defineProperties(HTMLConstructor.prototype, {
    [Symbol.toStringTag]: { value: \\"HTMLConstructor\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = HTMLConstructor;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: HTMLConstructor
  });
};

const Impl = require(\\"../implementations/HTMLConstructor.js\\");
"
`;

exports[`with processors LegacyLenientAttributes.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"LegacyLenientAttributes\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'LegacyLenientAttributes'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"LegacyLenientAttributes\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor LegacyLenientAttributes is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class LegacyLenientAttributes {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    get lenientSetter() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"lenientSetter\\"];
    }

    set lenientSetter(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
    }

    get lenientThisSetter() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        return;
      }

      return esValue[implSymbol][\\"lenientThisSetter\\"];
    }

    set lenientThisSetter(V) {}

    get lenientThis() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        return;
      }

      return esValue[implSymbol][\\"lenientThis\\"];
    }

    set lenientThis(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        return;
      }

      V = conversions[\\"DOMString\\"](V, {
        context: \\"Failed to set the 'lenientThis' property on 'LegacyLenientAttributes': The provided value\\"
      });

      esValue[implSymbol][\\"lenientThis\\"] = V;
    }

    get readonlyLenientThis() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        return;
      }

      return esValue[implSymbol][\\"readonlyLenientThis\\"];
    }

    get replaceableLenientThis() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        return;
      }

      return esValue[implSymbol][\\"replaceableLenientThis\\"];
    }

    set replaceableLenientThis(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      Object.defineProperty(esValue, \\"replaceableLenientThis\\", {
        configurable: true,
        enumerable: true,
        value: V,
        writable: true
      });
    }
  }
  Object.defineProperties(LegacyLenientAttributes.prototype, {
    lenientSetter: { enumerable: true },
    lenientThisSetter: { enumerable: true },
    lenientThis: { enumerable: true },
    readonlyLenientThis: { enumerable: true },
    replaceableLenientThis: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"LegacyLenientAttributes\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = LegacyLenientAttributes;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: LegacyLenientAttributes
  });
};

const Impl = require(\\"../implementations/LegacyLenientAttributes.js\\");
"
`;

exports[`with processors LegacyUnforgeable.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"LegacyUnforgeable\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'LegacyUnforgeable'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"LegacyUnforgeable\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor LegacyUnforgeable is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {
  Object.defineProperties(
    wrapper,
    Object.getOwnPropertyDescriptors({
      assign(url) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        if (arguments.length < 1) {
          throw new TypeError(
            \\"Failed to execute 'assign' on 'LegacyUnforgeable': 1 argument required, but only \\" +
              arguments.length +
              \\" present.\\"
          );
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions[\\"USVString\\"](curArg, {
            context: \\"Failed to execute 'assign' on 'LegacyUnforgeable': parameter 1\\"
          });
          args.push(curArg);
        }
        return esValue[implSymbol].assign(...args);
      },
      get href() {
        const esValue = this !== null && this !== undefined ? this : globalObject;

        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return esValue[implSymbol][\\"href\\"];
      },
      set href(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;

        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        V = conversions[\\"USVString\\"](V, {
          context: \\"Failed to set the 'href' property on 'LegacyUnforgeable': The provided value\\"
        });

        esValue[implSymbol][\\"href\\"] = V;
      },
      toString() {
        const esValue = this;
        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return esValue[implSymbol][\\"href\\"];
      },
      get origin() {
        const esValue = this !== null && this !== undefined ? this : globalObject;

        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return esValue[implSymbol][\\"origin\\"];
      },
      get protocol() {
        const esValue = this !== null && this !== undefined ? this : globalObject;

        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return esValue[implSymbol][\\"protocol\\"];
      },
      set protocol(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;

        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        V = conversions[\\"USVString\\"](V, {
          context: \\"Failed to set the 'protocol' property on 'LegacyUnforgeable': The provided value\\"
        });

        esValue[implSymbol][\\"protocol\\"] = V;
      }
    })
  );

  Object.defineProperties(wrapper, {
    assign: { configurable: false, writable: false },
    href: { configurable: false },
    toString: { configurable: false, writable: false },
    origin: { configurable: false },
    protocol: { configurable: false }
  });
};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class LegacyUnforgeable {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }
  }
  Object.defineProperties(LegacyUnforgeable.prototype, {
    [Symbol.toStringTag]: { value: \\"LegacyUnforgeable\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = LegacyUnforgeable;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: LegacyUnforgeable
  });
};

const Impl = require(\\"../implementations/LegacyUnforgeable.js\\");
"
`;

exports[`with processors LegacyUnforgeableMap.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"LegacyUnforgeableMap\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'LegacyUnforgeableMap'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"LegacyUnforgeableMap\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor LegacyUnforgeableMap is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {
  Object.defineProperties(
    wrapper,
    Object.getOwnPropertyDescriptors({
      get a() {
        const esValue = this !== null && this !== undefined ? this : globalObject;

        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return esValue[implSymbol][\\"a\\"];
      }
    })
  );

  Object.defineProperties(wrapper, { a: { configurable: false } });
};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper = new Proxy(wrapper, proxyHandler);

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper = new Proxy(wrapper, proxyHandler);

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class LegacyUnforgeableMap {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }
  }
  Object.defineProperties(LegacyUnforgeableMap.prototype, {
    [Symbol.toStringTag]: { value: \\"LegacyUnforgeableMap\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = LegacyUnforgeableMap;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: LegacyUnforgeableMap
  });
};

const proxyHandler = {
  get(target, P, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.get(target, P, receiver);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc === undefined) {
      const parent = Object.getPrototypeOf(target);
      if (parent === null) {
        return undefined;
      }
      return Reflect.get(target, P, receiver);
    }
    if (!desc.get && !desc.set) {
      return desc.value;
    }
    const getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return Reflect.apply(getter, receiver, []);
  },

  has(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.has(target, P);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc !== undefined) {
      return true;
    }
    const parent = Object.getPrototypeOf(target);
    if (parent !== null) {
      return Reflect.has(parent, P);
    }
    return false;
  },

  ownKeys(target) {
    const keys = new Set();

    for (const key of target[implSymbol][utils.supportedPropertyNames]) {
      if (!(key in target)) {
        keys.add(\`\${key}\`);
      }
    }

    for (const key of Reflect.ownKeys(target)) {
      keys.add(key);
    }
    return [...keys];
  },

  getOwnPropertyDescriptor(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.getOwnPropertyDescriptor(target, P);
    }
    let ignoreNamedProps = false;

    if (target[implSymbol][utils.supportsPropertyName](P) && !(P in target) && !ignoreNamedProps) {
      const namedValue = target[implSymbol][utils.namedGet](P);

      return {
        writable: true,
        enumerable: true,
        configurable: true,
        value: utils.tryWrapperForImpl(namedValue)
      };
    }

    return Reflect.getOwnPropertyDescriptor(target, P);
  },

  set(target, P, V, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.set(target, P, V, receiver);
    }
    if (target === receiver) {
      if (typeof P === \\"string\\" && !utils.isArrayIndexPropName(P)) {
        let namedValue = V;

        namedValue = conversions[\\"DOMString\\"](namedValue, {
          context: \\"Failed to set the '\\" + P + \\"' property on 'LegacyUnforgeableMap': The provided value\\"
        });

        const creating = !target[implSymbol][utils.supportsPropertyName](P);
        if (creating) {
          target[implSymbol][utils.namedSetNew](P, namedValue);
        } else {
          target[implSymbol][utils.namedSetExisting](P, namedValue);
        }

        return true;
      }
    }
    let ownDesc;

    if (ownDesc === undefined) {
      ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
    }
    if (ownDesc === undefined) {
      const parent = Reflect.getPrototypeOf(target);
      if (parent !== null) {
        return Reflect.set(parent, P, V, receiver);
      }
      ownDesc = { writable: true, enumerable: true, configurable: true, value: undefined };
    }
    if (!ownDesc.writable) {
      return false;
    }
    if (!utils.isObject(receiver)) {
      return false;
    }
    const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
    let valueDesc;
    if (existingDesc !== undefined) {
      if (existingDesc.get || existingDesc.set) {
        return false;
      }
      if (!existingDesc.writable) {
        return false;
      }
      valueDesc = { value: V };
    } else {
      valueDesc = { writable: true, enumerable: true, configurable: true, value: V };
    }
    return Reflect.defineProperty(receiver, P, valueDesc);
  },

  defineProperty(target, P, desc) {
    if (typeof P === \\"symbol\\") {
      return Reflect.defineProperty(target, P, desc);
    }
    if (![\\"a\\"].includes(P)) {
      if (!utils.hasOwn(target, P)) {
        if (desc.get || desc.set) {
          return false;
        }

        let namedValue = desc.value;

        namedValue = conversions[\\"DOMString\\"](namedValue, {
          context: \\"Failed to set the '\\" + P + \\"' property on 'LegacyUnforgeableMap': The provided value\\"
        });

        const creating = !target[implSymbol][utils.supportsPropertyName](P);
        if (creating) {
          target[implSymbol][utils.namedSetNew](P, namedValue);
        } else {
          target[implSymbol][utils.namedSetExisting](P, namedValue);
        }

        return true;
      }
    }
    return Reflect.defineProperty(target, P, desc);
  },

  deleteProperty(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.deleteProperty(target, P);
    }

    if (target[implSymbol][utils.supportsPropertyName](P) && !(P in target)) {
      return false;
    }

    return Reflect.deleteProperty(target, P);
  },

  preventExtensions() {
    return false;
  }
};

const Impl = require(\\"../implementations/LegacyUnforgeableMap.js\\");
"
`;

exports[`with processors MixedIn.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"MixedIn\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'MixedIn'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"MixedIn\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor MixedIn is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class MixedIn {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    mixedInOp() {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol].mixedInOp();
    }

    ifaceMixinOp() {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol].ifaceMixinOp();
    }

    get mixedInAttr() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"mixedInAttr\\"];
    }

    set mixedInAttr(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"DOMString\\"](V, {
        context: \\"Failed to set the 'mixedInAttr' property on 'MixedIn': The provided value\\"
      });

      esValue[implSymbol][\\"mixedInAttr\\"] = V;
    }

    get ifaceMixinAttr() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"ifaceMixinAttr\\"];
    }

    set ifaceMixinAttr(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"DOMString\\"](V, {
        context: \\"Failed to set the 'ifaceMixinAttr' property on 'MixedIn': The provided value\\"
      });

      esValue[implSymbol][\\"ifaceMixinAttr\\"] = V;
    }
  }
  Object.defineProperties(MixedIn.prototype, {
    mixedInOp: { enumerable: true },
    ifaceMixinOp: { enumerable: true },
    mixedInAttr: { enumerable: true },
    ifaceMixinAttr: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"MixedIn\\", configurable: true },
    mixedInConst: { value: 43, enumerable: true },
    ifaceMixinConst: { value: 42, enumerable: true }
  });
  Object.defineProperties(MixedIn, {
    mixedInConst: { value: 43, enumerable: true },
    ifaceMixinConst: { value: 42, enumerable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = MixedIn;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: MixedIn
  });
};

const Impl = require(\\"../implementations/MixedIn.js\\");
"
`;

exports[`with processors NodeFilter.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

exports.convert = function convert(value, { context = \\"The provided value\\" } = {}) {
  if (!utils.isObject(value)) {
    throw new TypeError(\`\${context} is not an object.\`);
  }

  function callTheUserObjectsOperation(node) {
    let thisArg = utils.tryWrapperForImpl(this);
    let O = value;
    let X = O;

    if (typeof O !== \\"function\\") {
      X = O[\\"acceptNode\\"];
      if (typeof X !== \\"function\\") {
        throw new TypeError(\`\${context} does not correctly implement NodeFilter.\`);
      }
      thisArg = O;
    }

    node = utils.tryWrapperForImpl(node);

    let callResult = Reflect.apply(X, thisArg, [node]);

    callResult = conversions[\\"unsigned short\\"](callResult, { context: context });

    return callResult;
  }

  callTheUserObjectsOperation[utils.wrapperSymbol] = value;
  callTheUserObjectsOperation.objectReference = value;

  return callTheUserObjectsOperation;
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }

  const NodeFilter = () => {
    throw new TypeError(\\"Illegal invocation\\");
  };

  Object.defineProperties(NodeFilter, {
    FILTER_ACCEPT: { value: 1, enumerable: true },
    FILTER_REJECT: { value: 2, enumerable: true },
    FILTER_SKIP: { value: 3, enumerable: true },
    SHOW_ALL: { value: 0xffffffff, enumerable: true },
    SHOW_ELEMENT: { value: 0x1, enumerable: true },
    SHOW_ATTRIBUTE: { value: 0x2, enumerable: true },
    SHOW_TEXT: { value: 0x4, enumerable: true },
    SHOW_CDATA_SECTION: { value: 0x8, enumerable: true },
    SHOW_ENTITY_REFERENCE: { value: 0x10, enumerable: true },
    SHOW_ENTITY: { value: 0x20, enumerable: true },
    SHOW_PROCESSING_INSTRUCTION: { value: 0x40, enumerable: true },
    SHOW_COMMENT: { value: 0x80, enumerable: true },
    SHOW_DOCUMENT: { value: 0x100, enumerable: true },
    SHOW_DOCUMENT_TYPE: { value: 0x200, enumerable: true },
    SHOW_DOCUMENT_FRAGMENT: { value: 0x400, enumerable: true },
    SHOW_NOTATION: { value: 0x800, enumerable: true }
  });

  Object.defineProperty(globalObject, \\"NodeFilter\\", {
    configurable: true,
    writable: true,
    value: NodeFilter
  });
};
"
`;

exports[`with processors Overloads.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const URL = require(\\"./URL.js\\");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"Overloads\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'Overloads'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"Overloads\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor Overloads is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class Overloads {
    constructor() {
      const args = [];
      switch (arguments.length) {
        case 0:
          break;
        default: {
          let curArg = arguments[0];
          if (URL.is(curArg)) {
            {
              let curArg = arguments[0];
              curArg = URL.convert(curArg, { context: \\"Failed to construct 'Overloads': parameter 1\\" });
              args.push(curArg);
            }
          } else {
            {
              let curArg = arguments[0];
              curArg = conversions[\\"DOMString\\"](curArg, { context: \\"Failed to construct 'Overloads': parameter 1\\" });
              args.push(curArg);
            }
          }
        }
      }
      return exports.setup(Object.create(new.target.prototype), globalObject, args);
    }

    compatible(arg1) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'compatible' on 'Overloads': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      switch (arguments.length) {
        case 1:
          {
            let curArg = arguments[0];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'compatible' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
          break;
        case 2:
          {
            let curArg = arguments[0];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'compatible' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'compatible' on 'Overloads': parameter 2\\"
            });
            args.push(curArg);
          }
          break;
        default:
          {
            let curArg = arguments[0];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'compatible' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'compatible' on 'Overloads': parameter 2\\"
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[2];
            if (curArg !== undefined) {
              curArg = conversions[\\"long\\"](curArg, {
                context: \\"Failed to execute 'compatible' on 'Overloads': parameter 3\\"
              });
            } else {
              curArg = 0;
            }
            args.push(curArg);
          }
      }
      return utils.tryWrapperForImpl(esValue[implSymbol].compatible(...args));
    }

    incompatible1(arg1) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'incompatible1' on 'Overloads': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (typeof curArg === \\"number\\") {
          {
            let curArg = arguments[0];
            curArg = conversions[\\"long\\"](curArg, {
              context: \\"Failed to execute 'incompatible1' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
        } else {
          {
            let curArg = arguments[0];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'incompatible1' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
        }
      }
      return esValue[implSymbol].incompatible1(...args);
    }

    incompatible2(arg1) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'incompatible2' on 'Overloads': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      switch (arguments.length) {
        case 1:
          {
            let curArg = arguments[0];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'incompatible2' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
          break;
        default:
          {
            let curArg = arguments[0];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'incompatible2' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'incompatible2' on 'Overloads': parameter 2\\"
            });
            args.push(curArg);
          }
      }
      return esValue[implSymbol].incompatible2(...args);
    }

    incompatible3(arg1) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'incompatible3' on 'Overloads': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      switch (arguments.length) {
        case 1:
          {
            let curArg = arguments[0];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'incompatible3' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
          break;
        case 2:
          {
            let curArg = arguments[0];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'incompatible3' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            if (curArg === undefined) {
              {
                let curArg = arguments[1];
                if (curArg !== undefined) {
                  curArg = URL.convert(curArg, {
                    context: \\"Failed to execute 'incompatible3' on 'Overloads': parameter 2\\"
                  });
                }
                args.push(curArg);
              }
            } else if (URL.is(curArg)) {
              {
                let curArg = arguments[1];
                if (curArg !== undefined) {
                  curArg = URL.convert(curArg, {
                    context: \\"Failed to execute 'incompatible3' on 'Overloads': parameter 2\\"
                  });
                }
                args.push(curArg);
              }
            } else if (utils.isArrayBuffer(curArg)) {
              {
                let curArg = arguments[1];
                if (utils.isArrayBuffer(curArg)) {
                } else if (ArrayBuffer.isView(curArg)) {
                } else {
                  throw new TypeError(
                    \\"Failed to execute 'incompatible3' on 'Overloads': parameter 2\\" + \\" is not of any supported type.\\"
                  );
                }
                args.push(curArg);
              }
            } else if (ArrayBuffer.isView(curArg)) {
              {
                let curArg = arguments[1];
                if (utils.isArrayBuffer(curArg)) {
                } else if (ArrayBuffer.isView(curArg)) {
                } else {
                  throw new TypeError(
                    \\"Failed to execute 'incompatible3' on 'Overloads': parameter 2\\" + \\" is not of any supported type.\\"
                  );
                }
                args.push(curArg);
              }
            } else {
              {
                let curArg = arguments[1];
                curArg = conversions[\\"DOMString\\"](curArg, {
                  context: \\"Failed to execute 'incompatible3' on 'Overloads': parameter 2\\"
                });
                args.push(curArg);
              }
            }
          }
          break;
        case 3:
          throw new TypeError(
            \\"Failed to execute 'incompatible3' on 'Overloads': only \\" + arguments.length + \\" arguments present.\\"
          );
          break;
        default:
          {
            let curArg = arguments[0];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'incompatible3' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            curArg = conversions[\\"long\\"](curArg, {
              context: \\"Failed to execute 'incompatible3' on 'Overloads': parameter 2\\"
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[2];
            if (utils.isArrayBuffer(curArg)) {
            } else if (ArrayBuffer.isView(curArg)) {
            } else {
              throw new TypeError(
                \\"Failed to execute 'incompatible3' on 'Overloads': parameter 3\\" + \\" is not of any supported type.\\"
              );
            }
            args.push(curArg);
          }
          {
            let curArg = arguments[3];
            if (utils.isArrayBuffer(curArg)) {
            } else if (ArrayBuffer.isView(curArg)) {
            } else {
              throw new TypeError(
                \\"Failed to execute 'incompatible3' on 'Overloads': parameter 4\\" + \\" is not of any supported type.\\"
              );
            }
            args.push(curArg);
          }
      }
      return esValue[implSymbol].incompatible3(...args);
    }
  }
  Object.defineProperties(Overloads.prototype, {
    compatible: { enumerable: true },
    incompatible1: { enumerable: true },
    incompatible2: { enumerable: true },
    incompatible3: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"Overloads\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = Overloads;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: Overloads
  });
};

const Impl = require(\\"../implementations/Overloads.js\\");
"
`;

exports[`with processors PromiseTypes.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"PromiseTypes\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'PromiseTypes'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"PromiseTypes\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor PromiseTypes is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {
  Object.defineProperties(
    wrapper,
    Object.getOwnPropertyDescriptors({
      unforgeablePromiseOperation() {
        try {
          const esValue = this !== null && this !== undefined ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new TypeError(\\"Illegal invocation\\");
          }

          return utils.tryWrapperForImpl(esValue[implSymbol].unforgeablePromiseOperation());
        } catch (e) {
          return Promise.reject(e);
        }
      },
      get unforgeablePromiseAttribute() {
        try {
          const esValue = this !== null && this !== undefined ? this : globalObject;

          if (!exports.is(esValue)) {
            throw new TypeError(\\"Illegal invocation\\");
          }

          return utils.tryWrapperForImpl(esValue[implSymbol][\\"unforgeablePromiseAttribute\\"]);
        } catch (e) {
          return Promise.reject(e);
        }
      }
    })
  );

  Object.defineProperties(wrapper, {
    unforgeablePromiseOperation: { configurable: false, writable: false },
    unforgeablePromiseAttribute: { configurable: false }
  });
};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class PromiseTypes {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    voidPromiseConsumer(p) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'voidPromiseConsumer' on 'PromiseTypes': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = Promise.resolve(curArg).then(
          value => {},
          reason => reason
        );
        args.push(curArg);
      }
      return esValue[implSymbol].voidPromiseConsumer(...args);
    }

    promiseConsumer(p) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'promiseConsumer' on 'PromiseTypes': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = Promise.resolve(curArg).then(
          value => {
            value = conversions[\\"double\\"](value, {
              context: \\"Failed to execute 'promiseConsumer' on 'PromiseTypes': parameter 1\\" + \\" promise value\\"
            });

            return value;
          },
          reason => reason
        );
        args.push(curArg);
      }
      return esValue[implSymbol].promiseConsumer(...args);
    }

    promiseOperation() {
      try {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return utils.tryWrapperForImpl(esValue[implSymbol].promiseOperation());
      } catch (e) {
        return Promise.reject(e);
      }
    }

    get promiseAttribute() {
      try {
        const esValue = this !== null && this !== undefined ? this : globalObject;

        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return utils.tryWrapperForImpl(esValue[implSymbol][\\"promiseAttribute\\"]);
      } catch (e) {
        return Promise.reject(e);
      }
    }

    static staticPromiseOperation() {
      try {
        return utils.tryWrapperForImpl(Impl.implementation.staticPromiseOperation());
      } catch (e) {
        return Promise.reject(e);
      }
    }

    static get staticPromiseAttribute() {
      try {
        const esValue = this !== null && this !== undefined ? this : globalObject;

        return Impl.implementation[\\"staticPromiseAttribute\\"];
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }
  Object.defineProperties(PromiseTypes.prototype, {
    voidPromiseConsumer: { enumerable: true },
    promiseConsumer: { enumerable: true },
    promiseOperation: { enumerable: true },
    promiseAttribute: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"PromiseTypes\\", configurable: true }
  });
  Object.defineProperties(PromiseTypes, {
    staticPromiseOperation: { enumerable: true },
    staticPromiseAttribute: { enumerable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = PromiseTypes;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: PromiseTypes
  });
};

const Impl = require(\\"../implementations/PromiseTypes.js\\");
"
`;

exports[`with processors Reflect.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const whatwg_url = require(\\"whatwg-url\\");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"Reflect\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'Reflect'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"Reflect\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor Reflect is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class Reflect {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    get reflectedBoolean() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol].hasAttributeNS(null, \\"reflectedboolean\\");
    }

    set reflectedBoolean(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"boolean\\"](V, {
        context: \\"Failed to set the 'reflectedBoolean' property on 'Reflect': The provided value\\"
      });

      if (V) {
        esValue[implSymbol].setAttributeNS(null, \\"reflectedboolean\\", \\"\\");
      } else {
        esValue[implSymbol].removeAttributeNS(null, \\"reflectedboolean\\");
      }
    }

    get reflectedDOMString() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      const value = esValue[implSymbol].getAttributeNS(null, \\"reflecteddomstring\\");
      return value === null ? \\"\\" : value;
    }

    set reflectedDOMString(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"DOMString\\"](V, {
        context: \\"Failed to set the 'reflectedDOMString' property on 'Reflect': The provided value\\"
      });

      esValue[implSymbol].setAttributeNS(null, \\"reflecteddomstring\\", V);
    }

    get reflectedLong() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      const value = parseInt(esValue[implSymbol].getAttributeNS(null, \\"reflectedlong\\"));
      return isNaN(value) || value < -2147483648 || value > 2147483647 ? 0 : value;
    }

    set reflectedLong(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"long\\"](V, {
        context: \\"Failed to set the 'reflectedLong' property on 'Reflect': The provided value\\"
      });

      esValue[implSymbol].setAttributeNS(null, \\"reflectedlong\\", String(V));
    }

    get reflectedUnsignedLong() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      const value = parseInt(esValue[implSymbol].getAttributeNS(null, \\"reflectedunsignedlong\\"));
      return isNaN(value) || value < 0 || value > 2147483647 ? 0 : value;
    }

    set reflectedUnsignedLong(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"unsigned long\\"](V, {
        context: \\"Failed to set the 'reflectedUnsignedLong' property on 'Reflect': The provided value\\"
      });

      esValue[implSymbol].setAttributeNS(null, \\"reflectedunsignedlong\\", String(V > 2147483647 ? 0 : V));
    }

    get reflectedUSVStringURL() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      const value = esValue[implSymbol].getAttributeNS(null, \\"reflectedusvstringurl\\");
      if (value === null) {
        return \\"\\";
      }
      const urlRecord = whatwg_url.parseURL(value, { baseURL: \\"http://localhost:8080/\\" });
      return urlRecord === null ? conversions.USVString(value) : whatwg_url.serializeURL(urlRecord);
    }

    set reflectedUSVStringURL(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, {
        context: \\"Failed to set the 'reflectedUSVStringURL' property on 'Reflect': The provided value\\"
      });

      esValue[implSymbol].setAttributeNS(null, \\"reflectedusvstringurl\\", V);
    }

    get reflectionTest() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      const value = esValue[implSymbol].getAttributeNS(null, \\"reflection\\");
      return value === null ? \\"\\" : value;
    }

    set reflectionTest(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"DOMString\\"](V, {
        context: \\"Failed to set the 'reflectionTest' property on 'Reflect': The provided value\\"
      });

      esValue[implSymbol].setAttributeNS(null, \\"reflection\\", V);
    }

    get withUnderscore() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      const value = esValue[implSymbol].getAttributeNS(null, \\"with-underscore\\");
      return value === null ? \\"\\" : value;
    }

    set withUnderscore(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"DOMString\\"](V, {
        context: \\"Failed to set the 'withUnderscore' property on 'Reflect': The provided value\\"
      });

      esValue[implSymbol].setAttributeNS(null, \\"with-underscore\\", V);
    }
  }
  Object.defineProperties(Reflect.prototype, {
    reflectedBoolean: { enumerable: true },
    reflectedDOMString: { enumerable: true },
    reflectedLong: { enumerable: true },
    reflectedUnsignedLong: { enumerable: true },
    reflectedUSVStringURL: { enumerable: true },
    reflectionTest: { enumerable: true },
    withUnderscore: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"Reflect\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = Reflect;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: Reflect
  });
};

const Impl = require(\\"../implementations/Reflect.js\\");
"
`;

exports[`with processors Replaceable.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"Replaceable\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'Replaceable'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"Replaceable\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor Replaceable is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class Replaceable {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    get replaceable() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"replaceable\\"];
    }

    set replaceable(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      Object.defineProperty(esValue, \\"replaceable\\", {
        configurable: true,
        enumerable: true,
        value: V,
        writable: true
      });
    }
  }
  Object.defineProperties(Replaceable.prototype, {
    replaceable: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"Replaceable\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = Replaceable;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: Replaceable
  });
};

const Impl = require(\\"../implementations/Replaceable.js\\");
"
`;

exports[`with processors RequestDestination.webidl 1`] = `
"\\"use strict\\";

const enumerationValues = new Set([
  \\"\\",
  \\"audio\\",
  \\"document\\",
  \\"embed\\",
  \\"font\\",
  \\"image\\",
  \\"manifest\\",
  \\"object\\",
  \\"report\\",
  \\"script\\",
  \\"sharedworker\\",
  \\"style\\",
  \\"track\\",
  \\"video\\",
  \\"worker\\",
  \\"xslt\\"
]);
exports.enumerationValues = enumerationValues;

exports.convert = function convert(value, { context = \\"The provided value\\" } = {}) {
  const string = \`\${value}\`;
  if (!enumerationValues.has(string)) {
    throw new TypeError(\`\${context} '\${string}' is not a valid enumeration value for RequestDestination\`);
  }
  return string;
};
"
`;

exports[`with processors SeqAndRec.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const URL = require(\\"./URL.js\\");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"SeqAndRec\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'SeqAndRec'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"SeqAndRec\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor SeqAndRec is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class SeqAndRec {
    constructor() {
      return exports.setup(Object.create(new.target.prototype), globalObject, undefined);
    }

    recordConsumer(rec) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'recordConsumer' on 'SeqAndRec': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (!utils.isObject(curArg)) {
          throw new TypeError(\\"Failed to execute 'recordConsumer' on 'SeqAndRec': parameter 1\\" + \\" is not an object.\\");
        } else {
          const result = Object.create(null);
          for (const key of Reflect.ownKeys(curArg)) {
            const desc = Object.getOwnPropertyDescriptor(curArg, key);
            if (desc && desc.enumerable) {
              let typedKey = key;

              typedKey = conversions[\\"USVString\\"](typedKey, {
                context: \\"Failed to execute 'recordConsumer' on 'SeqAndRec': parameter 1\\" + \\"'s key\\"
              });

              let typedValue = curArg[key];

              typedValue = conversions[\\"double\\"](typedValue, {
                context: \\"Failed to execute 'recordConsumer' on 'SeqAndRec': parameter 1\\" + \\"'s value\\"
              });

              result[typedKey] = typedValue;
            }
          }
          curArg = result;
        }
        args.push(curArg);
      }
      return esValue[implSymbol].recordConsumer(...args);
    }

    recordConsumer2(rec) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'recordConsumer2' on 'SeqAndRec': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (!utils.isObject(curArg)) {
          throw new TypeError(\\"Failed to execute 'recordConsumer2' on 'SeqAndRec': parameter 1\\" + \\" is not an object.\\");
        } else {
          const result = Object.create(null);
          for (const key of Reflect.ownKeys(curArg)) {
            const desc = Object.getOwnPropertyDescriptor(curArg, key);
            if (desc && desc.enumerable) {
              let typedKey = key;

              typedKey = conversions[\\"USVString\\"](typedKey, {
                context: \\"Failed to execute 'recordConsumer2' on 'SeqAndRec': parameter 1\\" + \\"'s key\\"
              });

              let typedValue = curArg[key];

              typedValue = URL.convert(typedValue, {
                context: \\"Failed to execute 'recordConsumer2' on 'SeqAndRec': parameter 1\\" + \\"'s value\\"
              });

              result[typedKey] = typedValue;
            }
          }
          curArg = result;
        }
        args.push(curArg);
      }
      return esValue[implSymbol].recordConsumer2(...args);
    }

    sequenceConsumer(seq) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'sequenceConsumer' on 'SeqAndRec': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (!utils.isObject(curArg)) {
          throw new TypeError(
            \\"Failed to execute 'sequenceConsumer' on 'SeqAndRec': parameter 1\\" + \\" is not an iterable object.\\"
          );
        } else {
          const V = [];
          const tmp = curArg;
          for (let nextItem of tmp) {
            nextItem = conversions[\\"USVString\\"](nextItem, {
              context: \\"Failed to execute 'sequenceConsumer' on 'SeqAndRec': parameter 1\\" + \\"'s element\\"
            });

            V.push(nextItem);
          }
          curArg = V;
        }
        args.push(curArg);
      }
      return esValue[implSymbol].sequenceConsumer(...args);
    }

    sequenceConsumer2(seq) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'sequenceConsumer2' on 'SeqAndRec': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (!utils.isObject(curArg)) {
          throw new TypeError(
            \\"Failed to execute 'sequenceConsumer2' on 'SeqAndRec': parameter 1\\" + \\" is not an iterable object.\\"
          );
        } else {
          const V = [];
          const tmp = curArg;
          for (let nextItem of tmp) {
            nextItem = utils.tryImplForWrapper(nextItem);

            V.push(nextItem);
          }
          curArg = V;
        }
        args.push(curArg);
      }
      return esValue[implSymbol].sequenceConsumer2(...args);
    }

    frozenArrayConsumer(arr) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'frozenArrayConsumer' on 'SeqAndRec': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (!utils.isObject(curArg)) {
          throw new TypeError(
            \\"Failed to execute 'frozenArrayConsumer' on 'SeqAndRec': parameter 1\\" + \\" is not an iterable object.\\"
          );
        } else {
          const V = [];
          const tmp = curArg;
          for (let nextItem of tmp) {
            nextItem = conversions[\\"double\\"](nextItem, {
              context: \\"Failed to execute 'frozenArrayConsumer' on 'SeqAndRec': parameter 1\\" + \\"'s element\\"
            });

            V.push(nextItem);
          }
          curArg = V;
        }
        curArg = Object.freeze(curArg);
        args.push(curArg);
      }
      return esValue[implSymbol].frozenArrayConsumer(...args);
    }
  }
  Object.defineProperties(SeqAndRec.prototype, {
    recordConsumer: { enumerable: true },
    recordConsumer2: { enumerable: true },
    sequenceConsumer: { enumerable: true },
    sequenceConsumer2: { enumerable: true },
    frozenArrayConsumer: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"SeqAndRec\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = SeqAndRec;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: SeqAndRec
  });
};

const Impl = require(\\"../implementations/SeqAndRec.js\\");
"
`;

exports[`with processors Static.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"Static\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'Static'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"Static\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor Static is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class Static {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    def() {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol].def();
    }

    get abc() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"abc\\"];
    }

    set abc(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"DOMString\\"](V, { context: \\"Failed to set the 'abc' property on 'Static': The provided value\\" });

      esValue[implSymbol][\\"abc\\"] = V;
    }

    static def() {
      return Impl.implementation.def();
    }

    static get abc() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      return Impl.implementation[\\"abc\\"];
    }

    static set abc(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      return Impl.implementation[\\"abc\\"];
    }
  }
  Object.defineProperties(Static.prototype, {
    def: { enumerable: true },
    abc: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"Static\\", configurable: true }
  });
  Object.defineProperties(Static, { def: { enumerable: true }, abc: { enumerable: true } });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = Static;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: Static
  });
};

const Impl = require(\\"../implementations/Static.js\\");
"
`;

exports[`with processors Storage.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"Storage\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'Storage'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"Storage\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor Storage is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper = new Proxy(wrapper, proxyHandler);

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper = new Proxy(wrapper, proxyHandler);

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class Storage {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    key(index) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'key' on 'Storage': 1 argument required, but only \\" + arguments.length + \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"unsigned long\\"](curArg, { context: \\"Failed to execute 'key' on 'Storage': parameter 1\\" });
        args.push(curArg);
      }
      return esValue[implSymbol].key(...args);
    }

    getItem(key) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'getItem' on 'Storage': 1 argument required, but only \\" + arguments.length + \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"DOMString\\"](curArg, { context: \\"Failed to execute 'getItem' on 'Storage': parameter 1\\" });
        args.push(curArg);
      }
      return esValue[implSymbol].getItem(...args);
    }

    setItem(key, value) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 2) {
        throw new TypeError(
          \\"Failed to execute 'setItem' on 'Storage': 2 arguments required, but only \\" + arguments.length + \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"DOMString\\"](curArg, { context: \\"Failed to execute 'setItem' on 'Storage': parameter 1\\" });
        args.push(curArg);
      }
      {
        let curArg = arguments[1];
        curArg = conversions[\\"DOMString\\"](curArg, { context: \\"Failed to execute 'setItem' on 'Storage': parameter 2\\" });
        args.push(curArg);
      }
      return esValue[implSymbol].setItem(...args);
    }

    removeItem(key) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'removeItem' on 'Storage': 1 argument required, but only \\" + arguments.length + \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'removeItem' on 'Storage': parameter 1\\"
        });
        args.push(curArg);
      }
      return esValue[implSymbol].removeItem(...args);
    }

    clear() {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol].clear();
    }

    get length() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"length\\"];
    }
  }
  Object.defineProperties(Storage.prototype, {
    key: { enumerable: true },
    getItem: { enumerable: true },
    setItem: { enumerable: true },
    removeItem: { enumerable: true },
    clear: { enumerable: true },
    length: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"Storage\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = Storage;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: Storage
  });
};

const proxyHandler = {
  get(target, P, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.get(target, P, receiver);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc === undefined) {
      const parent = Object.getPrototypeOf(target);
      if (parent === null) {
        return undefined;
      }
      return Reflect.get(target, P, receiver);
    }
    if (!desc.get && !desc.set) {
      return desc.value;
    }
    const getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return Reflect.apply(getter, receiver, []);
  },

  has(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.has(target, P);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc !== undefined) {
      return true;
    }
    const parent = Object.getPrototypeOf(target);
    if (parent !== null) {
      return Reflect.has(parent, P);
    }
    return false;
  },

  ownKeys(target) {
    const keys = new Set();

    for (const key of target[implSymbol][utils.supportedPropertyNames]) {
      if (!(key in target)) {
        keys.add(\`\${key}\`);
      }
    }

    for (const key of Reflect.ownKeys(target)) {
      keys.add(key);
    }
    return [...keys];
  },

  getOwnPropertyDescriptor(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.getOwnPropertyDescriptor(target, P);
    }
    let ignoreNamedProps = false;

    if (target[implSymbol][utils.supportsPropertyName](P) && !(P in target) && !ignoreNamedProps) {
      const namedValue = target[implSymbol].getItem(P);

      return {
        writable: true,
        enumerable: true,
        configurable: true,
        value: utils.tryWrapperForImpl(namedValue)
      };
    }

    return Reflect.getOwnPropertyDescriptor(target, P);
  },

  set(target, P, V, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.set(target, P, V, receiver);
    }
    if (target === receiver) {
      if (typeof P === \\"string\\" && !utils.isArrayIndexPropName(P)) {
        let namedValue = V;

        namedValue = conversions[\\"DOMString\\"](namedValue, {
          context: \\"Failed to set the '\\" + P + \\"' property on 'Storage': The provided value\\"
        });

        target[implSymbol].setItem(P, namedValue);

        return true;
      }
    }
    let ownDesc;

    if (ownDesc === undefined) {
      ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
    }
    if (ownDesc === undefined) {
      const parent = Reflect.getPrototypeOf(target);
      if (parent !== null) {
        return Reflect.set(parent, P, V, receiver);
      }
      ownDesc = { writable: true, enumerable: true, configurable: true, value: undefined };
    }
    if (!ownDesc.writable) {
      return false;
    }
    if (!utils.isObject(receiver)) {
      return false;
    }
    const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
    let valueDesc;
    if (existingDesc !== undefined) {
      if (existingDesc.get || existingDesc.set) {
        return false;
      }
      if (!existingDesc.writable) {
        return false;
      }
      valueDesc = { value: V };
    } else {
      valueDesc = { writable: true, enumerable: true, configurable: true, value: V };
    }
    return Reflect.defineProperty(receiver, P, valueDesc);
  },

  defineProperty(target, P, desc) {
    if (typeof P === \\"symbol\\") {
      return Reflect.defineProperty(target, P, desc);
    }
    if (!utils.hasOwn(target, P)) {
      if (desc.get || desc.set) {
        return false;
      }

      let namedValue = desc.value;

      namedValue = conversions[\\"DOMString\\"](namedValue, {
        context: \\"Failed to set the '\\" + P + \\"' property on 'Storage': The provided value\\"
      });

      target[implSymbol].setItem(P, namedValue);

      return true;
    }
    return Reflect.defineProperty(target, P, desc);
  },

  deleteProperty(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.deleteProperty(target, P);
    }

    if (target[implSymbol][utils.supportsPropertyName](P) && !(P in target)) {
      target[implSymbol].removeItem(P);
      return true;
    }

    return Reflect.deleteProperty(target, P);
  },

  preventExtensions() {
    return false;
  }
};

const Impl = require(\\"../implementations/Storage.js\\");
"
`;

exports[`with processors StringifierAttribute.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"StringifierAttribute\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'StringifierAttribute'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"StringifierAttribute\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor StringifierAttribute is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class StringifierAttribute {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    get attr() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"attr\\"];
    }

    toString() {
      const esValue = this;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"attr\\"];
    }
  }
  Object.defineProperties(StringifierAttribute.prototype, {
    attr: { enumerable: true },
    toString: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"StringifierAttribute\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = StringifierAttribute;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: StringifierAttribute
  });
};

const Impl = require(\\"../implementations/StringifierAttribute.js\\");
"
`;

exports[`with processors StringifierDefaultOperation.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"StringifierDefaultOperation\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'StringifierDefaultOperation'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"StringifierDefaultOperation\\"];
  if (ctor === undefined) {
    throw new Error(
      \\"Internal error: constructor StringifierDefaultOperation is not installed on the passed global object\\"
    );
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class StringifierDefaultOperation {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    toString() {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol].toString();
    }
  }
  Object.defineProperties(StringifierDefaultOperation.prototype, {
    toString: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"StringifierDefaultOperation\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = StringifierDefaultOperation;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: StringifierDefaultOperation
  });
};

const Impl = require(\\"../implementations/StringifierDefaultOperation.js\\");
"
`;

exports[`with processors StringifierNamedOperation.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"StringifierNamedOperation\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'StringifierNamedOperation'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"StringifierNamedOperation\\"];
  if (ctor === undefined) {
    throw new Error(
      \\"Internal error: constructor StringifierNamedOperation is not installed on the passed global object\\"
    );
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class StringifierNamedOperation {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    operation() {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol].operation();
    }

    toString() {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol].operation();
    }
  }
  Object.defineProperties(StringifierNamedOperation.prototype, {
    operation: { enumerable: true },
    toString: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"StringifierNamedOperation\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = StringifierNamedOperation;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: StringifierNamedOperation
  });
};

const Impl = require(\\"../implementations/StringifierNamedOperation.js\\");
"
`;

exports[`with processors StringifierOperation.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"StringifierOperation\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'StringifierOperation'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"StringifierOperation\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor StringifierOperation is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class StringifierOperation {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    toString() {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol].toString();
    }
  }
  Object.defineProperties(StringifierOperation.prototype, {
    toString: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"StringifierOperation\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = StringifierOperation;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: StringifierOperation
  });
};

const Impl = require(\\"../implementations/StringifierOperation.js\\");
"
`;

exports[`with processors TypedefsAndUnions.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const RequestDestination = require(\\"./RequestDestination.js\\");
const URL = require(\\"./URL.js\\");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"TypedefsAndUnions\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'TypedefsAndUnions'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"TypedefsAndUnions\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor TypedefsAndUnions is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class TypedefsAndUnions {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    numOrStrConsumer(a) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'numOrStrConsumer' on 'TypedefsAndUnions': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (typeof curArg === \\"number\\") {
          curArg = conversions[\\"double\\"](curArg, {
            context: \\"Failed to execute 'numOrStrConsumer' on 'TypedefsAndUnions': parameter 1\\",
            clamp: true
          });
        } else {
          curArg = conversions[\\"DOMString\\"](curArg, {
            context: \\"Failed to execute 'numOrStrConsumer' on 'TypedefsAndUnions': parameter 1\\"
          });
        }
        args.push(curArg);
      }
      return esValue[implSymbol].numOrStrConsumer(...args);
    }

    numOrEnumConsumer(a) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'numOrEnumConsumer' on 'TypedefsAndUnions': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg === null || curArg === undefined) {
          curArg = null;
        } else {
          if (typeof curArg === \\"number\\") {
            curArg = conversions[\\"double\\"](curArg, {
              context: \\"Failed to execute 'numOrEnumConsumer' on 'TypedefsAndUnions': parameter 1\\"
            });
          } else {
            curArg = RequestDestination.convert(curArg, {
              context: \\"Failed to execute 'numOrEnumConsumer' on 'TypedefsAndUnions': parameter 1\\"
            });
          }
        }
        args.push(curArg);
      }
      return esValue[implSymbol].numOrEnumConsumer(...args);
    }

    numOrStrOrNullConsumer(a) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'numOrStrOrNullConsumer' on 'TypedefsAndUnions': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg === null || curArg === undefined) {
          curArg = null;
        } else {
          if (typeof curArg === \\"number\\") {
            curArg = conversions[\\"double\\"](curArg, {
              context: \\"Failed to execute 'numOrStrOrNullConsumer' on 'TypedefsAndUnions': parameter 1\\",
              clamp: true,
              enforceRange: true
            });
          } else {
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'numOrStrOrNullConsumer' on 'TypedefsAndUnions': parameter 1\\",
              enforceRange: true
            });
          }
        }
        args.push(curArg);
      }
      return esValue[implSymbol].numOrStrOrNullConsumer(...args);
    }

    numOrStrOrURLOrNullConsumer(a) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'numOrStrOrURLOrNullConsumer' on 'TypedefsAndUnions': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg === null || curArg === undefined) {
          curArg = null;
        } else {
          if (URL.is(curArg)) {
            curArg = utils.implForWrapper(curArg);
          } else if (typeof curArg === \\"number\\") {
            curArg = conversions[\\"double\\"](curArg, {
              context: \\"Failed to execute 'numOrStrOrURLOrNullConsumer' on 'TypedefsAndUnions': parameter 1\\",
              clamp: true,
              enforceRange: true
            });
          } else {
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'numOrStrOrURLOrNullConsumer' on 'TypedefsAndUnions': parameter 1\\",
              enforceRange: true
            });
          }
        }
        args.push(curArg);
      }
      return esValue[implSymbol].numOrStrOrURLOrNullConsumer(...args);
    }

    urlMapInnerConsumer(a) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'urlMapInnerConsumer' on 'TypedefsAndUnions': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (!utils.isObject(curArg)) {
          throw new TypeError(
            \\"Failed to execute 'urlMapInnerConsumer' on 'TypedefsAndUnions': parameter 1\\" + \\" is not an object.\\"
          );
        } else {
          const result = Object.create(null);
          for (const key of Reflect.ownKeys(curArg)) {
            const desc = Object.getOwnPropertyDescriptor(curArg, key);
            if (desc && desc.enumerable) {
              let typedKey = key;

              typedKey = conversions[\\"USVString\\"](typedKey, {
                context: \\"Failed to execute 'urlMapInnerConsumer' on 'TypedefsAndUnions': parameter 1\\" + \\"'s key\\"
              });

              let typedValue = curArg[key];

              typedValue = URL.convert(typedValue, {
                context: \\"Failed to execute 'urlMapInnerConsumer' on 'TypedefsAndUnions': parameter 1\\" + \\"'s value\\"
              });

              result[typedKey] = typedValue;
            }
          }
          curArg = result;
        }
        args.push(curArg);
      }
      return esValue[implSymbol].urlMapInnerConsumer(...args);
    }

    urlMapConsumer(a) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'urlMapConsumer' on 'TypedefsAndUnions': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg === null || curArg === undefined) {
          curArg = null;
        } else {
          if (!utils.isObject(curArg)) {
            throw new TypeError(
              \\"Failed to execute 'urlMapConsumer' on 'TypedefsAndUnions': parameter 1\\" + \\" is not an object.\\"
            );
          } else {
            const result = Object.create(null);
            for (const key of Reflect.ownKeys(curArg)) {
              const desc = Object.getOwnPropertyDescriptor(curArg, key);
              if (desc && desc.enumerable) {
                let typedKey = key;

                typedKey = conversions[\\"USVString\\"](typedKey, {
                  context: \\"Failed to execute 'urlMapConsumer' on 'TypedefsAndUnions': parameter 1\\" + \\"'s key\\"
                });

                let typedValue = curArg[key];

                typedValue = URL.convert(typedValue, {
                  context: \\"Failed to execute 'urlMapConsumer' on 'TypedefsAndUnions': parameter 1\\" + \\"'s value\\"
                });

                result[typedKey] = typedValue;
              }
            }
            curArg = result;
          }
        }
        args.push(curArg);
      }
      return esValue[implSymbol].urlMapConsumer(...args);
    }

    bufferSourceOrURLConsumer(b) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'bufferSourceOrURLConsumer' on 'TypedefsAndUnions': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (URL.is(curArg)) {
          curArg = utils.implForWrapper(curArg);
        } else if (utils.isArrayBuffer(curArg)) {
        } else if (ArrayBuffer.isView(curArg)) {
        } else {
          throw new TypeError(
            \\"Failed to execute 'bufferSourceOrURLConsumer' on 'TypedefsAndUnions': parameter 1\\" +
              \\" is not of any supported type.\\"
          );
        }
        args.push(curArg);
      }
      return esValue[implSymbol].bufferSourceOrURLConsumer(...args);
    }

    arrayBufferViewOrURLMapConsumer(b) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'arrayBufferViewOrURLMapConsumer' on 'TypedefsAndUnions': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg === null || curArg === undefined) {
          curArg = null;
        } else {
          if (ArrayBuffer.isView(curArg)) {
          } else if (utils.isObject(curArg)) {
            if (!utils.isObject(curArg)) {
              throw new TypeError(
                \\"Failed to execute 'arrayBufferViewOrURLMapConsumer' on 'TypedefsAndUnions': parameter 1\\" +
                  \\" record\\" +
                  \\" is not an object.\\"
              );
            } else {
              const result = Object.create(null);
              for (const key of Reflect.ownKeys(curArg)) {
                const desc = Object.getOwnPropertyDescriptor(curArg, key);
                if (desc && desc.enumerable) {
                  let typedKey = key;

                  typedKey = conversions[\\"USVString\\"](typedKey, {
                    context:
                      \\"Failed to execute 'arrayBufferViewOrURLMapConsumer' on 'TypedefsAndUnions': parameter 1\\" +
                      \\" record\\" +
                      \\"'s key\\"
                  });

                  let typedValue = curArg[key];

                  typedValue = URL.convert(typedValue, {
                    context:
                      \\"Failed to execute 'arrayBufferViewOrURLMapConsumer' on 'TypedefsAndUnions': parameter 1\\" +
                      \\" record\\" +
                      \\"'s value\\"
                  });

                  result[typedKey] = typedValue;
                }
              }
              curArg = result;
            }
          } else {
            throw new TypeError(
              \\"Failed to execute 'arrayBufferViewOrURLMapConsumer' on 'TypedefsAndUnions': parameter 1\\" +
                \\" is not of any supported type.\\"
            );
          }
        }
        args.push(curArg);
      }
      return esValue[implSymbol].arrayBufferViewOrURLMapConsumer(...args);
    }

    arrayBufferViewDupConsumer(b) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'arrayBufferViewDupConsumer' on 'TypedefsAndUnions': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (ArrayBuffer.isView(curArg)) {
        } else {
          throw new TypeError(
            \\"Failed to execute 'arrayBufferViewDupConsumer' on 'TypedefsAndUnions': parameter 1\\" +
              \\" is not of any supported type.\\"
          );
        }
        args.push(curArg);
      }
      return esValue[implSymbol].arrayBufferViewDupConsumer(...args);
    }

    get buf() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][\\"buf\\"]);
    }

    set buf(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (utils.isArrayBuffer(V)) {
      } else if (
        ArrayBuffer.isView(V) &&
        (V.constructor.name === \\"Uint8Array\\" || V.constructor.name === \\"Uint16Array\\")
      ) {
      } else {
        throw new TypeError(
          \\"Failed to set the 'buf' property on 'TypedefsAndUnions': The provided value\\" +
            \\" is not of any supported type.\\"
        );
      }
      esValue[implSymbol][\\"buf\\"] = V;
    }

    get time() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"time\\"];
    }

    set time(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"unsigned long long\\"](V, {
        context: \\"Failed to set the 'time' property on 'TypedefsAndUnions': The provided value\\"
      });

      esValue[implSymbol][\\"time\\"] = V;
    }
  }
  Object.defineProperties(TypedefsAndUnions.prototype, {
    numOrStrConsumer: { enumerable: true },
    numOrEnumConsumer: { enumerable: true },
    numOrStrOrNullConsumer: { enumerable: true },
    numOrStrOrURLOrNullConsumer: { enumerable: true },
    urlMapInnerConsumer: { enumerable: true },
    urlMapConsumer: { enumerable: true },
    bufferSourceOrURLConsumer: { enumerable: true },
    arrayBufferViewOrURLMapConsumer: { enumerable: true },
    arrayBufferViewDupConsumer: { enumerable: true },
    buf: { enumerable: true },
    time: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"TypedefsAndUnions\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = TypedefsAndUnions;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: TypedefsAndUnions
  });
};

const Impl = require(\\"../implementations/TypedefsAndUnions.js\\");
"
`;

exports[`with processors URL.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"URL\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'URL'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"URL\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor URL is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\", \\"Worker\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class URL {
    constructor(url) {
      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to construct 'URL': 1 argument required, but only \\" + arguments.length + \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"USVString\\"](curArg, { context: \\"Failed to construct 'URL': parameter 1\\" });
        args.push(curArg);
      }
      {
        let curArg = arguments[1];
        if (curArg !== undefined) {
          curArg = conversions[\\"USVString\\"](curArg, { context: \\"Failed to construct 'URL': parameter 2\\" });
        }
        args.push(curArg);
      }
      return exports.setup(Object.create(new.target.prototype), globalObject, args);
    }

    toJSON() {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol].toJSON();
    }

    get href() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"href\\"];
    }

    set href(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, { context: \\"Failed to set the 'href' property on 'URL': The provided value\\" });

      esValue[implSymbol][\\"href\\"] = V;
    }

    toString() {
      const esValue = this;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"href\\"];
    }

    get origin() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"origin\\"];
    }

    get protocol() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"protocol\\"];
    }

    set protocol(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, {
        context: \\"Failed to set the 'protocol' property on 'URL': The provided value\\"
      });

      esValue[implSymbol][\\"protocol\\"] = V;
    }

    get username() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"username\\"];
    }

    set username(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, {
        context: \\"Failed to set the 'username' property on 'URL': The provided value\\"
      });

      esValue[implSymbol][\\"username\\"] = V;
    }

    get password() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"password\\"];
    }

    set password(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, {
        context: \\"Failed to set the 'password' property on 'URL': The provided value\\"
      });

      esValue[implSymbol][\\"password\\"] = V;
    }

    get host() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"host\\"];
    }

    set host(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, { context: \\"Failed to set the 'host' property on 'URL': The provided value\\" });

      esValue[implSymbol][\\"host\\"] = V;
    }

    get hostname() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"hostname\\"];
    }

    set hostname(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, {
        context: \\"Failed to set the 'hostname' property on 'URL': The provided value\\"
      });

      esValue[implSymbol][\\"hostname\\"] = V;
    }

    get port() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"port\\"];
    }

    set port(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, { context: \\"Failed to set the 'port' property on 'URL': The provided value\\" });

      esValue[implSymbol][\\"port\\"] = V;
    }

    get pathname() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"pathname\\"];
    }

    set pathname(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, {
        context: \\"Failed to set the 'pathname' property on 'URL': The provided value\\"
      });

      esValue[implSymbol][\\"pathname\\"] = V;
    }

    get search() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"search\\"];
    }

    set search(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, { context: \\"Failed to set the 'search' property on 'URL': The provided value\\" });

      esValue[implSymbol][\\"search\\"] = V;
    }

    get searchParams() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return utils.getSameObject(this, \\"searchParams\\", () => {
        return utils.tryWrapperForImpl(esValue[implSymbol][\\"searchParams\\"]);
      });
    }

    get hash() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"hash\\"];
    }

    set hash(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, { context: \\"Failed to set the 'hash' property on 'URL': The provided value\\" });

      esValue[implSymbol][\\"hash\\"] = V;
    }
  }
  Object.defineProperties(URL.prototype, {
    toJSON: { enumerable: true },
    href: { enumerable: true },
    toString: { enumerable: true },
    origin: { enumerable: true },
    protocol: { enumerable: true },
    username: { enumerable: true },
    password: { enumerable: true },
    host: { enumerable: true },
    hostname: { enumerable: true },
    port: { enumerable: true },
    pathname: { enumerable: true },
    search: { enumerable: true },
    searchParams: { enumerable: true },
    hash: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"URL\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = URL;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: URL
  });

  if (globalNames.includes(\\"Window\\")) {
    Object.defineProperty(globalObject, \\"webkitURL\\", {
      configurable: true,
      writable: true,
      value: URL
    });
  }
};

const Impl = require(\\"../implementations/URL.js\\");
"
`;

exports[`with processors URLList.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"URLList\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'URLList'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"URLList\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor URLList is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper = new Proxy(wrapper, proxyHandler);

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper = new Proxy(wrapper, proxyHandler);

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class URLList {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    item(index) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'item' on 'URLList': 1 argument required, but only \\" + arguments.length + \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"unsigned long\\"](curArg, {
          context: \\"Failed to execute 'item' on 'URLList': parameter 1\\"
        });
        args.push(curArg);
      }
      return utils.tryWrapperForImpl(esValue[implSymbol].item(...args));
    }

    get length() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"length\\"];
    }
  }
  Object.defineProperties(URLList.prototype, {
    item: { enumerable: true },
    length: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"URLList\\", configurable: true },
    [Symbol.iterator]: { value: Array.prototype[Symbol.iterator], configurable: true, writable: true },
    keys: { value: Array.prototype.keys, configurable: true, enumerable: true, writable: true },
    values: { value: Array.prototype[Symbol.iterator], configurable: true, enumerable: true, writable: true },
    entries: { value: Array.prototype.entries, configurable: true, enumerable: true, writable: true },
    forEach: { value: Array.prototype.forEach, configurable: true, enumerable: true, writable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = URLList;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: URLList
  });
};

const proxyHandler = {
  get(target, P, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.get(target, P, receiver);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc === undefined) {
      const parent = Object.getPrototypeOf(target);
      if (parent === null) {
        return undefined;
      }
      return Reflect.get(target, P, receiver);
    }
    if (!desc.get && !desc.set) {
      return desc.value;
    }
    const getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return Reflect.apply(getter, receiver, []);
  },

  has(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.has(target, P);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc !== undefined) {
      return true;
    }
    const parent = Object.getPrototypeOf(target);
    if (parent !== null) {
      return Reflect.has(parent, P);
    }
    return false;
  },

  ownKeys(target) {
    const keys = new Set();

    for (const key of target[implSymbol][utils.supportedPropertyIndices]) {
      keys.add(\`\${key}\`);
    }

    for (const key of Reflect.ownKeys(target)) {
      keys.add(key);
    }
    return [...keys];
  },

  getOwnPropertyDescriptor(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.getOwnPropertyDescriptor(target, P);
    }
    let ignoreNamedProps = false;

    if (utils.isArrayIndexPropName(P)) {
      const index = P >>> 0;

      if (target[implSymbol][utils.supportsPropertyIndex](index)) {
        const indexedValue = target[implSymbol].item(index);
        return {
          writable: false,
          enumerable: true,
          configurable: true,
          value: utils.tryWrapperForImpl(indexedValue)
        };
      }
      ignoreNamedProps = true;
    }

    return Reflect.getOwnPropertyDescriptor(target, P);
  },

  set(target, P, V, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.set(target, P, V, receiver);
    }
    if (target === receiver) {
      utils.isArrayIndexPropName(P);
    }
    let ownDesc;

    if (utils.isArrayIndexPropName(P)) {
      const index = P >>> 0;

      if (target[implSymbol][utils.supportsPropertyIndex](index)) {
        const indexedValue = target[implSymbol].item(index);
        ownDesc = {
          writable: false,
          enumerable: true,
          configurable: true,
          value: utils.tryWrapperForImpl(indexedValue)
        };
      }
    }

    if (ownDesc === undefined) {
      ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
    }
    if (ownDesc === undefined) {
      const parent = Reflect.getPrototypeOf(target);
      if (parent !== null) {
        return Reflect.set(parent, P, V, receiver);
      }
      ownDesc = { writable: true, enumerable: true, configurable: true, value: undefined };
    }
    if (!ownDesc.writable) {
      return false;
    }
    if (!utils.isObject(receiver)) {
      return false;
    }
    const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
    let valueDesc;
    if (existingDesc !== undefined) {
      if (existingDesc.get || existingDesc.set) {
        return false;
      }
      if (!existingDesc.writable) {
        return false;
      }
      valueDesc = { value: V };
    } else {
      valueDesc = { writable: true, enumerable: true, configurable: true, value: V };
    }
    return Reflect.defineProperty(receiver, P, valueDesc);
  },

  defineProperty(target, P, desc) {
    if (typeof P === \\"symbol\\") {
      return Reflect.defineProperty(target, P, desc);
    }

    if (utils.isArrayIndexPropName(P)) {
      return false;
    }

    return Reflect.defineProperty(target, P, desc);
  },

  deleteProperty(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.deleteProperty(target, P);
    }

    if (utils.isArrayIndexPropName(P)) {
      const index = P >>> 0;
      return !target[implSymbol][utils.supportsPropertyIndex](index);
    }

    return Reflect.deleteProperty(target, P);
  },

  preventExtensions() {
    return false;
  }
};

const Impl = require(\\"../implementations/URLList.js\\");
"
`;

exports[`with processors URLSearchParams.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"URLSearchParams\\";

const IteratorPrototype = Object.create(utils.IteratorPrototype, {
  next: {
    value: function next() {
      const internal = this[utils.iterInternalSymbol];
      const { target, kind, index } = internal;
      const values = Array.from(target[implSymbol]);
      const len = values.length;
      if (index >= len) {
        return { value: undefined, done: true };
      }

      const pair = values[index];
      internal.index = index + 1;
      const [key, value] = pair.map(utils.tryWrapperForImpl);

      let result;
      switch (kind) {
        case \\"key\\":
          result = key;
          break;
        case \\"value\\":
          result = value;
          break;
        case \\"key+value\\":
          result = [key, value];
          break;
      }
      return { value: result, done: false };
    },
    writable: true,
    enumerable: true,
    configurable: true
  },
  [Symbol.toStringTag]: {
    value: \\"URLSearchParams Iterator\\",
    configurable: true
  }
});

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'URLSearchParams'.\`);
};

exports.createDefaultIterator = (target, kind) => {
  const iterator = Object.create(IteratorPrototype);
  Object.defineProperty(iterator, utils.iterInternalSymbol, {
    value: { target, kind, index: 0 },
    configurable: true
  });
  return iterator;
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"URLSearchParams\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor URLSearchParams is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\", \\"Worker\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class URLSearchParams {
    constructor() {
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg !== undefined) {
          if (utils.isObject(curArg)) {
            if (curArg[Symbol.iterator] !== undefined) {
              if (!utils.isObject(curArg)) {
                throw new TypeError(
                  \\"Failed to construct 'URLSearchParams': parameter 1\\" + \\" sequence\\" + \\" is not an iterable object.\\"
                );
              } else {
                const V = [];
                const tmp = curArg;
                for (let nextItem of tmp) {
                  if (!utils.isObject(nextItem)) {
                    throw new TypeError(
                      \\"Failed to construct 'URLSearchParams': parameter 1\\" +
                        \\" sequence\\" +
                        \\"'s element\\" +
                        \\" is not an iterable object.\\"
                    );
                  } else {
                    const V = [];
                    const tmp = nextItem;
                    for (let nextItem of tmp) {
                      nextItem = conversions[\\"USVString\\"](nextItem, {
                        context:
                          \\"Failed to construct 'URLSearchParams': parameter 1\\" +
                          \\" sequence\\" +
                          \\"'s element\\" +
                          \\"'s element\\"
                      });

                      V.push(nextItem);
                    }
                    nextItem = V;
                  }

                  V.push(nextItem);
                }
                curArg = V;
              }
            } else {
              if (!utils.isObject(curArg)) {
                throw new TypeError(
                  \\"Failed to construct 'URLSearchParams': parameter 1\\" + \\" record\\" + \\" is not an object.\\"
                );
              } else {
                const result = Object.create(null);
                for (const key of Reflect.ownKeys(curArg)) {
                  const desc = Object.getOwnPropertyDescriptor(curArg, key);
                  if (desc && desc.enumerable) {
                    let typedKey = key;

                    typedKey = conversions[\\"USVString\\"](typedKey, {
                      context: \\"Failed to construct 'URLSearchParams': parameter 1\\" + \\" record\\" + \\"'s key\\"
                    });

                    let typedValue = curArg[key];

                    typedValue = conversions[\\"USVString\\"](typedValue, {
                      context: \\"Failed to construct 'URLSearchParams': parameter 1\\" + \\" record\\" + \\"'s value\\"
                    });

                    result[typedKey] = typedValue;
                  }
                }
                curArg = result;
              }
            }
          } else {
            curArg = conversions[\\"USVString\\"](curArg, {
              context: \\"Failed to construct 'URLSearchParams': parameter 1\\"
            });
          }
        } else {
          curArg = \\"\\";
        }
        args.push(curArg);
      }
      return exports.setup(Object.create(new.target.prototype), globalObject, args);
    }

    append(name, value) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 2) {
        throw new TypeError(
          \\"Failed to execute 'append' on 'URLSearchParams': 2 arguments required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"USVString\\"](curArg, {
          context: \\"Failed to execute 'append' on 'URLSearchParams': parameter 1\\"
        });
        args.push(curArg);
      }
      {
        let curArg = arguments[1];
        curArg = conversions[\\"USVString\\"](curArg, {
          context: \\"Failed to execute 'append' on 'URLSearchParams': parameter 2\\"
        });
        args.push(curArg);
      }
      return esValue[implSymbol].append(...args);
    }

    delete(name) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'delete' on 'URLSearchParams': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"USVString\\"](curArg, {
          context: \\"Failed to execute 'delete' on 'URLSearchParams': parameter 1\\"
        });
        args.push(curArg);
      }
      return esValue[implSymbol].delete(...args);
    }

    get(name) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'get' on 'URLSearchParams': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"USVString\\"](curArg, {
          context: \\"Failed to execute 'get' on 'URLSearchParams': parameter 1\\"
        });
        args.push(curArg);
      }
      return esValue[implSymbol].get(...args);
    }

    getAll(name) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'getAll' on 'URLSearchParams': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"USVString\\"](curArg, {
          context: \\"Failed to execute 'getAll' on 'URLSearchParams': parameter 1\\"
        });
        args.push(curArg);
      }
      return utils.tryWrapperForImpl(esValue[implSymbol].getAll(...args));
    }

    has(name) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'has' on 'URLSearchParams': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"USVString\\"](curArg, {
          context: \\"Failed to execute 'has' on 'URLSearchParams': parameter 1\\"
        });
        args.push(curArg);
      }
      return esValue[implSymbol].has(...args);
    }

    set(name, value) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 2) {
        throw new TypeError(
          \\"Failed to execute 'set' on 'URLSearchParams': 2 arguments required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"USVString\\"](curArg, {
          context: \\"Failed to execute 'set' on 'URLSearchParams': parameter 1\\"
        });
        args.push(curArg);
      }
      {
        let curArg = arguments[1];
        curArg = conversions[\\"USVString\\"](curArg, {
          context: \\"Failed to execute 'set' on 'URLSearchParams': parameter 2\\"
        });
        args.push(curArg);
      }
      return esValue[implSymbol].set(...args);
    }

    sort() {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol].sort();
    }

    toString() {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol].toString();
    }

    keys() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
      return exports.createDefaultIterator(this, \\"key\\");
    }

    values() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
      return exports.createDefaultIterator(this, \\"value\\");
    }

    entries() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
      return exports.createDefaultIterator(this, \\"key+value\\");
    }

    forEach(callback) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
      if (arguments.length < 1) {
        throw new TypeError(\\"Failed to execute 'forEach' on 'iterable': 1 argument required, \\" + \\"but only 0 present.\\");
      }
      if (typeof callback !== \\"function\\") {
        throw new TypeError(
          \\"Failed to execute 'forEach' on 'iterable': The callback provided \\" + \\"as parameter 1 is not a function.\\"
        );
      }
      const thisArg = arguments[1];
      let pairs = Array.from(this[implSymbol]);
      let i = 0;
      while (i < pairs.length) {
        const [key, value] = pairs[i].map(utils.tryWrapperForImpl);
        callback.call(thisArg, value, key, this);
        pairs = Array.from(this[implSymbol]);
        i++;
      }
    }
  }
  Object.defineProperties(URLSearchParams.prototype, {
    append: { enumerable: true },
    delete: { enumerable: true },
    get: { enumerable: true },
    getAll: { enumerable: true },
    has: { enumerable: true },
    set: { enumerable: true },
    sort: { enumerable: true },
    toString: { enumerable: true },
    keys: { enumerable: true },
    values: { enumerable: true },
    entries: { enumerable: true },
    forEach: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"URLSearchParams\\", configurable: true },
    [Symbol.iterator]: { value: URLSearchParams.prototype.entries, configurable: true, writable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = URLSearchParams;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: URLSearchParams
  });
};

const Impl = require(\\"../implementations/URLSearchParams.js\\");
"
`;

exports[`with processors URLSearchParamsCollection.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"URLSearchParamsCollection\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'URLSearchParamsCollection'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"URLSearchParamsCollection\\"];
  if (ctor === undefined) {
    throw new Error(
      \\"Internal error: constructor URLSearchParamsCollection is not installed on the passed global object\\"
    );
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper = new Proxy(wrapper, proxyHandler);

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper = new Proxy(wrapper, proxyHandler);

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class URLSearchParamsCollection {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    item(index) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'item' on 'URLSearchParamsCollection': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"unsigned long\\"](curArg, {
          context: \\"Failed to execute 'item' on 'URLSearchParamsCollection': parameter 1\\"
        });
        args.push(curArg);
      }
      return utils.tryWrapperForImpl(esValue[implSymbol].item(...args));
    }

    namedItem(name) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'namedItem' on 'URLSearchParamsCollection': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'namedItem' on 'URLSearchParamsCollection': parameter 1\\"
        });
        args.push(curArg);
      }
      return utils.tryWrapperForImpl(esValue[implSymbol].namedItem(...args));
    }

    get length() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"length\\"];
    }
  }
  Object.defineProperties(URLSearchParamsCollection.prototype, {
    item: { enumerable: true },
    namedItem: { enumerable: true },
    length: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"URLSearchParamsCollection\\", configurable: true },
    [Symbol.iterator]: { value: Array.prototype[Symbol.iterator], configurable: true, writable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = URLSearchParamsCollection;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: URLSearchParamsCollection
  });
};

const proxyHandler = {
  get(target, P, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.get(target, P, receiver);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc === undefined) {
      const parent = Object.getPrototypeOf(target);
      if (parent === null) {
        return undefined;
      }
      return Reflect.get(target, P, receiver);
    }
    if (!desc.get && !desc.set) {
      return desc.value;
    }
    const getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return Reflect.apply(getter, receiver, []);
  },

  has(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.has(target, P);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc !== undefined) {
      return true;
    }
    const parent = Object.getPrototypeOf(target);
    if (parent !== null) {
      return Reflect.has(parent, P);
    }
    return false;
  },

  ownKeys(target) {
    const keys = new Set();

    for (const key of target[implSymbol][utils.supportedPropertyIndices]) {
      keys.add(\`\${key}\`);
    }

    for (const key of target[implSymbol][utils.supportedPropertyNames]) {
      if (!(key in target)) {
        keys.add(\`\${key}\`);
      }
    }

    for (const key of Reflect.ownKeys(target)) {
      keys.add(key);
    }
    return [...keys];
  },

  getOwnPropertyDescriptor(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.getOwnPropertyDescriptor(target, P);
    }
    let ignoreNamedProps = false;

    if (utils.isArrayIndexPropName(P)) {
      const index = P >>> 0;
      const indexedValue = target[implSymbol].item(index);
      if (indexedValue !== undefined) {
        return {
          writable: false,
          enumerable: true,
          configurable: true,
          value: utils.tryWrapperForImpl(indexedValue)
        };
      }
      ignoreNamedProps = true;
    }

    const namedValue = target[implSymbol].namedItem(P);

    if (namedValue !== null && !(P in target) && !ignoreNamedProps) {
      return {
        writable: false,
        enumerable: false,
        configurable: true,
        value: utils.tryWrapperForImpl(namedValue)
      };
    }

    return Reflect.getOwnPropertyDescriptor(target, P);
  },

  set(target, P, V, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.set(target, P, V, receiver);
    }
    if (target === receiver) {
      utils.isArrayIndexPropName(P);

      typeof P === \\"string\\" && !utils.isArrayIndexPropName(P);
    }
    let ownDesc;

    if (utils.isArrayIndexPropName(P)) {
      const index = P >>> 0;
      const indexedValue = target[implSymbol].item(index);
      if (indexedValue !== undefined) {
        ownDesc = {
          writable: false,
          enumerable: true,
          configurable: true,
          value: utils.tryWrapperForImpl(indexedValue)
        };
      }
    }

    if (ownDesc === undefined) {
      ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
    }
    if (ownDesc === undefined) {
      const parent = Reflect.getPrototypeOf(target);
      if (parent !== null) {
        return Reflect.set(parent, P, V, receiver);
      }
      ownDesc = { writable: true, enumerable: true, configurable: true, value: undefined };
    }
    if (!ownDesc.writable) {
      return false;
    }
    if (!utils.isObject(receiver)) {
      return false;
    }
    const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
    let valueDesc;
    if (existingDesc !== undefined) {
      if (existingDesc.get || existingDesc.set) {
        return false;
      }
      if (!existingDesc.writable) {
        return false;
      }
      valueDesc = { value: V };
    } else {
      valueDesc = { writable: true, enumerable: true, configurable: true, value: V };
    }
    return Reflect.defineProperty(receiver, P, valueDesc);
  },

  defineProperty(target, P, desc) {
    if (typeof P === \\"symbol\\") {
      return Reflect.defineProperty(target, P, desc);
    }

    if (utils.isArrayIndexPropName(P)) {
      return false;
    }
    if (!utils.hasOwn(target, P)) {
      const creating = !(target[implSymbol].namedItem(P) !== null);
      if (!creating) {
        return false;
      }
    }
    return Reflect.defineProperty(target, P, desc);
  },

  deleteProperty(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.deleteProperty(target, P);
    }

    if (utils.isArrayIndexPropName(P)) {
      const index = P >>> 0;
      return !(target[implSymbol].item(index) !== undefined);
    }

    if (target[implSymbol].namedItem(P) !== null && !(P in target)) {
      return false;
    }

    return Reflect.deleteProperty(target, P);
  },

  preventExtensions() {
    return false;
  }
};

const Impl = require(\\"../implementations/URLSearchParamsCollection.js\\");
"
`;

exports[`with processors URLSearchParamsCollection2.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const URL = require(\\"./URL.js\\");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const URLSearchParamsCollection = require(\\"./URLSearchParamsCollection.js\\");

const interfaceName = \\"URLSearchParamsCollection2\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'URLSearchParamsCollection2'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"URLSearchParamsCollection2\\"];
  if (ctor === undefined) {
    throw new Error(
      \\"Internal error: constructor URLSearchParamsCollection2 is not installed on the passed global object\\"
    );
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {
  URLSearchParamsCollection._internalSetup(wrapper, globalObject);
};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper = new Proxy(wrapper, proxyHandler);

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper = new Proxy(wrapper, proxyHandler);

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }

  if (globalObject.URLSearchParamsCollection === undefined) {
    throw new Error(
      \\"Internal error: attempting to evaluate URLSearchParamsCollection2 before URLSearchParamsCollection\\"
    );
  }
  class URLSearchParamsCollection2 extends globalObject.URLSearchParamsCollection {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }
  }
  Object.defineProperties(URLSearchParamsCollection2.prototype, {
    [Symbol.toStringTag]: { value: \\"URLSearchParamsCollection2\\", configurable: true },
    [Symbol.iterator]: { value: Array.prototype[Symbol.iterator], configurable: true, writable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = URLSearchParamsCollection2;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: URLSearchParamsCollection2
  });
};

const proxyHandler = {
  get(target, P, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.get(target, P, receiver);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc === undefined) {
      const parent = Object.getPrototypeOf(target);
      if (parent === null) {
        return undefined;
      }
      return Reflect.get(target, P, receiver);
    }
    if (!desc.get && !desc.set) {
      return desc.value;
    }
    const getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return Reflect.apply(getter, receiver, []);
  },

  has(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.has(target, P);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc !== undefined) {
      return true;
    }
    const parent = Object.getPrototypeOf(target);
    if (parent !== null) {
      return Reflect.has(parent, P);
    }
    return false;
  },

  ownKeys(target) {
    const keys = new Set();

    for (const key of target[implSymbol][utils.supportedPropertyIndices]) {
      keys.add(\`\${key}\`);
    }

    for (const key of target[implSymbol][utils.supportedPropertyNames]) {
      if (!(key in target)) {
        keys.add(\`\${key}\`);
      }
    }

    for (const key of Reflect.ownKeys(target)) {
      keys.add(key);
    }
    return [...keys];
  },

  getOwnPropertyDescriptor(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.getOwnPropertyDescriptor(target, P);
    }
    let ignoreNamedProps = false;

    if (utils.isArrayIndexPropName(P)) {
      const index = P >>> 0;
      const indexedValue = target[implSymbol].item(index);
      if (indexedValue !== undefined) {
        return {
          writable: false,
          enumerable: true,
          configurable: true,
          value: utils.tryWrapperForImpl(indexedValue)
        };
      }
      ignoreNamedProps = true;
    }

    const namedValue = target[implSymbol].namedItem(P);

    if (namedValue !== null && !(P in target) && !ignoreNamedProps) {
      return {
        writable: true,
        enumerable: true,
        configurable: true,
        value: utils.tryWrapperForImpl(namedValue)
      };
    }

    return Reflect.getOwnPropertyDescriptor(target, P);
  },

  set(target, P, V, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.set(target, P, V, receiver);
    }
    if (target === receiver) {
      utils.isArrayIndexPropName(P);

      if (typeof P === \\"string\\" && !utils.isArrayIndexPropName(P)) {
        let namedValue = V;

        namedValue = URL.convert(namedValue, {
          context: \\"Failed to set the '\\" + P + \\"' property on 'URLSearchParamsCollection2': The provided value\\"
        });

        const creating = !(target[implSymbol].namedItem(P) !== null);
        if (creating) {
          target[implSymbol][utils.namedSetNew](P, namedValue);
        } else {
          target[implSymbol][utils.namedSetExisting](P, namedValue);
        }

        return true;
      }
    }
    let ownDesc;

    if (utils.isArrayIndexPropName(P)) {
      const index = P >>> 0;
      const indexedValue = target[implSymbol].item(index);
      if (indexedValue !== undefined) {
        ownDesc = {
          writable: false,
          enumerable: true,
          configurable: true,
          value: utils.tryWrapperForImpl(indexedValue)
        };
      }
    }

    if (ownDesc === undefined) {
      ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
    }
    if (ownDesc === undefined) {
      const parent = Reflect.getPrototypeOf(target);
      if (parent !== null) {
        return Reflect.set(parent, P, V, receiver);
      }
      ownDesc = { writable: true, enumerable: true, configurable: true, value: undefined };
    }
    if (!ownDesc.writable) {
      return false;
    }
    if (!utils.isObject(receiver)) {
      return false;
    }
    const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
    let valueDesc;
    if (existingDesc !== undefined) {
      if (existingDesc.get || existingDesc.set) {
        return false;
      }
      if (!existingDesc.writable) {
        return false;
      }
      valueDesc = { value: V };
    } else {
      valueDesc = { writable: true, enumerable: true, configurable: true, value: V };
    }
    return Reflect.defineProperty(receiver, P, valueDesc);
  },

  defineProperty(target, P, desc) {
    if (typeof P === \\"symbol\\") {
      return Reflect.defineProperty(target, P, desc);
    }

    if (utils.isArrayIndexPropName(P)) {
      return false;
    }
    if (!utils.hasOwn(target, P)) {
      if (desc.get || desc.set) {
        return false;
      }

      let namedValue = desc.value;

      namedValue = URL.convert(namedValue, {
        context: \\"Failed to set the '\\" + P + \\"' property on 'URLSearchParamsCollection2': The provided value\\"
      });

      const creating = !(target[implSymbol].namedItem(P) !== null);
      if (creating) {
        target[implSymbol][utils.namedSetNew](P, namedValue);
      } else {
        target[implSymbol][utils.namedSetExisting](P, namedValue);
      }

      return true;
    }
    return Reflect.defineProperty(target, P, desc);
  },

  deleteProperty(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.deleteProperty(target, P);
    }

    if (utils.isArrayIndexPropName(P)) {
      const index = P >>> 0;
      return !(target[implSymbol].item(index) !== undefined);
    }

    if (target[implSymbol].namedItem(P) !== null && !(P in target)) {
      return false;
    }

    return Reflect.deleteProperty(target, P);
  },

  preventExtensions() {
    return false;
  }
};

const Impl = require(\\"../implementations/URLSearchParamsCollection2.js\\");
"
`;

exports[`with processors UnderscoredProperties.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"UnderscoredProperties\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'UnderscoredProperties'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"UnderscoredProperties\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor UnderscoredProperties is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class UnderscoredProperties {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    operation(sequence) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'operation' on 'UnderscoredProperties': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (!utils.isObject(curArg)) {
          throw new TypeError(
            \\"Failed to execute 'operation' on 'UnderscoredProperties': parameter 1\\" + \\" is not an iterable object.\\"
          );
        } else {
          const V = [];
          const tmp = curArg;
          for (let nextItem of tmp) {
            nextItem = conversions[\\"DOMString\\"](nextItem, {
              context: \\"Failed to execute 'operation' on 'UnderscoredProperties': parameter 1\\" + \\"'s element\\"
            });

            V.push(nextItem);
          }
          curArg = V;
        }
        args.push(curArg);
      }
      return esValue[implSymbol].operation(...args);
    }

    get attribute() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"attribute\\"];
    }

    set attribute(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"byte\\"](V, {
        context: \\"Failed to set the 'attribute' property on 'UnderscoredProperties': The provided value\\"
      });

      esValue[implSymbol][\\"attribute\\"] = V;
    }

    static static(void_) {
      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'static' on 'UnderscoredProperties': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'static' on 'UnderscoredProperties': parameter 1\\"
        });
        args.push(curArg);
      }
      return Impl.implementation.static(...args);
    }
  }
  Object.defineProperties(UnderscoredProperties.prototype, {
    operation: { enumerable: true },
    attribute: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"UnderscoredProperties\\", configurable: true },
    const: { value: 42, enumerable: true }
  });
  Object.defineProperties(UnderscoredProperties, {
    static: { enumerable: true },
    const: { value: 42, enumerable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = UnderscoredProperties;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: UnderscoredProperties
  });
};

const Impl = require(\\"../implementations/UnderscoredProperties.js\\");
"
`;

exports[`with processors Unscopable.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"Unscopable\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'Unscopable'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"Unscopable\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor Unscopable is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class Unscopable {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    get unscopableTest() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"unscopableTest\\"];
    }

    set unscopableTest(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"boolean\\"](V, {
        context: \\"Failed to set the 'unscopableTest' property on 'Unscopable': The provided value\\"
      });

      esValue[implSymbol][\\"unscopableTest\\"] = V;
    }

    get unscopableMixin() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"unscopableMixin\\"];
    }

    set unscopableMixin(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"boolean\\"](V, {
        context: \\"Failed to set the 'unscopableMixin' property on 'Unscopable': The provided value\\"
      });

      esValue[implSymbol][\\"unscopableMixin\\"] = V;
    }
  }
  Object.defineProperties(Unscopable.prototype, {
    unscopableTest: { enumerable: true },
    unscopableMixin: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"Unscopable\\", configurable: true },
    [Symbol.unscopables]: {
      value: { unscopableTest: true, unscopableMixin: true, __proto__: null },
      configurable: true
    }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = Unscopable;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: Unscopable
  });
};

const Impl = require(\\"../implementations/Unscopable.js\\");
"
`;

exports[`with processors Variadic.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const URL = require(\\"./URL.js\\");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"Variadic\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'Variadic'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"Variadic\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor Variadic is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class Variadic {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    simple1() {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
      const args = [];
      for (let i = 0; i < arguments.length; i++) {
        let curArg = arguments[i];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'simple1' on 'Variadic': parameter \\" + (i + 1)
        });
        args.push(curArg);
      }
      return esValue[implSymbol].simple1(...args);
    }

    simple2(first) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'simple2' on 'Variadic': 1 argument required, but only \\" + arguments.length + \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'simple2' on 'Variadic': parameter 1\\"
        });
        args.push(curArg);
      }
      for (let i = 1; i < arguments.length; i++) {
        let curArg = arguments[i];
        curArg = URL.convert(curArg, { context: \\"Failed to execute 'simple2' on 'Variadic': parameter \\" + (i + 1) });
        args.push(curArg);
      }
      return esValue[implSymbol].simple2(...args);
    }

    overloaded1() {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
      const args = [];
      switch (arguments.length) {
        case 0:
          break;
        default: {
          let curArg = arguments[0];
          if (typeof curArg === \\"number\\") {
            for (let i = 0; i < arguments.length; i++) {
              let curArg = arguments[i];
              curArg = conversions[\\"unsigned long\\"](curArg, {
                context: \\"Failed to execute 'overloaded1' on 'Variadic': parameter \\" + (i + 1)
              });
              args.push(curArg);
            }
          } else {
            for (let i = 0; i < arguments.length; i++) {
              let curArg = arguments[i];
              curArg = conversions[\\"DOMString\\"](curArg, {
                context: \\"Failed to execute 'overloaded1' on 'Variadic': parameter \\" + (i + 1)
              });
              args.push(curArg);
            }
          }
        }
      }
      return esValue[implSymbol].overloaded1(...args);
    }

    overloaded2(first) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'overloaded2' on 'Variadic': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      switch (arguments.length) {
        case 1:
          {
            let curArg = arguments[0];
            if (typeof curArg === \\"number\\") {
              {
                let curArg = arguments[0];
                curArg = conversions[\\"unsigned long\\"](curArg, {
                  context: \\"Failed to execute 'overloaded2' on 'Variadic': parameter 1\\"
                });
                args.push(curArg);
              }
            } else {
              {
                let curArg = arguments[0];
                curArg = conversions[\\"DOMString\\"](curArg, {
                  context: \\"Failed to execute 'overloaded2' on 'Variadic': parameter 1\\"
                });
                args.push(curArg);
              }
            }
          }
          break;
        default: {
          let curArg = arguments[0];
          if (typeof curArg === \\"number\\") {
            {
              let curArg = arguments[0];
              curArg = conversions[\\"unsigned long\\"](curArg, {
                context: \\"Failed to execute 'overloaded2' on 'Variadic': parameter 1\\"
              });
              args.push(curArg);
            }
            for (let i = 1; i < arguments.length; i++) {
              let curArg = arguments[i];
              curArg = conversions[\\"DOMString\\"](curArg, {
                context: \\"Failed to execute 'overloaded2' on 'Variadic': parameter \\" + (i + 1)
              });
              args.push(curArg);
            }
          } else {
            {
              let curArg = arguments[0];
              curArg = conversions[\\"DOMString\\"](curArg, {
                context: \\"Failed to execute 'overloaded2' on 'Variadic': parameter 1\\"
              });
              args.push(curArg);
            }
            for (let i = 1; i < arguments.length; i++) {
              let curArg = arguments[i];
              curArg = conversions[\\"DOMString\\"](curArg, {
                context: \\"Failed to execute 'overloaded2' on 'Variadic': parameter \\" + (i + 1)
              });
              args.push(curArg);
            }
          }
        }
      }
      return esValue[implSymbol].overloaded2(...args);
    }
  }
  Object.defineProperties(Variadic.prototype, {
    simple1: { enumerable: true },
    simple2: { enumerable: true },
    overloaded1: { enumerable: true },
    overloaded2: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"Variadic\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = Variadic;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: Variadic
  });
};

const Impl = require(\\"../implementations/Variadic.js\\");
"
`;

exports[`with processors ZeroArgConstructor.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"ZeroArgConstructor\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'ZeroArgConstructor'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"ZeroArgConstructor\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor ZeroArgConstructor is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class ZeroArgConstructor {
    constructor() {
      return exports.setup(Object.create(new.target.prototype), globalObject, undefined);
    }
  }
  Object.defineProperties(ZeroArgConstructor.prototype, {
    [Symbol.toStringTag]: { value: \\"ZeroArgConstructor\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = ZeroArgConstructor;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: ZeroArgConstructor
  });
};

const Impl = require(\\"../implementations/ZeroArgConstructor.js\\");
"
`;

exports[`without processors AsyncCallbackInterface.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

exports.convert = function convert(value, { context = \\"The provided value\\" } = {}) {
  if (!utils.isObject(value)) {
    throw new TypeError(\`\${context} is not an object.\`);
  }

  function callTheUserObjectsOperation() {
    let thisArg = utils.tryWrapperForImpl(this);
    let O = value;
    let X = O;

    try {
      if (typeof O !== \\"function\\") {
        X = O[\\"asyncMethod\\"];
        if (typeof X !== \\"function\\") {
          throw new TypeError(\`\${context} does not correctly implement AsyncCallbackInterface.\`);
        }
        thisArg = O;
      }

      let callResult = Reflect.apply(X, thisArg, []);

      callResult = Promise.resolve(callResult).then(
        value => {
          value = conversions[\\"any\\"](value, { context: context + \\" promise value\\" });

          return value;
        },
        reason => reason
      );

      return callResult;
    } catch (err) {
      return Promise.reject(err);
    }
  }

  callTheUserObjectsOperation[utils.wrapperSymbol] = value;
  callTheUserObjectsOperation.objectReference = value;

  return callTheUserObjectsOperation;
};

exports.install = (globalObject, globalNames) => {};
"
`;

exports[`without processors BufferSourceTypes.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"BufferSourceTypes\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'BufferSourceTypes'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"BufferSourceTypes\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor BufferSourceTypes is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class BufferSourceTypes {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    bs(source) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'bs' on 'BufferSourceTypes': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (utils.isArrayBuffer(curArg)) {
        } else if (ArrayBuffer.isView(curArg)) {
        } else {
          throw new TypeError(
            \\"Failed to execute 'bs' on 'BufferSourceTypes': parameter 1\\" + \\" is not of any supported type.\\"
          );
        }
        args.push(curArg);
      }
      return esValue[implSymbol].bs(...args);
    }

    ab(ab) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'ab' on 'BufferSourceTypes': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"ArrayBuffer\\"](curArg, {
          context: \\"Failed to execute 'ab' on 'BufferSourceTypes': parameter 1\\"
        });
        args.push(curArg);
      }
      return esValue[implSymbol].ab(...args);
    }

    abv(abv) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'abv' on 'BufferSourceTypes': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (ArrayBuffer.isView(curArg)) {
        } else {
          throw new TypeError(
            \\"Failed to execute 'abv' on 'BufferSourceTypes': parameter 1\\" + \\" is not of any supported type.\\"
          );
        }
        args.push(curArg);
      }
      return esValue[implSymbol].abv(...args);
    }

    u8a(u8) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'u8a' on 'BufferSourceTypes': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"Uint8Array\\"](curArg, {
          context: \\"Failed to execute 'u8a' on 'BufferSourceTypes': parameter 1\\"
        });
        args.push(curArg);
      }
      return esValue[implSymbol].u8a(...args);
    }

    abUnion(ab) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'abUnion' on 'BufferSourceTypes': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (utils.isArrayBuffer(curArg)) {
        } else {
          curArg = conversions[\\"DOMString\\"](curArg, {
            context: \\"Failed to execute 'abUnion' on 'BufferSourceTypes': parameter 1\\"
          });
        }
        args.push(curArg);
      }
      return esValue[implSymbol].abUnion(...args);
    }

    u8aUnion(ab) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'u8aUnion' on 'BufferSourceTypes': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (ArrayBuffer.isView(curArg) && curArg.constructor.name === \\"Uint8Array\\") {
        } else {
          curArg = conversions[\\"DOMString\\"](curArg, {
            context: \\"Failed to execute 'u8aUnion' on 'BufferSourceTypes': parameter 1\\"
          });
        }
        args.push(curArg);
      }
      return esValue[implSymbol].u8aUnion(...args);
    }
  }
  Object.defineProperties(BufferSourceTypes.prototype, {
    bs: { enumerable: true },
    ab: { enumerable: true },
    abv: { enumerable: true },
    u8a: { enumerable: true },
    abUnion: { enumerable: true },
    u8aUnion: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"BufferSourceTypes\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = BufferSourceTypes;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: BufferSourceTypes
  });
};

const Impl = require(\\"../implementations/BufferSourceTypes.js\\");
"
`;

exports[`without processors CEReactions.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"CEReactions\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'CEReactions'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"CEReactions\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor CEReactions is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

function makeProxy(wrapper, globalObject) {
  let proxyHandler = proxyHandlerCache.get(globalObject);
  if (proxyHandler === undefined) {
    proxyHandler = new ProxyHandler(globalObject);
    proxyHandlerCache.set(globalObject, proxyHandler);
  }
  return new Proxy(wrapper, proxyHandler);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper = makeProxy(wrapper, globalObject);

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper = makeProxy(wrapper, globalObject);

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class CEReactions {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    method() {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol].method();
    }

    promiseOperation() {
      try {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return utils.tryWrapperForImpl(esValue[implSymbol].promiseOperation());
      } catch (e) {
        return Promise.reject(e);
      }
    }

    get attr() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"attr\\"];
    }

    set attr(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"DOMString\\"](V, {
        context: \\"Failed to set the 'attr' property on 'CEReactions': The provided value\\"
      });

      esValue[implSymbol][\\"attr\\"] = V;
    }

    get promiseAttribute() {
      try {
        const esValue = this !== null && this !== undefined ? this : globalObject;

        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return utils.tryWrapperForImpl(esValue[implSymbol][\\"promiseAttribute\\"]);
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }
  Object.defineProperties(CEReactions.prototype, {
    method: { enumerable: true },
    promiseOperation: { enumerable: true },
    attr: { enumerable: true },
    promiseAttribute: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"CEReactions\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = CEReactions;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: CEReactions
  });
};

const proxyHandlerCache = new WeakMap();
class ProxyHandler {
  constructor(globalObject) {
    this._globalObject = globalObject;
  }

  get(target, P, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.get(target, P, receiver);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc === undefined) {
      const parent = Object.getPrototypeOf(target);
      if (parent === null) {
        return undefined;
      }
      return Reflect.get(target, P, receiver);
    }
    if (!desc.get && !desc.set) {
      return desc.value;
    }
    const getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return Reflect.apply(getter, receiver, []);
  }

  has(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.has(target, P);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc !== undefined) {
      return true;
    }
    const parent = Object.getPrototypeOf(target);
    if (parent !== null) {
      return Reflect.has(parent, P);
    }
    return false;
  }

  ownKeys(target) {
    const keys = new Set();

    for (const key of target[implSymbol][utils.supportedPropertyNames]) {
      if (!(key in target)) {
        keys.add(\`\${key}\`);
      }
    }

    for (const key of Reflect.ownKeys(target)) {
      keys.add(key);
    }
    return [...keys];
  }

  getOwnPropertyDescriptor(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.getOwnPropertyDescriptor(target, P);
    }
    let ignoreNamedProps = false;

    if (target[implSymbol][utils.supportsPropertyName](P) && !(P in target) && !ignoreNamedProps) {
      const namedValue = target[implSymbol][utils.namedGet](P);

      return {
        writable: true,
        enumerable: true,
        configurable: true,
        value: utils.tryWrapperForImpl(namedValue)
      };
    }

    return Reflect.getOwnPropertyDescriptor(target, P);
  }

  set(target, P, V, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.set(target, P, V, receiver);
    }
    if (target === receiver) {
      const globalObject = this._globalObject;

      if (typeof P === \\"string\\" && !utils.isArrayIndexPropName(P)) {
        let namedValue = V;

        namedValue = conversions[\\"DOMString\\"](namedValue, {
          context: \\"Failed to set the '\\" + P + \\"' property on 'CEReactions': The provided value\\"
        });

        const creating = !target[implSymbol][utils.supportsPropertyName](P);
        if (creating) {
          target[implSymbol][utils.namedSetNew](P, namedValue);
        } else {
          target[implSymbol][utils.namedSetExisting](P, namedValue);
        }

        return true;
      }
    }
    let ownDesc;

    if (ownDesc === undefined) {
      ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
    }
    if (ownDesc === undefined) {
      const parent = Reflect.getPrototypeOf(target);
      if (parent !== null) {
        return Reflect.set(parent, P, V, receiver);
      }
      ownDesc = { writable: true, enumerable: true, configurable: true, value: undefined };
    }
    if (!ownDesc.writable) {
      return false;
    }
    if (!utils.isObject(receiver)) {
      return false;
    }
    const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
    let valueDesc;
    if (existingDesc !== undefined) {
      if (existingDesc.get || existingDesc.set) {
        return false;
      }
      if (!existingDesc.writable) {
        return false;
      }
      valueDesc = { value: V };
    } else {
      valueDesc = { writable: true, enumerable: true, configurable: true, value: V };
    }
    return Reflect.defineProperty(receiver, P, valueDesc);
  }

  defineProperty(target, P, desc) {
    if (typeof P === \\"symbol\\") {
      return Reflect.defineProperty(target, P, desc);
    }

    const globalObject = this._globalObject;
    if (!utils.hasOwn(target, P)) {
      if (desc.get || desc.set) {
        return false;
      }

      let namedValue = desc.value;

      namedValue = conversions[\\"DOMString\\"](namedValue, {
        context: \\"Failed to set the '\\" + P + \\"' property on 'CEReactions': The provided value\\"
      });

      const creating = !target[implSymbol][utils.supportsPropertyName](P);
      if (creating) {
        target[implSymbol][utils.namedSetNew](P, namedValue);
      } else {
        target[implSymbol][utils.namedSetExisting](P, namedValue);
      }

      return true;
    }
    return Reflect.defineProperty(target, P, desc);
  }

  deleteProperty(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.deleteProperty(target, P);
    }

    const globalObject = this._globalObject;

    if (target[implSymbol][utils.supportsPropertyName](P) && !(P in target)) {
      target[implSymbol][utils.namedDelete](P);
      return true;
    }

    return Reflect.deleteProperty(target, P);
  }

  preventExtensions() {
    return false;
  }
}

const Impl = require(\\"../implementations/CEReactions.js\\");
"
`;

exports[`without processors DOMImplementation.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"DOMImplementation\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'DOMImplementation'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"DOMImplementation\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor DOMImplementation is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class DOMImplementation {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    createDocumentType(qualifiedName, publicId, systemId) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 3) {
        throw new TypeError(
          \\"Failed to execute 'createDocumentType' on 'DOMImplementation': 3 arguments required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'createDocumentType' on 'DOMImplementation': parameter 1\\"
        });
        args.push(curArg);
      }
      {
        let curArg = arguments[1];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'createDocumentType' on 'DOMImplementation': parameter 2\\"
        });
        args.push(curArg);
      }
      {
        let curArg = arguments[2];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'createDocumentType' on 'DOMImplementation': parameter 3\\"
        });
        args.push(curArg);
      }
      return utils.tryWrapperForImpl(esValue[implSymbol].createDocumentType(...args));
    }

    createDocument(namespace, qualifiedName) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 2) {
        throw new TypeError(
          \\"Failed to execute 'createDocument' on 'DOMImplementation': 2 arguments required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg === null || curArg === undefined) {
          curArg = null;
        } else {
          curArg = conversions[\\"DOMString\\"](curArg, {
            context: \\"Failed to execute 'createDocument' on 'DOMImplementation': parameter 1\\"
          });
        }
        args.push(curArg);
      }
      {
        let curArg = arguments[1];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'createDocument' on 'DOMImplementation': parameter 2\\",
          treatNullAsEmptyString: true
        });
        args.push(curArg);
      }
      {
        let curArg = arguments[2];
        if (curArg !== undefined) {
          if (curArg === null || curArg === undefined) {
            curArg = null;
          } else {
            curArg = utils.tryImplForWrapper(curArg);
          }
        } else {
          curArg = null;
        }
        args.push(curArg);
      }
      return utils.tryWrapperForImpl(esValue[implSymbol].createDocument(...args));
    }

    createHTMLDocument() {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg !== undefined) {
          curArg = conversions[\\"DOMString\\"](curArg, {
            context: \\"Failed to execute 'createHTMLDocument' on 'DOMImplementation': parameter 1\\"
          });
        }
        args.push(curArg);
      }
      return utils.tryWrapperForImpl(esValue[implSymbol].createHTMLDocument(...args));
    }

    hasFeature() {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol].hasFeature();
    }
  }
  Object.defineProperties(DOMImplementation.prototype, {
    createDocumentType: { enumerable: true },
    createDocument: { enumerable: true },
    createHTMLDocument: { enumerable: true },
    hasFeature: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"DOMImplementation\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = DOMImplementation;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: DOMImplementation
  });
};

const Impl = require(\\"../implementations/DOMImplementation.js\\");
"
`;

exports[`without processors DOMRect.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"DOMRect\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'DOMRect'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"DOMRect\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor DOMRect is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\", \\"Worker\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class DOMRect {
    constructor() {
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg !== undefined) {
          curArg = conversions[\\"unrestricted double\\"](curArg, {
            context: \\"Failed to construct 'DOMRect': parameter 1\\"
          });
        } else {
          curArg = 0;
        }
        args.push(curArg);
      }
      {
        let curArg = arguments[1];
        if (curArg !== undefined) {
          curArg = conversions[\\"unrestricted double\\"](curArg, {
            context: \\"Failed to construct 'DOMRect': parameter 2\\"
          });
        } else {
          curArg = 0;
        }
        args.push(curArg);
      }
      {
        let curArg = arguments[2];
        if (curArg !== undefined) {
          curArg = conversions[\\"unrestricted double\\"](curArg, {
            context: \\"Failed to construct 'DOMRect': parameter 3\\"
          });
        } else {
          curArg = 0;
        }
        args.push(curArg);
      }
      {
        let curArg = arguments[3];
        if (curArg !== undefined) {
          curArg = conversions[\\"unrestricted double\\"](curArg, {
            context: \\"Failed to construct 'DOMRect': parameter 4\\"
          });
        } else {
          curArg = 0;
        }
        args.push(curArg);
      }
      return exports.setup(Object.create(new.target.prototype), globalObject, args);
    }

    get x() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"x\\"];
    }

    set x(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"unrestricted double\\"](V, {
        context: \\"Failed to set the 'x' property on 'DOMRect': The provided value\\"
      });

      esValue[implSymbol][\\"x\\"] = V;
    }

    get y() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"y\\"];
    }

    set y(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"unrestricted double\\"](V, {
        context: \\"Failed to set the 'y' property on 'DOMRect': The provided value\\"
      });

      esValue[implSymbol][\\"y\\"] = V;
    }

    get width() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"width\\"];
    }

    set width(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"unrestricted double\\"](V, {
        context: \\"Failed to set the 'width' property on 'DOMRect': The provided value\\"
      });

      esValue[implSymbol][\\"width\\"] = V;
    }

    get height() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"height\\"];
    }

    set height(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"unrestricted double\\"](V, {
        context: \\"Failed to set the 'height' property on 'DOMRect': The provided value\\"
      });

      esValue[implSymbol][\\"height\\"] = V;
    }

    static fromRect() {
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg !== undefined) {
          curArg = utils.tryImplForWrapper(curArg);
        }
        args.push(curArg);
      }
      return utils.tryWrapperForImpl(Impl.implementation.fromRect(...args));
    }
  }
  Object.defineProperties(DOMRect.prototype, {
    x: { enumerable: true },
    y: { enumerable: true },
    width: { enumerable: true },
    height: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"DOMRect\\", configurable: true }
  });
  Object.defineProperties(DOMRect, { fromRect: { enumerable: true } });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = DOMRect;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: DOMRect
  });

  if (globalNames.includes(\\"Window\\")) {
    Object.defineProperty(globalObject, \\"SVGRect\\", {
      configurable: true,
      writable: true,
      value: DOMRect
    });
  }
};

const Impl = require(\\"../implementations/DOMRect.js\\");
"
`;

exports[`without processors Dictionary.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const URL = require(\\"./URL.js\\");
const URLSearchParams = require(\\"./URLSearchParams.js\\");

exports._convertInherit = (obj, ret, { context = \\"The provided value\\" } = {}) => {
  {
    const key = \\"boolWithDefault\\";
    let value = obj === undefined || obj === null ? undefined : obj[key];
    if (value !== undefined) {
      value = conversions[\\"boolean\\"](value, { context: context + \\" has member 'boolWithDefault' that\\" });

      ret[key] = value;
    } else {
      ret[key] = false;
    }
  }

  {
    const key = \\"requiredInterface\\";
    let value = obj === undefined || obj === null ? undefined : obj[key];
    if (value !== undefined) {
      value = URL.convert(value, { context: context + \\" has member 'requiredInterface' that\\" });

      ret[key] = value;
    } else {
      throw new TypeError(\\"requiredInterface is required in 'Dictionary'\\");
    }
  }

  {
    const key = \\"seq\\";
    let value = obj === undefined || obj === null ? undefined : obj[key];
    if (value !== undefined) {
      if (!utils.isObject(value)) {
        throw new TypeError(context + \\" has member 'seq' that\\" + \\" is not an iterable object.\\");
      } else {
        const V = [];
        const tmp = value;
        for (let nextItem of tmp) {
          nextItem = URLSearchParams.convert(nextItem, { context: context + \\" has member 'seq' that\\" + \\"'s element\\" });

          V.push(nextItem);
        }
        value = V;
      }

      ret[key] = value;
    }
  }

  {
    const key = \\"vanillaString\\";
    let value = obj === undefined || obj === null ? undefined : obj[key];
    if (value !== undefined) {
      value = conversions[\\"DOMString\\"](value, { context: context + \\" has member 'vanillaString' that\\" });

      ret[key] = value;
    }
  }
};

exports.convert = function convert(obj, { context = \\"The provided value\\" } = {}) {
  if (obj !== undefined && typeof obj !== \\"object\\" && typeof obj !== \\"function\\") {
    throw new TypeError(\`\${context} is not an object.\`);
  }

  const ret = Object.create(null);
  exports._convertInherit(obj, ret, { context });
  return ret;
};
"
`;

exports[`without processors DictionaryConvert.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const Dictionary = require(\\"./Dictionary.js\\");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"DictionaryConvert\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'DictionaryConvert'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"DictionaryConvert\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor DictionaryConvert is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class DictionaryConvert {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    op() {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg !== undefined) {
          curArg = conversions[\\"DOMString\\"](curArg, {
            context: \\"Failed to execute 'op' on 'DictionaryConvert': parameter 1\\"
          });
        }
        args.push(curArg);
      }
      {
        let curArg = arguments[1];
        curArg = Dictionary.convert(curArg, { context: \\"Failed to execute 'op' on 'DictionaryConvert': parameter 2\\" });
        args.push(curArg);
      }
      return esValue[implSymbol].op(...args);
    }
  }
  Object.defineProperties(DictionaryConvert.prototype, {
    op: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"DictionaryConvert\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = DictionaryConvert;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: DictionaryConvert
  });
};

const Impl = require(\\"../implementations/DictionaryConvert.js\\");
"
`;

exports[`without processors Enum.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const RequestDestination = require(\\"./RequestDestination.js\\");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"Enum\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'Enum'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"Enum\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor Enum is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class Enum {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    op(destination) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'op' on 'Enum': 1 argument required, but only \\" + arguments.length + \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = RequestDestination.convert(curArg, { context: \\"Failed to execute 'op' on 'Enum': parameter 1\\" });
        args.push(curArg);
      }
      return esValue[implSymbol].op(...args);
    }

    get attr() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][\\"attr\\"]);
    }

    set attr(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = \`\${V}\`;
      if (!RequestDestination.enumerationValues.has(V)) {
        return;
      }

      esValue[implSymbol][\\"attr\\"] = V;
    }
  }
  Object.defineProperties(Enum.prototype, {
    op: { enumerable: true },
    attr: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"Enum\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = Enum;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: Enum
  });
};

const Impl = require(\\"../implementations/Enum.js\\");
"
`;

exports[`without processors EventListener.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

exports.convert = function convert(value, { context = \\"The provided value\\" } = {}) {
  if (!utils.isObject(value)) {
    throw new TypeError(\`\${context} is not an object.\`);
  }

  function callTheUserObjectsOperation(event) {
    let thisArg = utils.tryWrapperForImpl(this);
    let O = value;
    let X = O;

    if (typeof O !== \\"function\\") {
      X = O[\\"handleEvent\\"];
      if (typeof X !== \\"function\\") {
        throw new TypeError(\`\${context} does not correctly implement EventListener.\`);
      }
      thisArg = O;
    }

    event = utils.tryWrapperForImpl(event);

    let callResult = Reflect.apply(X, thisArg, [event]);
  }

  callTheUserObjectsOperation[utils.wrapperSymbol] = value;
  callTheUserObjectsOperation.objectReference = value;

  return callTheUserObjectsOperation;
};

exports.install = (globalObject, globalNames) => {};
"
`;

exports[`without processors EventTarget.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const EventListener = require(\\"./EventListener.js\\");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"EventTarget\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'EventTarget'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"EventTarget\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor EventTarget is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\", \\"Worker\\", \\"AudioWorklet\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class EventTarget {
    constructor() {
      return exports.setup(Object.create(new.target.prototype), globalObject, undefined);
    }

    addEventListener(type, callback) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 2) {
        throw new TypeError(
          \\"Failed to execute 'addEventListener' on 'EventTarget': 2 arguments required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'addEventListener' on 'EventTarget': parameter 1\\"
        });
        args.push(curArg);
      }
      {
        let curArg = arguments[1];
        if (curArg === null || curArg === undefined) {
          curArg = null;
        } else {
          curArg = EventListener.convert(curArg, {
            context: \\"Failed to execute 'addEventListener' on 'EventTarget': parameter 2\\"
          });
        }
        args.push(curArg);
      }
      return esValue[implSymbol].addEventListener(...args);
    }
  }
  Object.defineProperties(EventTarget.prototype, {
    addEventListener: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"EventTarget\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = EventTarget;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: EventTarget
  });
};

const Impl = require(\\"../implementations/EventTarget.js\\");
"
`;

exports[`without processors Global.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"Global\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'Global'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"Global\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor Global is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {
  Object.defineProperties(
    wrapper,
    Object.getOwnPropertyDescriptors({
      op() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return esValue[implSymbol].op();
      },
      unforgeableOp() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return esValue[implSymbol].unforgeableOp();
      },
      get attr() {
        const esValue = this !== null && this !== undefined ? this : globalObject;

        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return esValue[implSymbol][\\"attr\\"];
      },
      set attr(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;

        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        V = conversions[\\"DOMString\\"](V, {
          context: \\"Failed to set the 'attr' property on 'Global': The provided value\\"
        });

        esValue[implSymbol][\\"attr\\"] = V;
      },
      get unforgeableAttr() {
        const esValue = this !== null && this !== undefined ? this : globalObject;

        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return esValue[implSymbol][\\"unforgeableAttr\\"];
      },
      set unforgeableAttr(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;

        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        V = conversions[\\"DOMString\\"](V, {
          context: \\"Failed to set the 'unforgeableAttr' property on 'Global': The provided value\\"
        });

        esValue[implSymbol][\\"unforgeableAttr\\"] = V;
      },
      get length() {
        const esValue = this !== null && this !== undefined ? this : globalObject;

        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return esValue[implSymbol][\\"length\\"];
      },
      set length(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;

        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        V = conversions[\\"unsigned long\\"](V, {
          context: \\"Failed to set the 'length' property on 'Global': The provided value\\"
        });

        esValue[implSymbol][\\"length\\"] = V;
      },
      [Symbol.iterator]: Array.prototype[Symbol.iterator],
      keys: Array.prototype.keys,
      values: Array.prototype[Symbol.iterator],
      entries: Array.prototype.entries,
      forEach: Array.prototype.forEach
    })
  );

  Object.defineProperties(wrapper, {
    unforgeableOp: { configurable: false, writable: false },
    unforgeableAttr: { configurable: false },
    [Symbol.iterator]: { enumerable: false }
  });
};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Global\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class Global {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    static staticOp() {
      return Impl.implementation.staticOp();
    }

    static get staticAttr() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      return Impl.implementation[\\"staticAttr\\"];
    }

    static set staticAttr(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      return Impl.implementation[\\"staticAttr\\"];
    }
  }
  Object.defineProperties(Global.prototype, { [Symbol.toStringTag]: { value: \\"Global\\", configurable: true } });
  Object.defineProperties(Global, { staticOp: { enumerable: true }, staticAttr: { enumerable: true } });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = Global;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: Global
  });
};

const Impl = require(\\"../implementations/Global.js\\");
"
`;

exports[`without processors HTMLConstructor.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"HTMLConstructor\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'HTMLConstructor'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"HTMLConstructor\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor HTMLConstructor is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class HTMLConstructor {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }
  }
  Object.defineProperties(HTMLConstructor.prototype, {
    [Symbol.toStringTag]: { value: \\"HTMLConstructor\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = HTMLConstructor;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: HTMLConstructor
  });
};

const Impl = require(\\"../implementations/HTMLConstructor.js\\");
"
`;

exports[`without processors LegacyLenientAttributes.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"LegacyLenientAttributes\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'LegacyLenientAttributes'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"LegacyLenientAttributes\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor LegacyLenientAttributes is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class LegacyLenientAttributes {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    get lenientSetter() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"lenientSetter\\"];
    }

    set lenientSetter(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
    }

    get lenientThisSetter() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        return;
      }

      return esValue[implSymbol][\\"lenientThisSetter\\"];
    }

    set lenientThisSetter(V) {}

    get lenientThis() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        return;
      }

      return esValue[implSymbol][\\"lenientThis\\"];
    }

    set lenientThis(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        return;
      }

      V = conversions[\\"DOMString\\"](V, {
        context: \\"Failed to set the 'lenientThis' property on 'LegacyLenientAttributes': The provided value\\"
      });

      esValue[implSymbol][\\"lenientThis\\"] = V;
    }

    get readonlyLenientThis() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        return;
      }

      return esValue[implSymbol][\\"readonlyLenientThis\\"];
    }

    get replaceableLenientThis() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        return;
      }

      return esValue[implSymbol][\\"replaceableLenientThis\\"];
    }

    set replaceableLenientThis(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      Object.defineProperty(esValue, \\"replaceableLenientThis\\", {
        configurable: true,
        enumerable: true,
        value: V,
        writable: true
      });
    }
  }
  Object.defineProperties(LegacyLenientAttributes.prototype, {
    lenientSetter: { enumerable: true },
    lenientThisSetter: { enumerable: true },
    lenientThis: { enumerable: true },
    readonlyLenientThis: { enumerable: true },
    replaceableLenientThis: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"LegacyLenientAttributes\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = LegacyLenientAttributes;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: LegacyLenientAttributes
  });
};

const Impl = require(\\"../implementations/LegacyLenientAttributes.js\\");
"
`;

exports[`without processors LegacyUnforgeable.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"LegacyUnforgeable\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'LegacyUnforgeable'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"LegacyUnforgeable\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor LegacyUnforgeable is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {
  Object.defineProperties(
    wrapper,
    Object.getOwnPropertyDescriptors({
      assign(url) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        if (arguments.length < 1) {
          throw new TypeError(
            \\"Failed to execute 'assign' on 'LegacyUnforgeable': 1 argument required, but only \\" +
              arguments.length +
              \\" present.\\"
          );
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions[\\"USVString\\"](curArg, {
            context: \\"Failed to execute 'assign' on 'LegacyUnforgeable': parameter 1\\"
          });
          args.push(curArg);
        }
        return esValue[implSymbol].assign(...args);
      },
      get href() {
        const esValue = this !== null && this !== undefined ? this : globalObject;

        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return esValue[implSymbol][\\"href\\"];
      },
      set href(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;

        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        V = conversions[\\"USVString\\"](V, {
          context: \\"Failed to set the 'href' property on 'LegacyUnforgeable': The provided value\\"
        });

        esValue[implSymbol][\\"href\\"] = V;
      },
      toString() {
        const esValue = this;
        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return esValue[implSymbol][\\"href\\"];
      },
      get origin() {
        const esValue = this !== null && this !== undefined ? this : globalObject;

        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return esValue[implSymbol][\\"origin\\"];
      },
      get protocol() {
        const esValue = this !== null && this !== undefined ? this : globalObject;

        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return esValue[implSymbol][\\"protocol\\"];
      },
      set protocol(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;

        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        V = conversions[\\"USVString\\"](V, {
          context: \\"Failed to set the 'protocol' property on 'LegacyUnforgeable': The provided value\\"
        });

        esValue[implSymbol][\\"protocol\\"] = V;
      }
    })
  );

  Object.defineProperties(wrapper, {
    assign: { configurable: false, writable: false },
    href: { configurable: false },
    toString: { configurable: false, writable: false },
    origin: { configurable: false },
    protocol: { configurable: false }
  });
};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class LegacyUnforgeable {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }
  }
  Object.defineProperties(LegacyUnforgeable.prototype, {
    [Symbol.toStringTag]: { value: \\"LegacyUnforgeable\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = LegacyUnforgeable;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: LegacyUnforgeable
  });
};

const Impl = require(\\"../implementations/LegacyUnforgeable.js\\");
"
`;

exports[`without processors LegacyUnforgeableMap.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"LegacyUnforgeableMap\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'LegacyUnforgeableMap'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"LegacyUnforgeableMap\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor LegacyUnforgeableMap is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {
  Object.defineProperties(
    wrapper,
    Object.getOwnPropertyDescriptors({
      get a() {
        const esValue = this !== null && this !== undefined ? this : globalObject;

        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return esValue[implSymbol][\\"a\\"];
      }
    })
  );

  Object.defineProperties(wrapper, { a: { configurable: false } });
};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper = new Proxy(wrapper, proxyHandler);

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper = new Proxy(wrapper, proxyHandler);

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class LegacyUnforgeableMap {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }
  }
  Object.defineProperties(LegacyUnforgeableMap.prototype, {
    [Symbol.toStringTag]: { value: \\"LegacyUnforgeableMap\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = LegacyUnforgeableMap;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: LegacyUnforgeableMap
  });
};

const proxyHandler = {
  get(target, P, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.get(target, P, receiver);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc === undefined) {
      const parent = Object.getPrototypeOf(target);
      if (parent === null) {
        return undefined;
      }
      return Reflect.get(target, P, receiver);
    }
    if (!desc.get && !desc.set) {
      return desc.value;
    }
    const getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return Reflect.apply(getter, receiver, []);
  },

  has(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.has(target, P);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc !== undefined) {
      return true;
    }
    const parent = Object.getPrototypeOf(target);
    if (parent !== null) {
      return Reflect.has(parent, P);
    }
    return false;
  },

  ownKeys(target) {
    const keys = new Set();

    for (const key of target[implSymbol][utils.supportedPropertyNames]) {
      if (!(key in target)) {
        keys.add(\`\${key}\`);
      }
    }

    for (const key of Reflect.ownKeys(target)) {
      keys.add(key);
    }
    return [...keys];
  },

  getOwnPropertyDescriptor(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.getOwnPropertyDescriptor(target, P);
    }
    let ignoreNamedProps = false;

    if (target[implSymbol][utils.supportsPropertyName](P) && !(P in target) && !ignoreNamedProps) {
      const namedValue = target[implSymbol][utils.namedGet](P);

      return {
        writable: true,
        enumerable: true,
        configurable: true,
        value: utils.tryWrapperForImpl(namedValue)
      };
    }

    return Reflect.getOwnPropertyDescriptor(target, P);
  },

  set(target, P, V, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.set(target, P, V, receiver);
    }
    if (target === receiver) {
      if (typeof P === \\"string\\" && !utils.isArrayIndexPropName(P)) {
        let namedValue = V;

        namedValue = conversions[\\"DOMString\\"](namedValue, {
          context: \\"Failed to set the '\\" + P + \\"' property on 'LegacyUnforgeableMap': The provided value\\"
        });

        const creating = !target[implSymbol][utils.supportsPropertyName](P);
        if (creating) {
          target[implSymbol][utils.namedSetNew](P, namedValue);
        } else {
          target[implSymbol][utils.namedSetExisting](P, namedValue);
        }

        return true;
      }
    }
    let ownDesc;

    if (ownDesc === undefined) {
      ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
    }
    if (ownDesc === undefined) {
      const parent = Reflect.getPrototypeOf(target);
      if (parent !== null) {
        return Reflect.set(parent, P, V, receiver);
      }
      ownDesc = { writable: true, enumerable: true, configurable: true, value: undefined };
    }
    if (!ownDesc.writable) {
      return false;
    }
    if (!utils.isObject(receiver)) {
      return false;
    }
    const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
    let valueDesc;
    if (existingDesc !== undefined) {
      if (existingDesc.get || existingDesc.set) {
        return false;
      }
      if (!existingDesc.writable) {
        return false;
      }
      valueDesc = { value: V };
    } else {
      valueDesc = { writable: true, enumerable: true, configurable: true, value: V };
    }
    return Reflect.defineProperty(receiver, P, valueDesc);
  },

  defineProperty(target, P, desc) {
    if (typeof P === \\"symbol\\") {
      return Reflect.defineProperty(target, P, desc);
    }
    if (![\\"a\\"].includes(P)) {
      if (!utils.hasOwn(target, P)) {
        if (desc.get || desc.set) {
          return false;
        }

        let namedValue = desc.value;

        namedValue = conversions[\\"DOMString\\"](namedValue, {
          context: \\"Failed to set the '\\" + P + \\"' property on 'LegacyUnforgeableMap': The provided value\\"
        });

        const creating = !target[implSymbol][utils.supportsPropertyName](P);
        if (creating) {
          target[implSymbol][utils.namedSetNew](P, namedValue);
        } else {
          target[implSymbol][utils.namedSetExisting](P, namedValue);
        }

        return true;
      }
    }
    return Reflect.defineProperty(target, P, desc);
  },

  deleteProperty(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.deleteProperty(target, P);
    }

    if (target[implSymbol][utils.supportsPropertyName](P) && !(P in target)) {
      return false;
    }

    return Reflect.deleteProperty(target, P);
  },

  preventExtensions() {
    return false;
  }
};

const Impl = require(\\"../implementations/LegacyUnforgeableMap.js\\");
"
`;

exports[`without processors MixedIn.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"MixedIn\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'MixedIn'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"MixedIn\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor MixedIn is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class MixedIn {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    mixedInOp() {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol].mixedInOp();
    }

    ifaceMixinOp() {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol].ifaceMixinOp();
    }

    get mixedInAttr() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"mixedInAttr\\"];
    }

    set mixedInAttr(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"DOMString\\"](V, {
        context: \\"Failed to set the 'mixedInAttr' property on 'MixedIn': The provided value\\"
      });

      esValue[implSymbol][\\"mixedInAttr\\"] = V;
    }

    get ifaceMixinAttr() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"ifaceMixinAttr\\"];
    }

    set ifaceMixinAttr(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"DOMString\\"](V, {
        context: \\"Failed to set the 'ifaceMixinAttr' property on 'MixedIn': The provided value\\"
      });

      esValue[implSymbol][\\"ifaceMixinAttr\\"] = V;
    }
  }
  Object.defineProperties(MixedIn.prototype, {
    mixedInOp: { enumerable: true },
    ifaceMixinOp: { enumerable: true },
    mixedInAttr: { enumerable: true },
    ifaceMixinAttr: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"MixedIn\\", configurable: true },
    mixedInConst: { value: 43, enumerable: true },
    ifaceMixinConst: { value: 42, enumerable: true }
  });
  Object.defineProperties(MixedIn, {
    mixedInConst: { value: 43, enumerable: true },
    ifaceMixinConst: { value: 42, enumerable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = MixedIn;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: MixedIn
  });
};

const Impl = require(\\"../implementations/MixedIn.js\\");
"
`;

exports[`without processors NodeFilter.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

exports.convert = function convert(value, { context = \\"The provided value\\" } = {}) {
  if (!utils.isObject(value)) {
    throw new TypeError(\`\${context} is not an object.\`);
  }

  function callTheUserObjectsOperation(node) {
    let thisArg = utils.tryWrapperForImpl(this);
    let O = value;
    let X = O;

    if (typeof O !== \\"function\\") {
      X = O[\\"acceptNode\\"];
      if (typeof X !== \\"function\\") {
        throw new TypeError(\`\${context} does not correctly implement NodeFilter.\`);
      }
      thisArg = O;
    }

    node = utils.tryWrapperForImpl(node);

    let callResult = Reflect.apply(X, thisArg, [node]);

    callResult = conversions[\\"unsigned short\\"](callResult, { context: context });

    return callResult;
  }

  callTheUserObjectsOperation[utils.wrapperSymbol] = value;
  callTheUserObjectsOperation.objectReference = value;

  return callTheUserObjectsOperation;
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }

  const NodeFilter = () => {
    throw new TypeError(\\"Illegal invocation\\");
  };

  Object.defineProperties(NodeFilter, {
    FILTER_ACCEPT: { value: 1, enumerable: true },
    FILTER_REJECT: { value: 2, enumerable: true },
    FILTER_SKIP: { value: 3, enumerable: true },
    SHOW_ALL: { value: 0xffffffff, enumerable: true },
    SHOW_ELEMENT: { value: 0x1, enumerable: true },
    SHOW_ATTRIBUTE: { value: 0x2, enumerable: true },
    SHOW_TEXT: { value: 0x4, enumerable: true },
    SHOW_CDATA_SECTION: { value: 0x8, enumerable: true },
    SHOW_ENTITY_REFERENCE: { value: 0x10, enumerable: true },
    SHOW_ENTITY: { value: 0x20, enumerable: true },
    SHOW_PROCESSING_INSTRUCTION: { value: 0x40, enumerable: true },
    SHOW_COMMENT: { value: 0x80, enumerable: true },
    SHOW_DOCUMENT: { value: 0x100, enumerable: true },
    SHOW_DOCUMENT_TYPE: { value: 0x200, enumerable: true },
    SHOW_DOCUMENT_FRAGMENT: { value: 0x400, enumerable: true },
    SHOW_NOTATION: { value: 0x800, enumerable: true }
  });

  Object.defineProperty(globalObject, \\"NodeFilter\\", {
    configurable: true,
    writable: true,
    value: NodeFilter
  });
};
"
`;

exports[`without processors Overloads.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const URL = require(\\"./URL.js\\");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"Overloads\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'Overloads'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"Overloads\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor Overloads is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class Overloads {
    constructor() {
      const args = [];
      switch (arguments.length) {
        case 0:
          break;
        default: {
          let curArg = arguments[0];
          if (URL.is(curArg)) {
            {
              let curArg = arguments[0];
              curArg = URL.convert(curArg, { context: \\"Failed to construct 'Overloads': parameter 1\\" });
              args.push(curArg);
            }
          } else {
            {
              let curArg = arguments[0];
              curArg = conversions[\\"DOMString\\"](curArg, { context: \\"Failed to construct 'Overloads': parameter 1\\" });
              args.push(curArg);
            }
          }
        }
      }
      return exports.setup(Object.create(new.target.prototype), globalObject, args);
    }

    compatible(arg1) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'compatible' on 'Overloads': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      switch (arguments.length) {
        case 1:
          {
            let curArg = arguments[0];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'compatible' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
          break;
        case 2:
          {
            let curArg = arguments[0];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'compatible' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'compatible' on 'Overloads': parameter 2\\"
            });
            args.push(curArg);
          }
          break;
        default:
          {
            let curArg = arguments[0];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'compatible' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'compatible' on 'Overloads': parameter 2\\"
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[2];
            if (curArg !== undefined) {
              curArg = conversions[\\"long\\"](curArg, {
                context: \\"Failed to execute 'compatible' on 'Overloads': parameter 3\\"
              });
            } else {
              curArg = 0;
            }
            args.push(curArg);
          }
      }
      return utils.tryWrapperForImpl(esValue[implSymbol].compatible(...args));
    }

    incompatible1(arg1) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'incompatible1' on 'Overloads': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (typeof curArg === \\"number\\") {
          {
            let curArg = arguments[0];
            curArg = conversions[\\"long\\"](curArg, {
              context: \\"Failed to execute 'incompatible1' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
        } else {
          {
            let curArg = arguments[0];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'incompatible1' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
        }
      }
      return esValue[implSymbol].incompatible1(...args);
    }

    incompatible2(arg1) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'incompatible2' on 'Overloads': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      switch (arguments.length) {
        case 1:
          {
            let curArg = arguments[0];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'incompatible2' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
          break;
        default:
          {
            let curArg = arguments[0];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'incompatible2' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'incompatible2' on 'Overloads': parameter 2\\"
            });
            args.push(curArg);
          }
      }
      return esValue[implSymbol].incompatible2(...args);
    }

    incompatible3(arg1) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'incompatible3' on 'Overloads': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      switch (arguments.length) {
        case 1:
          {
            let curArg = arguments[0];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'incompatible3' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
          break;
        case 2:
          {
            let curArg = arguments[0];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'incompatible3' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            if (curArg === undefined) {
              {
                let curArg = arguments[1];
                if (curArg !== undefined) {
                  curArg = URL.convert(curArg, {
                    context: \\"Failed to execute 'incompatible3' on 'Overloads': parameter 2\\"
                  });
                }
                args.push(curArg);
              }
            } else if (URL.is(curArg)) {
              {
                let curArg = arguments[1];
                if (curArg !== undefined) {
                  curArg = URL.convert(curArg, {
                    context: \\"Failed to execute 'incompatible3' on 'Overloads': parameter 2\\"
                  });
                }
                args.push(curArg);
              }
            } else if (utils.isArrayBuffer(curArg)) {
              {
                let curArg = arguments[1];
                if (utils.isArrayBuffer(curArg)) {
                } else if (ArrayBuffer.isView(curArg)) {
                } else {
                  throw new TypeError(
                    \\"Failed to execute 'incompatible3' on 'Overloads': parameter 2\\" + \\" is not of any supported type.\\"
                  );
                }
                args.push(curArg);
              }
            } else if (ArrayBuffer.isView(curArg)) {
              {
                let curArg = arguments[1];
                if (utils.isArrayBuffer(curArg)) {
                } else if (ArrayBuffer.isView(curArg)) {
                } else {
                  throw new TypeError(
                    \\"Failed to execute 'incompatible3' on 'Overloads': parameter 2\\" + \\" is not of any supported type.\\"
                  );
                }
                args.push(curArg);
              }
            } else {
              {
                let curArg = arguments[1];
                curArg = conversions[\\"DOMString\\"](curArg, {
                  context: \\"Failed to execute 'incompatible3' on 'Overloads': parameter 2\\"
                });
                args.push(curArg);
              }
            }
          }
          break;
        case 3:
          throw new TypeError(
            \\"Failed to execute 'incompatible3' on 'Overloads': only \\" + arguments.length + \\" arguments present.\\"
          );
          break;
        default:
          {
            let curArg = arguments[0];
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'incompatible3' on 'Overloads': parameter 1\\"
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            curArg = conversions[\\"long\\"](curArg, {
              context: \\"Failed to execute 'incompatible3' on 'Overloads': parameter 2\\"
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[2];
            if (utils.isArrayBuffer(curArg)) {
            } else if (ArrayBuffer.isView(curArg)) {
            } else {
              throw new TypeError(
                \\"Failed to execute 'incompatible3' on 'Overloads': parameter 3\\" + \\" is not of any supported type.\\"
              );
            }
            args.push(curArg);
          }
          {
            let curArg = arguments[3];
            if (utils.isArrayBuffer(curArg)) {
            } else if (ArrayBuffer.isView(curArg)) {
            } else {
              throw new TypeError(
                \\"Failed to execute 'incompatible3' on 'Overloads': parameter 4\\" + \\" is not of any supported type.\\"
              );
            }
            args.push(curArg);
          }
      }
      return esValue[implSymbol].incompatible3(...args);
    }
  }
  Object.defineProperties(Overloads.prototype, {
    compatible: { enumerable: true },
    incompatible1: { enumerable: true },
    incompatible2: { enumerable: true },
    incompatible3: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"Overloads\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = Overloads;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: Overloads
  });
};

const Impl = require(\\"../implementations/Overloads.js\\");
"
`;

exports[`without processors PromiseTypes.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"PromiseTypes\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'PromiseTypes'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"PromiseTypes\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor PromiseTypes is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {
  Object.defineProperties(
    wrapper,
    Object.getOwnPropertyDescriptors({
      unforgeablePromiseOperation() {
        try {
          const esValue = this !== null && this !== undefined ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new TypeError(\\"Illegal invocation\\");
          }

          return utils.tryWrapperForImpl(esValue[implSymbol].unforgeablePromiseOperation());
        } catch (e) {
          return Promise.reject(e);
        }
      },
      get unforgeablePromiseAttribute() {
        try {
          const esValue = this !== null && this !== undefined ? this : globalObject;

          if (!exports.is(esValue)) {
            throw new TypeError(\\"Illegal invocation\\");
          }

          return utils.tryWrapperForImpl(esValue[implSymbol][\\"unforgeablePromiseAttribute\\"]);
        } catch (e) {
          return Promise.reject(e);
        }
      }
    })
  );

  Object.defineProperties(wrapper, {
    unforgeablePromiseOperation: { configurable: false, writable: false },
    unforgeablePromiseAttribute: { configurable: false }
  });
};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class PromiseTypes {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    voidPromiseConsumer(p) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'voidPromiseConsumer' on 'PromiseTypes': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = Promise.resolve(curArg).then(
          value => {},
          reason => reason
        );
        args.push(curArg);
      }
      return esValue[implSymbol].voidPromiseConsumer(...args);
    }

    promiseConsumer(p) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'promiseConsumer' on 'PromiseTypes': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = Promise.resolve(curArg).then(
          value => {
            value = conversions[\\"double\\"](value, {
              context: \\"Failed to execute 'promiseConsumer' on 'PromiseTypes': parameter 1\\" + \\" promise value\\"
            });

            return value;
          },
          reason => reason
        );
        args.push(curArg);
      }
      return esValue[implSymbol].promiseConsumer(...args);
    }

    promiseOperation() {
      try {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return utils.tryWrapperForImpl(esValue[implSymbol].promiseOperation());
      } catch (e) {
        return Promise.reject(e);
      }
    }

    get promiseAttribute() {
      try {
        const esValue = this !== null && this !== undefined ? this : globalObject;

        if (!exports.is(esValue)) {
          throw new TypeError(\\"Illegal invocation\\");
        }

        return utils.tryWrapperForImpl(esValue[implSymbol][\\"promiseAttribute\\"]);
      } catch (e) {
        return Promise.reject(e);
      }
    }

    static staticPromiseOperation() {
      try {
        return utils.tryWrapperForImpl(Impl.implementation.staticPromiseOperation());
      } catch (e) {
        return Promise.reject(e);
      }
    }

    static get staticPromiseAttribute() {
      try {
        const esValue = this !== null && this !== undefined ? this : globalObject;

        return Impl.implementation[\\"staticPromiseAttribute\\"];
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }
  Object.defineProperties(PromiseTypes.prototype, {
    voidPromiseConsumer: { enumerable: true },
    promiseConsumer: { enumerable: true },
    promiseOperation: { enumerable: true },
    promiseAttribute: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"PromiseTypes\\", configurable: true }
  });
  Object.defineProperties(PromiseTypes, {
    staticPromiseOperation: { enumerable: true },
    staticPromiseAttribute: { enumerable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = PromiseTypes;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: PromiseTypes
  });
};

const Impl = require(\\"../implementations/PromiseTypes.js\\");
"
`;

exports[`without processors Reflect.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"Reflect\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'Reflect'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"Reflect\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor Reflect is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class Reflect {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    get reflectedBoolean() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"reflectedBoolean\\"];
    }

    set reflectedBoolean(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"boolean\\"](V, {
        context: \\"Failed to set the 'reflectedBoolean' property on 'Reflect': The provided value\\"
      });

      esValue[implSymbol][\\"reflectedBoolean\\"] = V;
    }

    get reflectedDOMString() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"reflectedDOMString\\"];
    }

    set reflectedDOMString(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"DOMString\\"](V, {
        context: \\"Failed to set the 'reflectedDOMString' property on 'Reflect': The provided value\\"
      });

      esValue[implSymbol][\\"reflectedDOMString\\"] = V;
    }

    get reflectedLong() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"reflectedLong\\"];
    }

    set reflectedLong(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"long\\"](V, {
        context: \\"Failed to set the 'reflectedLong' property on 'Reflect': The provided value\\"
      });

      esValue[implSymbol][\\"reflectedLong\\"] = V;
    }

    get reflectedUnsignedLong() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"reflectedUnsignedLong\\"];
    }

    set reflectedUnsignedLong(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"unsigned long\\"](V, {
        context: \\"Failed to set the 'reflectedUnsignedLong' property on 'Reflect': The provided value\\"
      });

      esValue[implSymbol][\\"reflectedUnsignedLong\\"] = V;
    }

    get reflectedUSVStringURL() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"reflectedUSVStringURL\\"];
    }

    set reflectedUSVStringURL(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, {
        context: \\"Failed to set the 'reflectedUSVStringURL' property on 'Reflect': The provided value\\"
      });

      esValue[implSymbol][\\"reflectedUSVStringURL\\"] = V;
    }

    get reflectionTest() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"reflectionTest\\"];
    }

    set reflectionTest(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"DOMString\\"](V, {
        context: \\"Failed to set the 'reflectionTest' property on 'Reflect': The provided value\\"
      });

      esValue[implSymbol][\\"reflectionTest\\"] = V;
    }

    get withUnderscore() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"withUnderscore\\"];
    }

    set withUnderscore(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"DOMString\\"](V, {
        context: \\"Failed to set the 'withUnderscore' property on 'Reflect': The provided value\\"
      });

      esValue[implSymbol][\\"withUnderscore\\"] = V;
    }
  }
  Object.defineProperties(Reflect.prototype, {
    reflectedBoolean: { enumerable: true },
    reflectedDOMString: { enumerable: true },
    reflectedLong: { enumerable: true },
    reflectedUnsignedLong: { enumerable: true },
    reflectedUSVStringURL: { enumerable: true },
    reflectionTest: { enumerable: true },
    withUnderscore: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"Reflect\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = Reflect;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: Reflect
  });
};

const Impl = require(\\"../implementations/Reflect.js\\");
"
`;

exports[`without processors Replaceable.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"Replaceable\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'Replaceable'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"Replaceable\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor Replaceable is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class Replaceable {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    get replaceable() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"replaceable\\"];
    }

    set replaceable(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      Object.defineProperty(esValue, \\"replaceable\\", {
        configurable: true,
        enumerable: true,
        value: V,
        writable: true
      });
    }
  }
  Object.defineProperties(Replaceable.prototype, {
    replaceable: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"Replaceable\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = Replaceable;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: Replaceable
  });
};

const Impl = require(\\"../implementations/Replaceable.js\\");
"
`;

exports[`without processors RequestDestination.webidl 1`] = `
"\\"use strict\\";

const enumerationValues = new Set([
  \\"\\",
  \\"audio\\",
  \\"document\\",
  \\"embed\\",
  \\"font\\",
  \\"image\\",
  \\"manifest\\",
  \\"object\\",
  \\"report\\",
  \\"script\\",
  \\"sharedworker\\",
  \\"style\\",
  \\"track\\",
  \\"video\\",
  \\"worker\\",
  \\"xslt\\"
]);
exports.enumerationValues = enumerationValues;

exports.convert = function convert(value, { context = \\"The provided value\\" } = {}) {
  const string = \`\${value}\`;
  if (!enumerationValues.has(string)) {
    throw new TypeError(\`\${context} '\${string}' is not a valid enumeration value for RequestDestination\`);
  }
  return string;
};
"
`;

exports[`without processors SeqAndRec.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const URL = require(\\"./URL.js\\");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"SeqAndRec\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'SeqAndRec'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"SeqAndRec\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor SeqAndRec is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class SeqAndRec {
    constructor() {
      return exports.setup(Object.create(new.target.prototype), globalObject, undefined);
    }

    recordConsumer(rec) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'recordConsumer' on 'SeqAndRec': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (!utils.isObject(curArg)) {
          throw new TypeError(\\"Failed to execute 'recordConsumer' on 'SeqAndRec': parameter 1\\" + \\" is not an object.\\");
        } else {
          const result = Object.create(null);
          for (const key of Reflect.ownKeys(curArg)) {
            const desc = Object.getOwnPropertyDescriptor(curArg, key);
            if (desc && desc.enumerable) {
              let typedKey = key;

              typedKey = conversions[\\"USVString\\"](typedKey, {
                context: \\"Failed to execute 'recordConsumer' on 'SeqAndRec': parameter 1\\" + \\"'s key\\"
              });

              let typedValue = curArg[key];

              typedValue = conversions[\\"double\\"](typedValue, {
                context: \\"Failed to execute 'recordConsumer' on 'SeqAndRec': parameter 1\\" + \\"'s value\\"
              });

              result[typedKey] = typedValue;
            }
          }
          curArg = result;
        }
        args.push(curArg);
      }
      return esValue[implSymbol].recordConsumer(...args);
    }

    recordConsumer2(rec) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'recordConsumer2' on 'SeqAndRec': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (!utils.isObject(curArg)) {
          throw new TypeError(\\"Failed to execute 'recordConsumer2' on 'SeqAndRec': parameter 1\\" + \\" is not an object.\\");
        } else {
          const result = Object.create(null);
          for (const key of Reflect.ownKeys(curArg)) {
            const desc = Object.getOwnPropertyDescriptor(curArg, key);
            if (desc && desc.enumerable) {
              let typedKey = key;

              typedKey = conversions[\\"USVString\\"](typedKey, {
                context: \\"Failed to execute 'recordConsumer2' on 'SeqAndRec': parameter 1\\" + \\"'s key\\"
              });

              let typedValue = curArg[key];

              typedValue = URL.convert(typedValue, {
                context: \\"Failed to execute 'recordConsumer2' on 'SeqAndRec': parameter 1\\" + \\"'s value\\"
              });

              result[typedKey] = typedValue;
            }
          }
          curArg = result;
        }
        args.push(curArg);
      }
      return esValue[implSymbol].recordConsumer2(...args);
    }

    sequenceConsumer(seq) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'sequenceConsumer' on 'SeqAndRec': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (!utils.isObject(curArg)) {
          throw new TypeError(
            \\"Failed to execute 'sequenceConsumer' on 'SeqAndRec': parameter 1\\" + \\" is not an iterable object.\\"
          );
        } else {
          const V = [];
          const tmp = curArg;
          for (let nextItem of tmp) {
            nextItem = conversions[\\"USVString\\"](nextItem, {
              context: \\"Failed to execute 'sequenceConsumer' on 'SeqAndRec': parameter 1\\" + \\"'s element\\"
            });

            V.push(nextItem);
          }
          curArg = V;
        }
        args.push(curArg);
      }
      return esValue[implSymbol].sequenceConsumer(...args);
    }

    sequenceConsumer2(seq) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'sequenceConsumer2' on 'SeqAndRec': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (!utils.isObject(curArg)) {
          throw new TypeError(
            \\"Failed to execute 'sequenceConsumer2' on 'SeqAndRec': parameter 1\\" + \\" is not an iterable object.\\"
          );
        } else {
          const V = [];
          const tmp = curArg;
          for (let nextItem of tmp) {
            nextItem = utils.tryImplForWrapper(nextItem);

            V.push(nextItem);
          }
          curArg = V;
        }
        args.push(curArg);
      }
      return esValue[implSymbol].sequenceConsumer2(...args);
    }

    frozenArrayConsumer(arr) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'frozenArrayConsumer' on 'SeqAndRec': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (!utils.isObject(curArg)) {
          throw new TypeError(
            \\"Failed to execute 'frozenArrayConsumer' on 'SeqAndRec': parameter 1\\" + \\" is not an iterable object.\\"
          );
        } else {
          const V = [];
          const tmp = curArg;
          for (let nextItem of tmp) {
            nextItem = conversions[\\"double\\"](nextItem, {
              context: \\"Failed to execute 'frozenArrayConsumer' on 'SeqAndRec': parameter 1\\" + \\"'s element\\"
            });

            V.push(nextItem);
          }
          curArg = V;
        }
        curArg = Object.freeze(curArg);
        args.push(curArg);
      }
      return esValue[implSymbol].frozenArrayConsumer(...args);
    }
  }
  Object.defineProperties(SeqAndRec.prototype, {
    recordConsumer: { enumerable: true },
    recordConsumer2: { enumerable: true },
    sequenceConsumer: { enumerable: true },
    sequenceConsumer2: { enumerable: true },
    frozenArrayConsumer: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"SeqAndRec\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = SeqAndRec;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: SeqAndRec
  });
};

const Impl = require(\\"../implementations/SeqAndRec.js\\");
"
`;

exports[`without processors Static.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"Static\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'Static'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"Static\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor Static is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class Static {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    def() {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol].def();
    }

    get abc() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"abc\\"];
    }

    set abc(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"DOMString\\"](V, { context: \\"Failed to set the 'abc' property on 'Static': The provided value\\" });

      esValue[implSymbol][\\"abc\\"] = V;
    }

    static def() {
      return Impl.implementation.def();
    }

    static get abc() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      return Impl.implementation[\\"abc\\"];
    }

    static set abc(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      return Impl.implementation[\\"abc\\"];
    }
  }
  Object.defineProperties(Static.prototype, {
    def: { enumerable: true },
    abc: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"Static\\", configurable: true }
  });
  Object.defineProperties(Static, { def: { enumerable: true }, abc: { enumerable: true } });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = Static;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: Static
  });
};

const Impl = require(\\"../implementations/Static.js\\");
"
`;

exports[`without processors Storage.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"Storage\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'Storage'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"Storage\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor Storage is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper = new Proxy(wrapper, proxyHandler);

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper = new Proxy(wrapper, proxyHandler);

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class Storage {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    key(index) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'key' on 'Storage': 1 argument required, but only \\" + arguments.length + \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"unsigned long\\"](curArg, { context: \\"Failed to execute 'key' on 'Storage': parameter 1\\" });
        args.push(curArg);
      }
      return esValue[implSymbol].key(...args);
    }

    getItem(key) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'getItem' on 'Storage': 1 argument required, but only \\" + arguments.length + \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"DOMString\\"](curArg, { context: \\"Failed to execute 'getItem' on 'Storage': parameter 1\\" });
        args.push(curArg);
      }
      return esValue[implSymbol].getItem(...args);
    }

    setItem(key, value) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 2) {
        throw new TypeError(
          \\"Failed to execute 'setItem' on 'Storage': 2 arguments required, but only \\" + arguments.length + \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"DOMString\\"](curArg, { context: \\"Failed to execute 'setItem' on 'Storage': parameter 1\\" });
        args.push(curArg);
      }
      {
        let curArg = arguments[1];
        curArg = conversions[\\"DOMString\\"](curArg, { context: \\"Failed to execute 'setItem' on 'Storage': parameter 2\\" });
        args.push(curArg);
      }
      return esValue[implSymbol].setItem(...args);
    }

    removeItem(key) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'removeItem' on 'Storage': 1 argument required, but only \\" + arguments.length + \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'removeItem' on 'Storage': parameter 1\\"
        });
        args.push(curArg);
      }
      return esValue[implSymbol].removeItem(...args);
    }

    clear() {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol].clear();
    }

    get length() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"length\\"];
    }
  }
  Object.defineProperties(Storage.prototype, {
    key: { enumerable: true },
    getItem: { enumerable: true },
    setItem: { enumerable: true },
    removeItem: { enumerable: true },
    clear: { enumerable: true },
    length: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"Storage\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = Storage;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: Storage
  });
};

const proxyHandler = {
  get(target, P, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.get(target, P, receiver);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc === undefined) {
      const parent = Object.getPrototypeOf(target);
      if (parent === null) {
        return undefined;
      }
      return Reflect.get(target, P, receiver);
    }
    if (!desc.get && !desc.set) {
      return desc.value;
    }
    const getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return Reflect.apply(getter, receiver, []);
  },

  has(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.has(target, P);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc !== undefined) {
      return true;
    }
    const parent = Object.getPrototypeOf(target);
    if (parent !== null) {
      return Reflect.has(parent, P);
    }
    return false;
  },

  ownKeys(target) {
    const keys = new Set();

    for (const key of target[implSymbol][utils.supportedPropertyNames]) {
      if (!(key in target)) {
        keys.add(\`\${key}\`);
      }
    }

    for (const key of Reflect.ownKeys(target)) {
      keys.add(key);
    }
    return [...keys];
  },

  getOwnPropertyDescriptor(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.getOwnPropertyDescriptor(target, P);
    }
    let ignoreNamedProps = false;

    if (target[implSymbol][utils.supportsPropertyName](P) && !(P in target) && !ignoreNamedProps) {
      const namedValue = target[implSymbol].getItem(P);

      return {
        writable: true,
        enumerable: true,
        configurable: true,
        value: utils.tryWrapperForImpl(namedValue)
      };
    }

    return Reflect.getOwnPropertyDescriptor(target, P);
  },

  set(target, P, V, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.set(target, P, V, receiver);
    }
    if (target === receiver) {
      if (typeof P === \\"string\\" && !utils.isArrayIndexPropName(P)) {
        let namedValue = V;

        namedValue = conversions[\\"DOMString\\"](namedValue, {
          context: \\"Failed to set the '\\" + P + \\"' property on 'Storage': The provided value\\"
        });

        target[implSymbol].setItem(P, namedValue);

        return true;
      }
    }
    let ownDesc;

    if (ownDesc === undefined) {
      ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
    }
    if (ownDesc === undefined) {
      const parent = Reflect.getPrototypeOf(target);
      if (parent !== null) {
        return Reflect.set(parent, P, V, receiver);
      }
      ownDesc = { writable: true, enumerable: true, configurable: true, value: undefined };
    }
    if (!ownDesc.writable) {
      return false;
    }
    if (!utils.isObject(receiver)) {
      return false;
    }
    const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
    let valueDesc;
    if (existingDesc !== undefined) {
      if (existingDesc.get || existingDesc.set) {
        return false;
      }
      if (!existingDesc.writable) {
        return false;
      }
      valueDesc = { value: V };
    } else {
      valueDesc = { writable: true, enumerable: true, configurable: true, value: V };
    }
    return Reflect.defineProperty(receiver, P, valueDesc);
  },

  defineProperty(target, P, desc) {
    if (typeof P === \\"symbol\\") {
      return Reflect.defineProperty(target, P, desc);
    }
    if (!utils.hasOwn(target, P)) {
      if (desc.get || desc.set) {
        return false;
      }

      let namedValue = desc.value;

      namedValue = conversions[\\"DOMString\\"](namedValue, {
        context: \\"Failed to set the '\\" + P + \\"' property on 'Storage': The provided value\\"
      });

      target[implSymbol].setItem(P, namedValue);

      return true;
    }
    return Reflect.defineProperty(target, P, desc);
  },

  deleteProperty(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.deleteProperty(target, P);
    }

    if (target[implSymbol][utils.supportsPropertyName](P) && !(P in target)) {
      target[implSymbol].removeItem(P);
      return true;
    }

    return Reflect.deleteProperty(target, P);
  },

  preventExtensions() {
    return false;
  }
};

const Impl = require(\\"../implementations/Storage.js\\");
"
`;

exports[`without processors StringifierAttribute.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"StringifierAttribute\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'StringifierAttribute'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"StringifierAttribute\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor StringifierAttribute is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class StringifierAttribute {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    get attr() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"attr\\"];
    }

    toString() {
      const esValue = this;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"attr\\"];
    }
  }
  Object.defineProperties(StringifierAttribute.prototype, {
    attr: { enumerable: true },
    toString: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"StringifierAttribute\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = StringifierAttribute;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: StringifierAttribute
  });
};

const Impl = require(\\"../implementations/StringifierAttribute.js\\");
"
`;

exports[`without processors StringifierDefaultOperation.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"StringifierDefaultOperation\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'StringifierDefaultOperation'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"StringifierDefaultOperation\\"];
  if (ctor === undefined) {
    throw new Error(
      \\"Internal error: constructor StringifierDefaultOperation is not installed on the passed global object\\"
    );
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class StringifierDefaultOperation {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    toString() {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol].toString();
    }
  }
  Object.defineProperties(StringifierDefaultOperation.prototype, {
    toString: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"StringifierDefaultOperation\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = StringifierDefaultOperation;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: StringifierDefaultOperation
  });
};

const Impl = require(\\"../implementations/StringifierDefaultOperation.js\\");
"
`;

exports[`without processors StringifierNamedOperation.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"StringifierNamedOperation\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'StringifierNamedOperation'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"StringifierNamedOperation\\"];
  if (ctor === undefined) {
    throw new Error(
      \\"Internal error: constructor StringifierNamedOperation is not installed on the passed global object\\"
    );
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class StringifierNamedOperation {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    operation() {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol].operation();
    }

    toString() {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol].operation();
    }
  }
  Object.defineProperties(StringifierNamedOperation.prototype, {
    operation: { enumerable: true },
    toString: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"StringifierNamedOperation\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = StringifierNamedOperation;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: StringifierNamedOperation
  });
};

const Impl = require(\\"../implementations/StringifierNamedOperation.js\\");
"
`;

exports[`without processors StringifierOperation.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"StringifierOperation\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'StringifierOperation'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"StringifierOperation\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor StringifierOperation is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class StringifierOperation {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    toString() {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol].toString();
    }
  }
  Object.defineProperties(StringifierOperation.prototype, {
    toString: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"StringifierOperation\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = StringifierOperation;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: StringifierOperation
  });
};

const Impl = require(\\"../implementations/StringifierOperation.js\\");
"
`;

exports[`without processors TypedefsAndUnions.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const RequestDestination = require(\\"./RequestDestination.js\\");
const URL = require(\\"./URL.js\\");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"TypedefsAndUnions\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'TypedefsAndUnions'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"TypedefsAndUnions\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor TypedefsAndUnions is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class TypedefsAndUnions {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    numOrStrConsumer(a) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'numOrStrConsumer' on 'TypedefsAndUnions': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (typeof curArg === \\"number\\") {
          curArg = conversions[\\"double\\"](curArg, {
            context: \\"Failed to execute 'numOrStrConsumer' on 'TypedefsAndUnions': parameter 1\\",
            clamp: true
          });
        } else {
          curArg = conversions[\\"DOMString\\"](curArg, {
            context: \\"Failed to execute 'numOrStrConsumer' on 'TypedefsAndUnions': parameter 1\\"
          });
        }
        args.push(curArg);
      }
      return esValue[implSymbol].numOrStrConsumer(...args);
    }

    numOrEnumConsumer(a) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'numOrEnumConsumer' on 'TypedefsAndUnions': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg === null || curArg === undefined) {
          curArg = null;
        } else {
          if (typeof curArg === \\"number\\") {
            curArg = conversions[\\"double\\"](curArg, {
              context: \\"Failed to execute 'numOrEnumConsumer' on 'TypedefsAndUnions': parameter 1\\"
            });
          } else {
            curArg = RequestDestination.convert(curArg, {
              context: \\"Failed to execute 'numOrEnumConsumer' on 'TypedefsAndUnions': parameter 1\\"
            });
          }
        }
        args.push(curArg);
      }
      return esValue[implSymbol].numOrEnumConsumer(...args);
    }

    numOrStrOrNullConsumer(a) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'numOrStrOrNullConsumer' on 'TypedefsAndUnions': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg === null || curArg === undefined) {
          curArg = null;
        } else {
          if (typeof curArg === \\"number\\") {
            curArg = conversions[\\"double\\"](curArg, {
              context: \\"Failed to execute 'numOrStrOrNullConsumer' on 'TypedefsAndUnions': parameter 1\\",
              clamp: true,
              enforceRange: true
            });
          } else {
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'numOrStrOrNullConsumer' on 'TypedefsAndUnions': parameter 1\\",
              enforceRange: true
            });
          }
        }
        args.push(curArg);
      }
      return esValue[implSymbol].numOrStrOrNullConsumer(...args);
    }

    numOrStrOrURLOrNullConsumer(a) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'numOrStrOrURLOrNullConsumer' on 'TypedefsAndUnions': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg === null || curArg === undefined) {
          curArg = null;
        } else {
          if (URL.is(curArg)) {
            curArg = utils.implForWrapper(curArg);
          } else if (typeof curArg === \\"number\\") {
            curArg = conversions[\\"double\\"](curArg, {
              context: \\"Failed to execute 'numOrStrOrURLOrNullConsumer' on 'TypedefsAndUnions': parameter 1\\",
              clamp: true,
              enforceRange: true
            });
          } else {
            curArg = conversions[\\"DOMString\\"](curArg, {
              context: \\"Failed to execute 'numOrStrOrURLOrNullConsumer' on 'TypedefsAndUnions': parameter 1\\",
              enforceRange: true
            });
          }
        }
        args.push(curArg);
      }
      return esValue[implSymbol].numOrStrOrURLOrNullConsumer(...args);
    }

    urlMapInnerConsumer(a) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'urlMapInnerConsumer' on 'TypedefsAndUnions': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (!utils.isObject(curArg)) {
          throw new TypeError(
            \\"Failed to execute 'urlMapInnerConsumer' on 'TypedefsAndUnions': parameter 1\\" + \\" is not an object.\\"
          );
        } else {
          const result = Object.create(null);
          for (const key of Reflect.ownKeys(curArg)) {
            const desc = Object.getOwnPropertyDescriptor(curArg, key);
            if (desc && desc.enumerable) {
              let typedKey = key;

              typedKey = conversions[\\"USVString\\"](typedKey, {
                context: \\"Failed to execute 'urlMapInnerConsumer' on 'TypedefsAndUnions': parameter 1\\" + \\"'s key\\"
              });

              let typedValue = curArg[key];

              typedValue = URL.convert(typedValue, {
                context: \\"Failed to execute 'urlMapInnerConsumer' on 'TypedefsAndUnions': parameter 1\\" + \\"'s value\\"
              });

              result[typedKey] = typedValue;
            }
          }
          curArg = result;
        }
        args.push(curArg);
      }
      return esValue[implSymbol].urlMapInnerConsumer(...args);
    }

    urlMapConsumer(a) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'urlMapConsumer' on 'TypedefsAndUnions': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg === null || curArg === undefined) {
          curArg = null;
        } else {
          if (!utils.isObject(curArg)) {
            throw new TypeError(
              \\"Failed to execute 'urlMapConsumer' on 'TypedefsAndUnions': parameter 1\\" + \\" is not an object.\\"
            );
          } else {
            const result = Object.create(null);
            for (const key of Reflect.ownKeys(curArg)) {
              const desc = Object.getOwnPropertyDescriptor(curArg, key);
              if (desc && desc.enumerable) {
                let typedKey = key;

                typedKey = conversions[\\"USVString\\"](typedKey, {
                  context: \\"Failed to execute 'urlMapConsumer' on 'TypedefsAndUnions': parameter 1\\" + \\"'s key\\"
                });

                let typedValue = curArg[key];

                typedValue = URL.convert(typedValue, {
                  context: \\"Failed to execute 'urlMapConsumer' on 'TypedefsAndUnions': parameter 1\\" + \\"'s value\\"
                });

                result[typedKey] = typedValue;
              }
            }
            curArg = result;
          }
        }
        args.push(curArg);
      }
      return esValue[implSymbol].urlMapConsumer(...args);
    }

    bufferSourceOrURLConsumer(b) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'bufferSourceOrURLConsumer' on 'TypedefsAndUnions': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (URL.is(curArg)) {
          curArg = utils.implForWrapper(curArg);
        } else if (utils.isArrayBuffer(curArg)) {
        } else if (ArrayBuffer.isView(curArg)) {
        } else {
          throw new TypeError(
            \\"Failed to execute 'bufferSourceOrURLConsumer' on 'TypedefsAndUnions': parameter 1\\" +
              \\" is not of any supported type.\\"
          );
        }
        args.push(curArg);
      }
      return esValue[implSymbol].bufferSourceOrURLConsumer(...args);
    }

    arrayBufferViewOrURLMapConsumer(b) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'arrayBufferViewOrURLMapConsumer' on 'TypedefsAndUnions': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg === null || curArg === undefined) {
          curArg = null;
        } else {
          if (ArrayBuffer.isView(curArg)) {
          } else if (utils.isObject(curArg)) {
            if (!utils.isObject(curArg)) {
              throw new TypeError(
                \\"Failed to execute 'arrayBufferViewOrURLMapConsumer' on 'TypedefsAndUnions': parameter 1\\" +
                  \\" record\\" +
                  \\" is not an object.\\"
              );
            } else {
              const result = Object.create(null);
              for (const key of Reflect.ownKeys(curArg)) {
                const desc = Object.getOwnPropertyDescriptor(curArg, key);
                if (desc && desc.enumerable) {
                  let typedKey = key;

                  typedKey = conversions[\\"USVString\\"](typedKey, {
                    context:
                      \\"Failed to execute 'arrayBufferViewOrURLMapConsumer' on 'TypedefsAndUnions': parameter 1\\" +
                      \\" record\\" +
                      \\"'s key\\"
                  });

                  let typedValue = curArg[key];

                  typedValue = URL.convert(typedValue, {
                    context:
                      \\"Failed to execute 'arrayBufferViewOrURLMapConsumer' on 'TypedefsAndUnions': parameter 1\\" +
                      \\" record\\" +
                      \\"'s value\\"
                  });

                  result[typedKey] = typedValue;
                }
              }
              curArg = result;
            }
          } else {
            throw new TypeError(
              \\"Failed to execute 'arrayBufferViewOrURLMapConsumer' on 'TypedefsAndUnions': parameter 1\\" +
                \\" is not of any supported type.\\"
            );
          }
        }
        args.push(curArg);
      }
      return esValue[implSymbol].arrayBufferViewOrURLMapConsumer(...args);
    }

    arrayBufferViewDupConsumer(b) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'arrayBufferViewDupConsumer' on 'TypedefsAndUnions': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (ArrayBuffer.isView(curArg)) {
        } else {
          throw new TypeError(
            \\"Failed to execute 'arrayBufferViewDupConsumer' on 'TypedefsAndUnions': parameter 1\\" +
              \\" is not of any supported type.\\"
          );
        }
        args.push(curArg);
      }
      return esValue[implSymbol].arrayBufferViewDupConsumer(...args);
    }

    get buf() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return utils.tryWrapperForImpl(esValue[implSymbol][\\"buf\\"]);
    }

    set buf(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (utils.isArrayBuffer(V)) {
      } else if (
        ArrayBuffer.isView(V) &&
        (V.constructor.name === \\"Uint8Array\\" || V.constructor.name === \\"Uint16Array\\")
      ) {
      } else {
        throw new TypeError(
          \\"Failed to set the 'buf' property on 'TypedefsAndUnions': The provided value\\" +
            \\" is not of any supported type.\\"
        );
      }
      esValue[implSymbol][\\"buf\\"] = V;
    }

    get time() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"time\\"];
    }

    set time(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"unsigned long long\\"](V, {
        context: \\"Failed to set the 'time' property on 'TypedefsAndUnions': The provided value\\"
      });

      esValue[implSymbol][\\"time\\"] = V;
    }
  }
  Object.defineProperties(TypedefsAndUnions.prototype, {
    numOrStrConsumer: { enumerable: true },
    numOrEnumConsumer: { enumerable: true },
    numOrStrOrNullConsumer: { enumerable: true },
    numOrStrOrURLOrNullConsumer: { enumerable: true },
    urlMapInnerConsumer: { enumerable: true },
    urlMapConsumer: { enumerable: true },
    bufferSourceOrURLConsumer: { enumerable: true },
    arrayBufferViewOrURLMapConsumer: { enumerable: true },
    arrayBufferViewDupConsumer: { enumerable: true },
    buf: { enumerable: true },
    time: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"TypedefsAndUnions\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = TypedefsAndUnions;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: TypedefsAndUnions
  });
};

const Impl = require(\\"../implementations/TypedefsAndUnions.js\\");
"
`;

exports[`without processors URL.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"URL\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'URL'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"URL\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor URL is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\", \\"Worker\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class URL {
    constructor(url) {
      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to construct 'URL': 1 argument required, but only \\" + arguments.length + \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"USVString\\"](curArg, { context: \\"Failed to construct 'URL': parameter 1\\" });
        args.push(curArg);
      }
      {
        let curArg = arguments[1];
        if (curArg !== undefined) {
          curArg = conversions[\\"USVString\\"](curArg, { context: \\"Failed to construct 'URL': parameter 2\\" });
        }
        args.push(curArg);
      }
      return exports.setup(Object.create(new.target.prototype), globalObject, args);
    }

    toJSON() {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol].toJSON();
    }

    get href() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"href\\"];
    }

    set href(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, { context: \\"Failed to set the 'href' property on 'URL': The provided value\\" });

      esValue[implSymbol][\\"href\\"] = V;
    }

    toString() {
      const esValue = this;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"href\\"];
    }

    get origin() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"origin\\"];
    }

    get protocol() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"protocol\\"];
    }

    set protocol(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, {
        context: \\"Failed to set the 'protocol' property on 'URL': The provided value\\"
      });

      esValue[implSymbol][\\"protocol\\"] = V;
    }

    get username() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"username\\"];
    }

    set username(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, {
        context: \\"Failed to set the 'username' property on 'URL': The provided value\\"
      });

      esValue[implSymbol][\\"username\\"] = V;
    }

    get password() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"password\\"];
    }

    set password(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, {
        context: \\"Failed to set the 'password' property on 'URL': The provided value\\"
      });

      esValue[implSymbol][\\"password\\"] = V;
    }

    get host() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"host\\"];
    }

    set host(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, { context: \\"Failed to set the 'host' property on 'URL': The provided value\\" });

      esValue[implSymbol][\\"host\\"] = V;
    }

    get hostname() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"hostname\\"];
    }

    set hostname(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, {
        context: \\"Failed to set the 'hostname' property on 'URL': The provided value\\"
      });

      esValue[implSymbol][\\"hostname\\"] = V;
    }

    get port() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"port\\"];
    }

    set port(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, { context: \\"Failed to set the 'port' property on 'URL': The provided value\\" });

      esValue[implSymbol][\\"port\\"] = V;
    }

    get pathname() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"pathname\\"];
    }

    set pathname(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, {
        context: \\"Failed to set the 'pathname' property on 'URL': The provided value\\"
      });

      esValue[implSymbol][\\"pathname\\"] = V;
    }

    get search() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"search\\"];
    }

    set search(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, { context: \\"Failed to set the 'search' property on 'URL': The provided value\\" });

      esValue[implSymbol][\\"search\\"] = V;
    }

    get searchParams() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return utils.getSameObject(this, \\"searchParams\\", () => {
        return utils.tryWrapperForImpl(esValue[implSymbol][\\"searchParams\\"]);
      });
    }

    get hash() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"hash\\"];
    }

    set hash(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"USVString\\"](V, { context: \\"Failed to set the 'hash' property on 'URL': The provided value\\" });

      esValue[implSymbol][\\"hash\\"] = V;
    }
  }
  Object.defineProperties(URL.prototype, {
    toJSON: { enumerable: true },
    href: { enumerable: true },
    toString: { enumerable: true },
    origin: { enumerable: true },
    protocol: { enumerable: true },
    username: { enumerable: true },
    password: { enumerable: true },
    host: { enumerable: true },
    hostname: { enumerable: true },
    port: { enumerable: true },
    pathname: { enumerable: true },
    search: { enumerable: true },
    searchParams: { enumerable: true },
    hash: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"URL\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = URL;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: URL
  });

  if (globalNames.includes(\\"Window\\")) {
    Object.defineProperty(globalObject, \\"webkitURL\\", {
      configurable: true,
      writable: true,
      value: URL
    });
  }
};

const Impl = require(\\"../implementations/URL.js\\");
"
`;

exports[`without processors URLList.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"URLList\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'URLList'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"URLList\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor URLList is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper = new Proxy(wrapper, proxyHandler);

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper = new Proxy(wrapper, proxyHandler);

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class URLList {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    item(index) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'item' on 'URLList': 1 argument required, but only \\" + arguments.length + \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"unsigned long\\"](curArg, {
          context: \\"Failed to execute 'item' on 'URLList': parameter 1\\"
        });
        args.push(curArg);
      }
      return utils.tryWrapperForImpl(esValue[implSymbol].item(...args));
    }

    get length() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"length\\"];
    }
  }
  Object.defineProperties(URLList.prototype, {
    item: { enumerable: true },
    length: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"URLList\\", configurable: true },
    [Symbol.iterator]: { value: Array.prototype[Symbol.iterator], configurable: true, writable: true },
    keys: { value: Array.prototype.keys, configurable: true, enumerable: true, writable: true },
    values: { value: Array.prototype[Symbol.iterator], configurable: true, enumerable: true, writable: true },
    entries: { value: Array.prototype.entries, configurable: true, enumerable: true, writable: true },
    forEach: { value: Array.prototype.forEach, configurable: true, enumerable: true, writable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = URLList;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: URLList
  });
};

const proxyHandler = {
  get(target, P, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.get(target, P, receiver);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc === undefined) {
      const parent = Object.getPrototypeOf(target);
      if (parent === null) {
        return undefined;
      }
      return Reflect.get(target, P, receiver);
    }
    if (!desc.get && !desc.set) {
      return desc.value;
    }
    const getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return Reflect.apply(getter, receiver, []);
  },

  has(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.has(target, P);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc !== undefined) {
      return true;
    }
    const parent = Object.getPrototypeOf(target);
    if (parent !== null) {
      return Reflect.has(parent, P);
    }
    return false;
  },

  ownKeys(target) {
    const keys = new Set();

    for (const key of target[implSymbol][utils.supportedPropertyIndices]) {
      keys.add(\`\${key}\`);
    }

    for (const key of Reflect.ownKeys(target)) {
      keys.add(key);
    }
    return [...keys];
  },

  getOwnPropertyDescriptor(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.getOwnPropertyDescriptor(target, P);
    }
    let ignoreNamedProps = false;

    if (utils.isArrayIndexPropName(P)) {
      const index = P >>> 0;

      if (target[implSymbol][utils.supportsPropertyIndex](index)) {
        const indexedValue = target[implSymbol].item(index);
        return {
          writable: false,
          enumerable: true,
          configurable: true,
          value: utils.tryWrapperForImpl(indexedValue)
        };
      }
      ignoreNamedProps = true;
    }

    return Reflect.getOwnPropertyDescriptor(target, P);
  },

  set(target, P, V, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.set(target, P, V, receiver);
    }
    if (target === receiver) {
      utils.isArrayIndexPropName(P);
    }
    let ownDesc;

    if (utils.isArrayIndexPropName(P)) {
      const index = P >>> 0;

      if (target[implSymbol][utils.supportsPropertyIndex](index)) {
        const indexedValue = target[implSymbol].item(index);
        ownDesc = {
          writable: false,
          enumerable: true,
          configurable: true,
          value: utils.tryWrapperForImpl(indexedValue)
        };
      }
    }

    if (ownDesc === undefined) {
      ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
    }
    if (ownDesc === undefined) {
      const parent = Reflect.getPrototypeOf(target);
      if (parent !== null) {
        return Reflect.set(parent, P, V, receiver);
      }
      ownDesc = { writable: true, enumerable: true, configurable: true, value: undefined };
    }
    if (!ownDesc.writable) {
      return false;
    }
    if (!utils.isObject(receiver)) {
      return false;
    }
    const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
    let valueDesc;
    if (existingDesc !== undefined) {
      if (existingDesc.get || existingDesc.set) {
        return false;
      }
      if (!existingDesc.writable) {
        return false;
      }
      valueDesc = { value: V };
    } else {
      valueDesc = { writable: true, enumerable: true, configurable: true, value: V };
    }
    return Reflect.defineProperty(receiver, P, valueDesc);
  },

  defineProperty(target, P, desc) {
    if (typeof P === \\"symbol\\") {
      return Reflect.defineProperty(target, P, desc);
    }

    if (utils.isArrayIndexPropName(P)) {
      return false;
    }

    return Reflect.defineProperty(target, P, desc);
  },

  deleteProperty(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.deleteProperty(target, P);
    }

    if (utils.isArrayIndexPropName(P)) {
      const index = P >>> 0;
      return !target[implSymbol][utils.supportsPropertyIndex](index);
    }

    return Reflect.deleteProperty(target, P);
  },

  preventExtensions() {
    return false;
  }
};

const Impl = require(\\"../implementations/URLList.js\\");
"
`;

exports[`without processors URLSearchParams.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"URLSearchParams\\";

const IteratorPrototype = Object.create(utils.IteratorPrototype, {
  next: {
    value: function next() {
      const internal = this[utils.iterInternalSymbol];
      const { target, kind, index } = internal;
      const values = Array.from(target[implSymbol]);
      const len = values.length;
      if (index >= len) {
        return { value: undefined, done: true };
      }

      const pair = values[index];
      internal.index = index + 1;
      const [key, value] = pair.map(utils.tryWrapperForImpl);

      let result;
      switch (kind) {
        case \\"key\\":
          result = key;
          break;
        case \\"value\\":
          result = value;
          break;
        case \\"key+value\\":
          result = [key, value];
          break;
      }
      return { value: result, done: false };
    },
    writable: true,
    enumerable: true,
    configurable: true
  },
  [Symbol.toStringTag]: {
    value: \\"URLSearchParams Iterator\\",
    configurable: true
  }
});

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'URLSearchParams'.\`);
};

exports.createDefaultIterator = (target, kind) => {
  const iterator = Object.create(IteratorPrototype);
  Object.defineProperty(iterator, utils.iterInternalSymbol, {
    value: { target, kind, index: 0 },
    configurable: true
  });
  return iterator;
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"URLSearchParams\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor URLSearchParams is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\", \\"Worker\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class URLSearchParams {
    constructor() {
      const args = [];
      {
        let curArg = arguments[0];
        if (curArg !== undefined) {
          if (utils.isObject(curArg)) {
            if (curArg[Symbol.iterator] !== undefined) {
              if (!utils.isObject(curArg)) {
                throw new TypeError(
                  \\"Failed to construct 'URLSearchParams': parameter 1\\" + \\" sequence\\" + \\" is not an iterable object.\\"
                );
              } else {
                const V = [];
                const tmp = curArg;
                for (let nextItem of tmp) {
                  if (!utils.isObject(nextItem)) {
                    throw new TypeError(
                      \\"Failed to construct 'URLSearchParams': parameter 1\\" +
                        \\" sequence\\" +
                        \\"'s element\\" +
                        \\" is not an iterable object.\\"
                    );
                  } else {
                    const V = [];
                    const tmp = nextItem;
                    for (let nextItem of tmp) {
                      nextItem = conversions[\\"USVString\\"](nextItem, {
                        context:
                          \\"Failed to construct 'URLSearchParams': parameter 1\\" +
                          \\" sequence\\" +
                          \\"'s element\\" +
                          \\"'s element\\"
                      });

                      V.push(nextItem);
                    }
                    nextItem = V;
                  }

                  V.push(nextItem);
                }
                curArg = V;
              }
            } else {
              if (!utils.isObject(curArg)) {
                throw new TypeError(
                  \\"Failed to construct 'URLSearchParams': parameter 1\\" + \\" record\\" + \\" is not an object.\\"
                );
              } else {
                const result = Object.create(null);
                for (const key of Reflect.ownKeys(curArg)) {
                  const desc = Object.getOwnPropertyDescriptor(curArg, key);
                  if (desc && desc.enumerable) {
                    let typedKey = key;

                    typedKey = conversions[\\"USVString\\"](typedKey, {
                      context: \\"Failed to construct 'URLSearchParams': parameter 1\\" + \\" record\\" + \\"'s key\\"
                    });

                    let typedValue = curArg[key];

                    typedValue = conversions[\\"USVString\\"](typedValue, {
                      context: \\"Failed to construct 'URLSearchParams': parameter 1\\" + \\" record\\" + \\"'s value\\"
                    });

                    result[typedKey] = typedValue;
                  }
                }
                curArg = result;
              }
            }
          } else {
            curArg = conversions[\\"USVString\\"](curArg, {
              context: \\"Failed to construct 'URLSearchParams': parameter 1\\"
            });
          }
        } else {
          curArg = \\"\\";
        }
        args.push(curArg);
      }
      return exports.setup(Object.create(new.target.prototype), globalObject, args);
    }

    append(name, value) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 2) {
        throw new TypeError(
          \\"Failed to execute 'append' on 'URLSearchParams': 2 arguments required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"USVString\\"](curArg, {
          context: \\"Failed to execute 'append' on 'URLSearchParams': parameter 1\\"
        });
        args.push(curArg);
      }
      {
        let curArg = arguments[1];
        curArg = conversions[\\"USVString\\"](curArg, {
          context: \\"Failed to execute 'append' on 'URLSearchParams': parameter 2\\"
        });
        args.push(curArg);
      }
      return esValue[implSymbol].append(...args);
    }

    delete(name) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'delete' on 'URLSearchParams': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"USVString\\"](curArg, {
          context: \\"Failed to execute 'delete' on 'URLSearchParams': parameter 1\\"
        });
        args.push(curArg);
      }
      return esValue[implSymbol].delete(...args);
    }

    get(name) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'get' on 'URLSearchParams': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"USVString\\"](curArg, {
          context: \\"Failed to execute 'get' on 'URLSearchParams': parameter 1\\"
        });
        args.push(curArg);
      }
      return esValue[implSymbol].get(...args);
    }

    getAll(name) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'getAll' on 'URLSearchParams': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"USVString\\"](curArg, {
          context: \\"Failed to execute 'getAll' on 'URLSearchParams': parameter 1\\"
        });
        args.push(curArg);
      }
      return utils.tryWrapperForImpl(esValue[implSymbol].getAll(...args));
    }

    has(name) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'has' on 'URLSearchParams': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"USVString\\"](curArg, {
          context: \\"Failed to execute 'has' on 'URLSearchParams': parameter 1\\"
        });
        args.push(curArg);
      }
      return esValue[implSymbol].has(...args);
    }

    set(name, value) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 2) {
        throw new TypeError(
          \\"Failed to execute 'set' on 'URLSearchParams': 2 arguments required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"USVString\\"](curArg, {
          context: \\"Failed to execute 'set' on 'URLSearchParams': parameter 1\\"
        });
        args.push(curArg);
      }
      {
        let curArg = arguments[1];
        curArg = conversions[\\"USVString\\"](curArg, {
          context: \\"Failed to execute 'set' on 'URLSearchParams': parameter 2\\"
        });
        args.push(curArg);
      }
      return esValue[implSymbol].set(...args);
    }

    sort() {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol].sort();
    }

    toString() {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol].toString();
    }

    keys() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
      return exports.createDefaultIterator(this, \\"key\\");
    }

    values() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
      return exports.createDefaultIterator(this, \\"value\\");
    }

    entries() {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
      return exports.createDefaultIterator(this, \\"key+value\\");
    }

    forEach(callback) {
      if (!this || !exports.is(this)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
      if (arguments.length < 1) {
        throw new TypeError(\\"Failed to execute 'forEach' on 'iterable': 1 argument required, \\" + \\"but only 0 present.\\");
      }
      if (typeof callback !== \\"function\\") {
        throw new TypeError(
          \\"Failed to execute 'forEach' on 'iterable': The callback provided \\" + \\"as parameter 1 is not a function.\\"
        );
      }
      const thisArg = arguments[1];
      let pairs = Array.from(this[implSymbol]);
      let i = 0;
      while (i < pairs.length) {
        const [key, value] = pairs[i].map(utils.tryWrapperForImpl);
        callback.call(thisArg, value, key, this);
        pairs = Array.from(this[implSymbol]);
        i++;
      }
    }
  }
  Object.defineProperties(URLSearchParams.prototype, {
    append: { enumerable: true },
    delete: { enumerable: true },
    get: { enumerable: true },
    getAll: { enumerable: true },
    has: { enumerable: true },
    set: { enumerable: true },
    sort: { enumerable: true },
    toString: { enumerable: true },
    keys: { enumerable: true },
    values: { enumerable: true },
    entries: { enumerable: true },
    forEach: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"URLSearchParams\\", configurable: true },
    [Symbol.iterator]: { value: URLSearchParams.prototype.entries, configurable: true, writable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = URLSearchParams;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: URLSearchParams
  });
};

const Impl = require(\\"../implementations/URLSearchParams.js\\");
"
`;

exports[`without processors URLSearchParamsCollection.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"URLSearchParamsCollection\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'URLSearchParamsCollection'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"URLSearchParamsCollection\\"];
  if (ctor === undefined) {
    throw new Error(
      \\"Internal error: constructor URLSearchParamsCollection is not installed on the passed global object\\"
    );
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper = new Proxy(wrapper, proxyHandler);

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper = new Proxy(wrapper, proxyHandler);

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class URLSearchParamsCollection {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    item(index) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'item' on 'URLSearchParamsCollection': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"unsigned long\\"](curArg, {
          context: \\"Failed to execute 'item' on 'URLSearchParamsCollection': parameter 1\\"
        });
        args.push(curArg);
      }
      return utils.tryWrapperForImpl(esValue[implSymbol].item(...args));
    }

    namedItem(name) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'namedItem' on 'URLSearchParamsCollection': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'namedItem' on 'URLSearchParamsCollection': parameter 1\\"
        });
        args.push(curArg);
      }
      return utils.tryWrapperForImpl(esValue[implSymbol].namedItem(...args));
    }

    get length() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"length\\"];
    }
  }
  Object.defineProperties(URLSearchParamsCollection.prototype, {
    item: { enumerable: true },
    namedItem: { enumerable: true },
    length: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"URLSearchParamsCollection\\", configurable: true },
    [Symbol.iterator]: { value: Array.prototype[Symbol.iterator], configurable: true, writable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = URLSearchParamsCollection;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: URLSearchParamsCollection
  });
};

const proxyHandler = {
  get(target, P, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.get(target, P, receiver);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc === undefined) {
      const parent = Object.getPrototypeOf(target);
      if (parent === null) {
        return undefined;
      }
      return Reflect.get(target, P, receiver);
    }
    if (!desc.get && !desc.set) {
      return desc.value;
    }
    const getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return Reflect.apply(getter, receiver, []);
  },

  has(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.has(target, P);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc !== undefined) {
      return true;
    }
    const parent = Object.getPrototypeOf(target);
    if (parent !== null) {
      return Reflect.has(parent, P);
    }
    return false;
  },

  ownKeys(target) {
    const keys = new Set();

    for (const key of target[implSymbol][utils.supportedPropertyIndices]) {
      keys.add(\`\${key}\`);
    }

    for (const key of target[implSymbol][utils.supportedPropertyNames]) {
      if (!(key in target)) {
        keys.add(\`\${key}\`);
      }
    }

    for (const key of Reflect.ownKeys(target)) {
      keys.add(key);
    }
    return [...keys];
  },

  getOwnPropertyDescriptor(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.getOwnPropertyDescriptor(target, P);
    }
    let ignoreNamedProps = false;

    if (utils.isArrayIndexPropName(P)) {
      const index = P >>> 0;
      const indexedValue = target[implSymbol].item(index);
      if (indexedValue !== undefined) {
        return {
          writable: false,
          enumerable: true,
          configurable: true,
          value: utils.tryWrapperForImpl(indexedValue)
        };
      }
      ignoreNamedProps = true;
    }

    const namedValue = target[implSymbol].namedItem(P);

    if (namedValue !== null && !(P in target) && !ignoreNamedProps) {
      return {
        writable: false,
        enumerable: false,
        configurable: true,
        value: utils.tryWrapperForImpl(namedValue)
      };
    }

    return Reflect.getOwnPropertyDescriptor(target, P);
  },

  set(target, P, V, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.set(target, P, V, receiver);
    }
    if (target === receiver) {
      utils.isArrayIndexPropName(P);

      typeof P === \\"string\\" && !utils.isArrayIndexPropName(P);
    }
    let ownDesc;

    if (utils.isArrayIndexPropName(P)) {
      const index = P >>> 0;
      const indexedValue = target[implSymbol].item(index);
      if (indexedValue !== undefined) {
        ownDesc = {
          writable: false,
          enumerable: true,
          configurable: true,
          value: utils.tryWrapperForImpl(indexedValue)
        };
      }
    }

    if (ownDesc === undefined) {
      ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
    }
    if (ownDesc === undefined) {
      const parent = Reflect.getPrototypeOf(target);
      if (parent !== null) {
        return Reflect.set(parent, P, V, receiver);
      }
      ownDesc = { writable: true, enumerable: true, configurable: true, value: undefined };
    }
    if (!ownDesc.writable) {
      return false;
    }
    if (!utils.isObject(receiver)) {
      return false;
    }
    const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
    let valueDesc;
    if (existingDesc !== undefined) {
      if (existingDesc.get || existingDesc.set) {
        return false;
      }
      if (!existingDesc.writable) {
        return false;
      }
      valueDesc = { value: V };
    } else {
      valueDesc = { writable: true, enumerable: true, configurable: true, value: V };
    }
    return Reflect.defineProperty(receiver, P, valueDesc);
  },

  defineProperty(target, P, desc) {
    if (typeof P === \\"symbol\\") {
      return Reflect.defineProperty(target, P, desc);
    }

    if (utils.isArrayIndexPropName(P)) {
      return false;
    }
    if (!utils.hasOwn(target, P)) {
      const creating = !(target[implSymbol].namedItem(P) !== null);
      if (!creating) {
        return false;
      }
    }
    return Reflect.defineProperty(target, P, desc);
  },

  deleteProperty(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.deleteProperty(target, P);
    }

    if (utils.isArrayIndexPropName(P)) {
      const index = P >>> 0;
      return !(target[implSymbol].item(index) !== undefined);
    }

    if (target[implSymbol].namedItem(P) !== null && !(P in target)) {
      return false;
    }

    return Reflect.deleteProperty(target, P);
  },

  preventExtensions() {
    return false;
  }
};

const Impl = require(\\"../implementations/URLSearchParamsCollection.js\\");
"
`;

exports[`without processors URLSearchParamsCollection2.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const URL = require(\\"./URL.js\\");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;
const URLSearchParamsCollection = require(\\"./URLSearchParamsCollection.js\\");

const interfaceName = \\"URLSearchParamsCollection2\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'URLSearchParamsCollection2'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"URLSearchParamsCollection2\\"];
  if (ctor === undefined) {
    throw new Error(
      \\"Internal error: constructor URLSearchParamsCollection2 is not installed on the passed global object\\"
    );
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {
  URLSearchParamsCollection._internalSetup(wrapper, globalObject);
};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper = new Proxy(wrapper, proxyHandler);

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper = new Proxy(wrapper, proxyHandler);

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }

  if (globalObject.URLSearchParamsCollection === undefined) {
    throw new Error(
      \\"Internal error: attempting to evaluate URLSearchParamsCollection2 before URLSearchParamsCollection\\"
    );
  }
  class URLSearchParamsCollection2 extends globalObject.URLSearchParamsCollection {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }
  }
  Object.defineProperties(URLSearchParamsCollection2.prototype, {
    [Symbol.toStringTag]: { value: \\"URLSearchParamsCollection2\\", configurable: true },
    [Symbol.iterator]: { value: Array.prototype[Symbol.iterator], configurable: true, writable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = URLSearchParamsCollection2;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: URLSearchParamsCollection2
  });
};

const proxyHandler = {
  get(target, P, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.get(target, P, receiver);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc === undefined) {
      const parent = Object.getPrototypeOf(target);
      if (parent === null) {
        return undefined;
      }
      return Reflect.get(target, P, receiver);
    }
    if (!desc.get && !desc.set) {
      return desc.value;
    }
    const getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return Reflect.apply(getter, receiver, []);
  },

  has(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.has(target, P);
    }
    const desc = this.getOwnPropertyDescriptor(target, P);
    if (desc !== undefined) {
      return true;
    }
    const parent = Object.getPrototypeOf(target);
    if (parent !== null) {
      return Reflect.has(parent, P);
    }
    return false;
  },

  ownKeys(target) {
    const keys = new Set();

    for (const key of target[implSymbol][utils.supportedPropertyIndices]) {
      keys.add(\`\${key}\`);
    }

    for (const key of target[implSymbol][utils.supportedPropertyNames]) {
      if (!(key in target)) {
        keys.add(\`\${key}\`);
      }
    }

    for (const key of Reflect.ownKeys(target)) {
      keys.add(key);
    }
    return [...keys];
  },

  getOwnPropertyDescriptor(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.getOwnPropertyDescriptor(target, P);
    }
    let ignoreNamedProps = false;

    if (utils.isArrayIndexPropName(P)) {
      const index = P >>> 0;
      const indexedValue = target[implSymbol].item(index);
      if (indexedValue !== undefined) {
        return {
          writable: false,
          enumerable: true,
          configurable: true,
          value: utils.tryWrapperForImpl(indexedValue)
        };
      }
      ignoreNamedProps = true;
    }

    const namedValue = target[implSymbol].namedItem(P);

    if (namedValue !== null && !(P in target) && !ignoreNamedProps) {
      return {
        writable: true,
        enumerable: true,
        configurable: true,
        value: utils.tryWrapperForImpl(namedValue)
      };
    }

    return Reflect.getOwnPropertyDescriptor(target, P);
  },

  set(target, P, V, receiver) {
    if (typeof P === \\"symbol\\") {
      return Reflect.set(target, P, V, receiver);
    }
    if (target === receiver) {
      utils.isArrayIndexPropName(P);

      if (typeof P === \\"string\\" && !utils.isArrayIndexPropName(P)) {
        let namedValue = V;

        namedValue = URL.convert(namedValue, {
          context: \\"Failed to set the '\\" + P + \\"' property on 'URLSearchParamsCollection2': The provided value\\"
        });

        const creating = !(target[implSymbol].namedItem(P) !== null);
        if (creating) {
          target[implSymbol][utils.namedSetNew](P, namedValue);
        } else {
          target[implSymbol][utils.namedSetExisting](P, namedValue);
        }

        return true;
      }
    }
    let ownDesc;

    if (utils.isArrayIndexPropName(P)) {
      const index = P >>> 0;
      const indexedValue = target[implSymbol].item(index);
      if (indexedValue !== undefined) {
        ownDesc = {
          writable: false,
          enumerable: true,
          configurable: true,
          value: utils.tryWrapperForImpl(indexedValue)
        };
      }
    }

    if (ownDesc === undefined) {
      ownDesc = Reflect.getOwnPropertyDescriptor(target, P);
    }
    if (ownDesc === undefined) {
      const parent = Reflect.getPrototypeOf(target);
      if (parent !== null) {
        return Reflect.set(parent, P, V, receiver);
      }
      ownDesc = { writable: true, enumerable: true, configurable: true, value: undefined };
    }
    if (!ownDesc.writable) {
      return false;
    }
    if (!utils.isObject(receiver)) {
      return false;
    }
    const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);
    let valueDesc;
    if (existingDesc !== undefined) {
      if (existingDesc.get || existingDesc.set) {
        return false;
      }
      if (!existingDesc.writable) {
        return false;
      }
      valueDesc = { value: V };
    } else {
      valueDesc = { writable: true, enumerable: true, configurable: true, value: V };
    }
    return Reflect.defineProperty(receiver, P, valueDesc);
  },

  defineProperty(target, P, desc) {
    if (typeof P === \\"symbol\\") {
      return Reflect.defineProperty(target, P, desc);
    }

    if (utils.isArrayIndexPropName(P)) {
      return false;
    }
    if (!utils.hasOwn(target, P)) {
      if (desc.get || desc.set) {
        return false;
      }

      let namedValue = desc.value;

      namedValue = URL.convert(namedValue, {
        context: \\"Failed to set the '\\" + P + \\"' property on 'URLSearchParamsCollection2': The provided value\\"
      });

      const creating = !(target[implSymbol].namedItem(P) !== null);
      if (creating) {
        target[implSymbol][utils.namedSetNew](P, namedValue);
      } else {
        target[implSymbol][utils.namedSetExisting](P, namedValue);
      }

      return true;
    }
    return Reflect.defineProperty(target, P, desc);
  },

  deleteProperty(target, P) {
    if (typeof P === \\"symbol\\") {
      return Reflect.deleteProperty(target, P);
    }

    if (utils.isArrayIndexPropName(P)) {
      const index = P >>> 0;
      return !(target[implSymbol].item(index) !== undefined);
    }

    if (target[implSymbol].namedItem(P) !== null && !(P in target)) {
      return false;
    }

    return Reflect.deleteProperty(target, P);
  },

  preventExtensions() {
    return false;
  }
};

const Impl = require(\\"../implementations/URLSearchParamsCollection2.js\\");
"
`;

exports[`without processors UnderscoredProperties.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"UnderscoredProperties\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'UnderscoredProperties'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"UnderscoredProperties\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor UnderscoredProperties is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class UnderscoredProperties {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    operation(sequence) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'operation' on 'UnderscoredProperties': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        if (!utils.isObject(curArg)) {
          throw new TypeError(
            \\"Failed to execute 'operation' on 'UnderscoredProperties': parameter 1\\" + \\" is not an iterable object.\\"
          );
        } else {
          const V = [];
          const tmp = curArg;
          for (let nextItem of tmp) {
            nextItem = conversions[\\"DOMString\\"](nextItem, {
              context: \\"Failed to execute 'operation' on 'UnderscoredProperties': parameter 1\\" + \\"'s element\\"
            });

            V.push(nextItem);
          }
          curArg = V;
        }
        args.push(curArg);
      }
      return esValue[implSymbol].operation(...args);
    }

    get attribute() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"attribute\\"];
    }

    set attribute(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"byte\\"](V, {
        context: \\"Failed to set the 'attribute' property on 'UnderscoredProperties': The provided value\\"
      });

      esValue[implSymbol][\\"attribute\\"] = V;
    }

    static static(void_) {
      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'static' on 'UnderscoredProperties': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'static' on 'UnderscoredProperties': parameter 1\\"
        });
        args.push(curArg);
      }
      return Impl.implementation.static(...args);
    }
  }
  Object.defineProperties(UnderscoredProperties.prototype, {
    operation: { enumerable: true },
    attribute: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"UnderscoredProperties\\", configurable: true },
    const: { value: 42, enumerable: true }
  });
  Object.defineProperties(UnderscoredProperties, {
    static: { enumerable: true },
    const: { value: 42, enumerable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = UnderscoredProperties;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: UnderscoredProperties
  });
};

const Impl = require(\\"../implementations/UnderscoredProperties.js\\");
"
`;

exports[`without processors Unscopable.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"Unscopable\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'Unscopable'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"Unscopable\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor Unscopable is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class Unscopable {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    get unscopableTest() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"unscopableTest\\"];
    }

    set unscopableTest(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"boolean\\"](V, {
        context: \\"Failed to set the 'unscopableTest' property on 'Unscopable': The provided value\\"
      });

      esValue[implSymbol][\\"unscopableTest\\"] = V;
    }

    get unscopableMixin() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      return esValue[implSymbol][\\"unscopableMixin\\"];
    }

    set unscopableMixin(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      V = conversions[\\"boolean\\"](V, {
        context: \\"Failed to set the 'unscopableMixin' property on 'Unscopable': The provided value\\"
      });

      esValue[implSymbol][\\"unscopableMixin\\"] = V;
    }
  }
  Object.defineProperties(Unscopable.prototype, {
    unscopableTest: { enumerable: true },
    unscopableMixin: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"Unscopable\\", configurable: true },
    [Symbol.unscopables]: {
      value: { unscopableTest: true, unscopableMixin: true, __proto__: null },
      configurable: true
    }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = Unscopable;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: Unscopable
  });
};

const Impl = require(\\"../implementations/Unscopable.js\\");
"
`;

exports[`without processors Variadic.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const URL = require(\\"./URL.js\\");
const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"Variadic\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'Variadic'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"Variadic\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor Variadic is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class Variadic {
    constructor() {
      throw new TypeError(\\"Illegal constructor\\");
    }

    simple1() {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
      const args = [];
      for (let i = 0; i < arguments.length; i++) {
        let curArg = arguments[i];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'simple1' on 'Variadic': parameter \\" + (i + 1)
        });
        args.push(curArg);
      }
      return esValue[implSymbol].simple1(...args);
    }

    simple2(first) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'simple2' on 'Variadic': 1 argument required, but only \\" + arguments.length + \\" present.\\"
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = conversions[\\"DOMString\\"](curArg, {
          context: \\"Failed to execute 'simple2' on 'Variadic': parameter 1\\"
        });
        args.push(curArg);
      }
      for (let i = 1; i < arguments.length; i++) {
        let curArg = arguments[i];
        curArg = URL.convert(curArg, { context: \\"Failed to execute 'simple2' on 'Variadic': parameter \\" + (i + 1) });
        args.push(curArg);
      }
      return esValue[implSymbol].simple2(...args);
    }

    overloaded1() {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }
      const args = [];
      switch (arguments.length) {
        case 0:
          break;
        default: {
          let curArg = arguments[0];
          if (typeof curArg === \\"number\\") {
            for (let i = 0; i < arguments.length; i++) {
              let curArg = arguments[i];
              curArg = conversions[\\"unsigned long\\"](curArg, {
                context: \\"Failed to execute 'overloaded1' on 'Variadic': parameter \\" + (i + 1)
              });
              args.push(curArg);
            }
          } else {
            for (let i = 0; i < arguments.length; i++) {
              let curArg = arguments[i];
              curArg = conversions[\\"DOMString\\"](curArg, {
                context: \\"Failed to execute 'overloaded1' on 'Variadic': parameter \\" + (i + 1)
              });
              args.push(curArg);
            }
          }
        }
      }
      return esValue[implSymbol].overloaded1(...args);
    }

    overloaded2(first) {
      const esValue = this !== null && this !== undefined ? this : globalObject;
      if (!exports.is(esValue)) {
        throw new TypeError(\\"Illegal invocation\\");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          \\"Failed to execute 'overloaded2' on 'Variadic': 1 argument required, but only \\" +
            arguments.length +
            \\" present.\\"
        );
      }
      const args = [];
      switch (arguments.length) {
        case 1:
          {
            let curArg = arguments[0];
            if (typeof curArg === \\"number\\") {
              {
                let curArg = arguments[0];
                curArg = conversions[\\"unsigned long\\"](curArg, {
                  context: \\"Failed to execute 'overloaded2' on 'Variadic': parameter 1\\"
                });
                args.push(curArg);
              }
            } else {
              {
                let curArg = arguments[0];
                curArg = conversions[\\"DOMString\\"](curArg, {
                  context: \\"Failed to execute 'overloaded2' on 'Variadic': parameter 1\\"
                });
                args.push(curArg);
              }
            }
          }
          break;
        default: {
          let curArg = arguments[0];
          if (typeof curArg === \\"number\\") {
            {
              let curArg = arguments[0];
              curArg = conversions[\\"unsigned long\\"](curArg, {
                context: \\"Failed to execute 'overloaded2' on 'Variadic': parameter 1\\"
              });
              args.push(curArg);
            }
            for (let i = 1; i < arguments.length; i++) {
              let curArg = arguments[i];
              curArg = conversions[\\"DOMString\\"](curArg, {
                context: \\"Failed to execute 'overloaded2' on 'Variadic': parameter \\" + (i + 1)
              });
              args.push(curArg);
            }
          } else {
            {
              let curArg = arguments[0];
              curArg = conversions[\\"DOMString\\"](curArg, {
                context: \\"Failed to execute 'overloaded2' on 'Variadic': parameter 1\\"
              });
              args.push(curArg);
            }
            for (let i = 1; i < arguments.length; i++) {
              let curArg = arguments[i];
              curArg = conversions[\\"DOMString\\"](curArg, {
                context: \\"Failed to execute 'overloaded2' on 'Variadic': parameter \\" + (i + 1)
              });
              args.push(curArg);
            }
          }
        }
      }
      return esValue[implSymbol].overloaded2(...args);
    }
  }
  Object.defineProperties(Variadic.prototype, {
    simple1: { enumerable: true },
    simple2: { enumerable: true },
    overloaded1: { enumerable: true },
    overloaded2: { enumerable: true },
    [Symbol.toStringTag]: { value: \\"Variadic\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = Variadic;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: Variadic
  });
};

const Impl = require(\\"../implementations/Variadic.js\\");
"
`;

exports[`without processors ZeroArgConstructor.webidl 1`] = `
"\\"use strict\\";

const conversions = require(\\"webidl-conversions\\");
const utils = require(\\"./utils.js\\");

const implSymbol = utils.implSymbol;
const ctorRegistrySymbol = utils.ctorRegistrySymbol;

const interfaceName = \\"ZeroArgConstructor\\";

exports.is = value => {
  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
};
exports.isImpl = value => {
  return utils.isObject(value) && value instanceof Impl.implementation;
};
exports.convert = (value, { context = \\"The provided value\\" } = {}) => {
  if (exports.is(value)) {
    return utils.implForWrapper(value);
  }
  throw new TypeError(\`\${context} is not of type 'ZeroArgConstructor'.\`);
};

function makeWrapper(globalObject) {
  if (globalObject[ctorRegistrySymbol] === undefined) {
    throw new Error(\\"Internal error: invalid global object\\");
  }

  const ctor = globalObject[ctorRegistrySymbol][\\"ZeroArgConstructor\\"];
  if (ctor === undefined) {
    throw new Error(\\"Internal error: constructor ZeroArgConstructor is not installed on the passed global object\\");
  }

  return Object.create(ctor.prototype);
}

exports.create = (globalObject, constructorArgs, privateData) => {
  const wrapper = makeWrapper(globalObject);
  return exports.setup(wrapper, globalObject, constructorArgs, privateData);
};

exports.createImpl = (globalObject, constructorArgs, privateData) => {
  const wrapper = exports.create(globalObject, constructorArgs, privateData);
  return utils.implForWrapper(wrapper);
};

exports._internalSetup = (wrapper, globalObject) => {};

exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
  privateData.wrapper = wrapper;

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: new Impl.implementation(globalObject, constructorArgs, privateData),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper;
};

exports.new = globalObject => {
  const wrapper = makeWrapper(globalObject);

  exports._internalSetup(wrapper, globalObject);
  Object.defineProperty(wrapper, implSymbol, {
    value: Object.create(Impl.implementation.prototype),
    configurable: true
  });

  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
  if (Impl.init) {
    Impl.init(wrapper[implSymbol]);
  }
  return wrapper[implSymbol];
};

const exposed = new Set([\\"Window\\"]);

exports.install = (globalObject, globalNames) => {
  if (!globalNames.some(globalName => exposed.has(globalName))) {
    return;
  }
  class ZeroArgConstructor {
    constructor() {
      return exports.setup(Object.create(new.target.prototype), globalObject, undefined);
    }
  }
  Object.defineProperties(ZeroArgConstructor.prototype, {
    [Symbol.toStringTag]: { value: \\"ZeroArgConstructor\\", configurable: true }
  });
  if (globalObject[ctorRegistrySymbol] === undefined) {
    globalObject[ctorRegistrySymbol] = Object.create(null);
  }
  globalObject[ctorRegistrySymbol][interfaceName] = ZeroArgConstructor;

  Object.defineProperty(globalObject, interfaceName, {
    configurable: true,
    writable: true,
    value: ZeroArgConstructor
  });
};

const Impl = require(\\"../implementations/ZeroArgConstructor.js\\");
"
`;
